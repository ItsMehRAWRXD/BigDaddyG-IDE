<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' ws://localhost:8001 ws://localhost:3000 http://localhost:3000 http://localhost:11441 http://localhost:11434 http://127.0.0.1:11434 https: http:; frame-src 'self' https: http: data:; child-src 'self' https: http: data:;">
    <title>BigDaddyG Self-Made Browser</title>
    <style>
        :root {
            --bg: #0a0a0a;
            --cyan: #00d4ff;
            --orange: #ff6b35;
            --teal: #1dd1a1;
            --void: #000;
            --green: #00ff00;
            --red: #ff4757;
            --yellow: #ffaa00;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Courier New', monospace;
        }
        
        /* ========================================
           4K 240Hz ULTRA-SMOOTH OPTIMIZATION
           For high refresh rate monitors
        ======================================== */
        
        @media (min-resolution: 2dppx) {
            /* 4K/Retina optimization */
            * {
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
                text-rendering: optimizeLegibility;
            }
        }
        
        /* Force GPU acceleration for buttery 240Hz */
        .pane-resizer,
        .task-bubble,
        .beam,
        .beam-trail,
        .agent-node,
        .stream-particle,
        .pane-bubble,
        #token-stream-overlay,
        #beam-layer,
        .expandable-pane {
            will-change: transform;
            transform: translateZ(0);
            backface-visibility: hidden;
        }
        
        /* High refresh rate canvas rendering */
        canvas {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        body {
            display: flex;
            height: 100vh;
            background: transparent;
            color: var(--cyan);
            overflow: hidden;
            margin: 0;
            padding: 0;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        /* HTML element gets the base background */
        html {
            background: var(--bg);
        }
        
        /* ===== FLOATING AI CHAT (ALWAYS ON TOP) ===== */
        #floating-ai {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 400px;
            max-height: 600px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid var(--cyan);
            border-radius: 10px;
            z-index: 99999;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px rgba(0, 212, 255, 0.3);
        }
        
        #floating-ai-header {
            background: var(--cyan);
            color: var(--void);
            padding: 10px;
            font-weight: bold;
            border-radius: 8px 8px 0 0;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #floating-ai-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            max-height: 400px;
        }
        
        #floating-ai-input {
            padding: 10px;
            border-top: 1px solid var(--cyan);
            display: flex;
            gap: 5px;
        }
        
        #floating-ai-input input {
            flex: 1;
            background: var(--bg);
            color: var(--cyan);
            border: 1px solid var(--cyan);
            padding: 8px;
            border-radius: 3px;
        }
        
        #floating-ai-input button {
            background: var(--green);
            color: var(--void);
            border: none;
            padding: 8px 15px;
            cursor: pointer;
            border-radius: 3px;
            font-weight: bold;
        }
        
        #floating-ai-input button:hover {
            background: var(--teal);
        }
        
        .ai-msg {
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(0, 212, 255, 0.1);
            border-left: 3px solid var(--cyan);
            border-radius: 3px;
            font-size: 12px;
        }
        
        .ai-msg.user {
            background: rgba(255, 107, 53, 0.1);
            border-left-color: var(--orange);
        }
        
        .minimize-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: var(--void);
            padding: 2px 8px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 10px;
        }

        /* ===== LEFT PANEL = CODE ===== */
        #left-panel {
            width: 400px;
            display: flex;
            flex-direction: column;
            border-right: 2px solid var(--cyan);
            background: var(--void);
            min-height: 100vh;
            position: relative;
        }

        #code-header {
            padding: 10px;
            background: var(--void);
            border-bottom: 1px solid var(--cyan);
            font-size: 14px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .new-chat-btn {
            background: var(--green);
            color: var(--void);
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
        }

        .new-chat-btn:hover {
            background: var(--teal);
        }

        #code {
            flex: 1;
            width: 100%;
            background: var(--bg);
            color: var(--cyan);
            border: 1px solid var(--cyan);
            outline: none;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            resize: none;
            tab-size: 2;
            min-height: 300px;
        }

        .view-container {
            display: none;
            flex: 1;
            padding: 20px;
            background: var(--void);
            color: var(--cyan);
            overflow-y: auto;
        }

        .view-container.active {
            display: flex;
            flex-direction: column;
        }

        .main-view {
            display: flex;
            flex-direction: column;
            height: 100%;
            padding: 0;
        }

        .dashboard-view {
            height: 100%;
            overflow-y: auto;
        }

        .view-btn {
            background: var(--gray);
            color: var(--cyan);
            border: 1px solid var(--cyan);
            padding: 4px 8px;
            margin-left: 5px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 11px;
        }

        .view-btn:hover,
        .view-btn.active {
            background: var(--cyan);
            color: var(--bg);
        }

        #code-controls {
            display: flex;
            padding: 10px;
            background: var(--void);
            border-top: 1px solid var(--cyan);
            gap: 5px;
        }

        #code-controls button {
            background: var(--orange);
            color: var(--void);
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 3px;
        }

        #code-controls button:hover {
            background: var(--yellow);
        }

        /* ===== MIDDLE PANEL = CONSOLE ===== */
        #middle-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 2px solid var(--cyan);
            background: var(--void);
            min-height: 100vh;
            max-height: 100vh;
            overflow: hidden;
        }

        #console-header {
            padding: 10px;
            background: var(--void);
            border-bottom: 1px solid var(--cyan);
            font-size: 14px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #console {
            flex: 1;
            padding: 10px;
            background: var(--bg);
            color: var(--cyan);
            overflow-y: auto;
            overflow-x: hidden;
            font-size: 12px;
            line-height: 1.4;
            max-height: calc(100vh - 200px);
            min-height: 300px;
        }

        #console-input {
            display: flex;
            padding: 10px;
            background: var(--void);
            border-top: 1px solid var(--cyan);
        }

        #console-input input {
            flex: 1;
            background: var(--bg);
            color: var(--cyan);
            border: 1px solid var(--cyan);
            padding: 8px;
            font-family: monospace;
        }

        #console-input button {
            background: var(--teal);
            color: var(--void);
            border: none;
            padding: 8px 15px;
            margin-left: 5px;
            cursor: pointer;
        }

        /* ===== RIGHT PANEL = AGENTS ===== */
        #right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--void);
            min-height: 100vh;
        }

        #agents-header {
            padding: 10px;
            background: var(--void);
            border-bottom: 1px solid var(--cyan);
            font-size: 14px;
            font-weight: bold;
        }

        #agents {
            flex: 1;
            padding: 10px;
            background: var(--bg);
            overflow-y: auto;
        }

        /* ===== AGENT STATUS ===== */
        .agent-status {
            display: flex;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            background: rgba(0, 212, 255, 0.05);
            border: 1px solid rgba(0, 212, 255, 0.2);
            border-radius: 3px;
        }

        .agent-status .indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .status-idle { background: #666; }
        .status-active { background: var(--green); animation: pulse 1s infinite; }
        .status-busy { background: var(--orange); }
        .status-error { background: var(--red); }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* ===== CONSOLE LOGS ===== */
        .log-entry {
            margin: 3px 0;
            padding: 2px 0;
            word-wrap: break-word;
        }

        .log-time { color: #666; font-size: 10px; }
        .log-info { color: var(--cyan); }
        .log-success { color: var(--green); font-weight: bold; }
        .log-error { color: var(--red); font-weight: bold; }
        .log-warning { color: var(--yellow); }
        .log-debug { color: #888; }

        /* ===== BROWSER CONTROLS ===== */
        #browser-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        #browser-controls button {
            background: var(--cyan);
            color: var(--void);
            border: none;
            padding: 6px 12px;
            cursor: pointer;
            border-radius: 3px;
        }

        #browser-controls button:hover {
            background: var(--teal);
        }

        /* ===== RIGHT PANEL TABS ===== */
        #right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--void);
            border-left: 2px solid var(--cyan);
            position: relative;
            overflow: hidden;
        }

        #tab-navigation {
            display: flex;
            background: var(--bg);
            border-bottom: 1px solid var(--cyan);
        }

        .tab-btn {
            flex: 1;
            padding: 10px;
            background: var(--void);
            color: var(--cyan);
            border: none;
            cursor: pointer;
            font-size: 12px;
            border-right: 1px solid var(--cyan);
            transition: all 0.3s ease;
        }

        .tab-btn:last-child {
            border-right: none;
        }

        .tab-btn:hover {
            background: rgba(0, 212, 255, 0.1);
        }

        .tab-btn.active {
            background: var(--cyan);
            color: var(--bg);
        }

        .tab-content {
            display: none;
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background: var(--void);
            color: var(--cyan);
            height: calc(100vh - 150px);
        }

        .tab-content.active {
            display: block;
        }

        /* Default tab content for agents */
        #agents-tab {
            display: block !important;
        }

        /* Make sure all tab content has proper styling */
        #agents-tab, #extensions-tab, #tools-tab, #history-tab {
            background: var(--void);
            color: var(--cyan);
            border: none;
            height: 100%;
        }

        /* ===== EXTENSIONS MARKETPLACE ===== */
        .extension-category {
            margin-bottom: 20px;
        }

        .extension-category h4 {
            color: var(--orange);
            margin-bottom: 10px;
            font-size: 14px;
        }

        .extension-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }

        .extension-card {
            display: flex;
            align-items: center;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .extension-card:hover {
            background: rgba(255, 107, 53, 0.1);
            border-color: var(--orange);
        }

        .extension-icon {
            font-size: 24px;
            margin-right: 12px;
        }

        .extension-info {
            flex: 1;
        }

        .extension-info strong {
            color: var(--cyan);
            display: block;
            margin-bottom: 2px;
        }

        .extension-info small {
            color: #888;
            font-size: 11px;
        }

        .install-btn {
            background: var(--green);
            color: var(--bg);
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
        }

        .install-btn:hover {
            background: var(--teal);
        }

        /* ===== TOOLS TAB ===== */
        .tool-section {
            margin-bottom: 20px;
        }

        .tool-section h4 {
            color: var(--orange);
            margin-bottom: 10px;
            font-size: 14px;
        }

        .tool-btn {
            display: block;
            width: 100%;
            padding: 8px 12px;
            margin-bottom: 5px;
            background: rgba(255, 255, 255, 0.05);
            color: var(--cyan);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .tool-btn:hover {
            background: rgba(0, 212, 255, 0.1);
            border-color: var(--cyan);
        }

        /* ===== HISTORY TAB ===== */
        #history-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .history-entry {
            padding: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
            color: #ccc;
        }

        .history-entry:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .history-controls {
            display: flex;
            gap: 10px;
        }

        .history-btn {
            flex: 1;
            padding: 8px;
            background: var(--orange);
            color: var(--void);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .history-btn:hover {
            background: var(--red);
        }

        /* ===== AGENT ACTIONS ===== */
        .agent-actions {
            display: flex;
            gap: 5px;
        }

        .agent-actions button {
            padding: 2px 6px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            color: var(--cyan);
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s ease;
        }

        .agent-actions button:hover {
            background: rgba(0, 212, 255, 0.2);
        }

        /* ===== TOP TAB NAVIGATION (MOVED FROM BOTTOM) ===== */
        #bottom-tab-navigation {
            position: sticky;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            background: rgba(0, 0, 0, 0.95);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-bottom: 2px solid var(--cyan);
            z-index: 500;
            overflow-x: auto;
            overflow-y: hidden;
            flex-wrap: wrap;
            transition: all 0.3s ease;
        }

        #bottom-tab-navigation.collapsed {
            max-height: 40px;
        }

        #bottom-tab-navigation.expanded {
            max-height: none;
        }

        .tab-nav-header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px;
            background: var(--void);
            border-bottom: 1px solid rgba(0, 212, 255, 0.3);
        }

        .tab-nav-title {
            color: var(--cyan);
            font-size: 12px;
            font-weight: bold;
        }

        .tab-collapse-btn {
            background: var(--cyan);
            color: var(--void);
            border: none;
            padding: 2px 8px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
        }

        .tab-collapse-btn:hover {
            background: var(--teal);
        }

        .tab-buttons-container {
            display: flex;
            width: 100%;
            flex-wrap: wrap;
        }

        .bottom-tab-btn {
            flex: 1;
            min-width: 120px;
            padding: 12px 8px;
            background: var(--void);
            color: var(--cyan);
            border: none;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            border-right: 1px solid rgba(0, 212, 255, 0.3);
            transition: all 0.3s ease;
            text-align: center;
            white-space: nowrap;
        }

        .bottom-tab-btn:last-child {
            border-right: none;
        }

        .bottom-tab-btn:hover {
            background: rgba(0, 212, 255, 0.2);
            color: var(--orange);
        }

        .bottom-tab-btn.active {
            background: var(--cyan);
            color: var(--bg);
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        /* ===== TRANSPARENCY & CHAMELEON EFFECTS ===== */
        .chameleon-text {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #f9ca24, #ff6b6b);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: chameleon 3s ease infinite;
        }

        @keyframes chameleon {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .transparent-shader {
            background: rgba(255, 255, 255, 0.05);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Command Palette Styles */
        #command-palette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding-top: 100px;
        }

        .command-palette-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
        }

        .command-palette-content {
            position: relative;
            background: var(--void);
            border: 2px solid var(--cyan);
            border-radius: 8px;
            width: 600px;
            max-height: 400px;
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.3);
        }

        #command-input {
            width: 100%;
            padding: 15px;
            background: var(--void);
            border: none;
            border-bottom: 1px solid var(--cyan);
            color: var(--cyan);
            font-size: 16px;
            font-family: 'Courier New', monospace;
            outline: none;
        }

        #command-input::placeholder {
            color: rgba(0, 212, 255, 0.5);
        }

        .command-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .command-item {
            padding: 12px 15px;
            color: var(--cyan);
            cursor: pointer;
            border-bottom: 1px solid rgba(0, 212, 255, 0.1);
            transition: all 0.2s ease;
        }

        .command-item:hover {
            background: rgba(0, 212, 255, 0.1);
            color: var(--orange);
        }

        .command-item:last-child {
            border-bottom: none;
        }

        /* Settings Modal Styles */
        #settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settings-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
        }

        .settings-content {
            position: relative;
            background: var(--void);
            border: 2px solid var(--cyan);
            border-radius: 8px;
            padding: 30px;
            width: 500px;
            max-height: 600px;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.3);
        }

        .settings-content h3 {
            color: var(--cyan);
            margin-bottom: 20px;
            text-align: center;
        }

        .setting-group {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .setting-group label {
            color: var(--cyan);
            font-weight: bold;
            min-width: 120px;
        }

        .setting-group select,
        .setting-group input[type="range"] {
            background: var(--void);
            border: 1px solid var(--cyan);
            color: var(--cyan);
            padding: 5px;
            border-radius: 4px;
        }

        .setting-group input[type="checkbox"] {
            transform: scale(1.2);
        }

        .settings-content button {
            background: var(--cyan);
            color: var(--void);
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .settings-content button:hover {
            background: var(--orange);
            transform: translateY(-2px);
        }

        /* Status Bar Styles */
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: var(--void);
            border-top: 1px solid var(--cyan);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            font-size: 12px;
            z-index: 1000;
            box-shadow: 0 -2px 10px rgba(0, 212, 255, 0.1);
        }

        .status-left, .status-center, .status-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .status-item {
            color: var(--cyan);
            font-family: 'Courier New', monospace;
            white-space: nowrap;
        }

        .status-item:hover {
            color: var(--orange);
        }

        #connection-status.connected {
            color: var(--green);
        }

        /* Copilot Context Menu Styles */
        .code-context-menu {
            position: fixed;
            background: var(--void);
            border: 2px solid var(--cyan);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.5);
            padding: 8px 0;
            min-width: 220px;
            z-index: 100000;
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
            transition: all 0.15s ease;
        }

        .code-context-menu.active {
            opacity: 1;
            transform: scale(1);
            pointer-events: all;
        }

        .context-menu-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            color: var(--cyan);
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Courier New', monospace;
        }

        .context-menu-item:hover {
            background: rgba(0, 212, 255, 0.1);
            color: var(--orange);
        }

        .context-menu-icon {
            font-size: 18px;
        }

        .context-menu-label {
            flex: 1;
        }

        .context-menu-shortcut {
            font-size: 11px;
            color: rgba(0, 212, 255, 0.5);
        }

        .context-menu-separator {
            height: 1px;
            background: rgba(0, 212, 255, 0.3);
            margin: 5px 0;
        }

        /* Resizable Panes System */
        .pane-resizer {
            width: 6px;
            background: linear-gradient(to bottom, #666, #222);
            cursor: col-resize;
            user-select: none;
            transition: background 0.2s ease;
            position: relative;
            z-index: 10;
        }

        .pane-resizer:hover {
            background: linear-gradient(to bottom, var(--cyan), var(--orange));
            box-shadow: 0 0 10px var(--cyan);
        }

        .pane-resizer.resizing {
            background: linear-gradient(to bottom, var(--orange), var(--red));
        }

        #left-panel, #middle-left-panel, #middle-panel, #middle-right-panel, #right-panel {
            transition: flex 0.3s ease-in-out;
            overflow: hidden;
        }
        
        /* 5-Pane specific styles */
        #left-panel {
            display: flex;
            flex-direction: column;
        }
        
        #middle-left-panel {
            display: flex;
            flex-direction: column;
        }
        
        #middle-panel {
            display: flex;
            flex-direction: column;
        }
        
        #middle-right-panel {
            display: flex;
            flex-direction: column;
        }
        
        #right-panel {
            display: flex;
            flex-direction: column;
        }

        /* Task Bubble Layer */
        #task-bubble-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 50;
            overflow: hidden;
        }

        .task-bubble {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(0, 246, 255, 0.9), rgba(0, 68, 255, 0.7));
            box-shadow: 0 0 20px rgba(0, 246, 255, 0.6), inset 0 0 10px rgba(255, 255, 255, 0.3);
            animation: bubbleFloat 4s infinite ease-in-out, bubblePulse 2s infinite ease-in-out;
            pointer-events: auto;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            border: 2px solid rgba(0, 246, 255, 0.4);
        }

        .task-bubble:hover {
            transform: scale(1.3) rotate(5deg);
            box-shadow: 0 0 40px rgba(0, 246, 255, 1), inset 0 0 20px rgba(255, 255, 255, 0.5);
            animation-play-state: paused;
        }

        .task-bubble.popping {
            animation: bubblePop 0.5s ease-out forwards;
        }

        @keyframes bubbleFloat {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            25% { transform: translateY(-15px) rotate(5deg); }
            50% { transform: translateY(0) rotate(0deg); }
            75% { transform: translateY(-10px) rotate(-5deg); }
        }

        @keyframes bubblePulse {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 246, 255, 0.6); }
            50% { box-shadow: 0 0 40px rgba(0, 246, 255, 1); }
        }

        @keyframes bubblePop {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.8; }
            100% { transform: scale(0); opacity: 0; }
        }

        .glow-trail {
            position: absolute;
            pointer-events: none;
            opacity: 0;
        }

        .glow-trail-particle {
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: var(--cyan);
            box-shadow: 0 0 8px var(--cyan);
            animation: trailFade 1.5s ease-out forwards;
        }

        @keyframes trailFade {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.3); }
        }

        .bubble-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--void);
            border: 1px solid var(--cyan);
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 10px;
            color: var(--cyan);
            white-space: nowrap;
            font-family: 'Courier New', monospace;
            pointer-events: none;
        }

        /* Task Modal */
        .task-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: var(--void);
            border: 3px solid var(--cyan);
            border-radius: 15px;
            padding: 25px;
            min-width: 400px;
            max-width: 600px;
            z-index: 100000;
            box-shadow: 0 20px 60px rgba(0, 212, 255, 0.5);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            pointer-events: none;
        }

        .task-modal.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: all;
        }

        .task-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--cyan);
        }

        .task-modal-title {
            font-size: 20px;
            color: var(--orange);
            font-weight: bold;
        }

        .task-modal-close {
            background: var(--red);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s ease;
        }

        .task-modal-close:hover {
            background: var(--orange);
            transform: rotate(90deg);
        }

        .task-subtasks {
            margin-top: 15px;
        }

        .subtask-item {
            padding: 10px;
            margin: 8px 0;
            background: rgba(0, 212, 255, 0.05);
            border-left: 3px solid var(--cyan);
            border-radius: 5px;
            color: var(--cyan);
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .subtask-item:hover {
            background: rgba(0, 212, 255, 0.15);
            transform: translateX(5px);
        }

        .subtask-checkbox {
            width: 18px;
            height: 18px;
            border: 2px solid var(--cyan);
            border-radius: 3px;
            cursor: pointer;
        }

        .subtask-checkbox.checked {
            background: var(--green);
            border-color: var(--green);
        }

        /* Token Streaming Visualization Overlay */
        #token-stream-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 50000;
            overflow: hidden;
        }

        .stream-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: var(--cyan);
            box-shadow: 0 0 10px var(--cyan), 0 0 20px var(--cyan);
            animation: streamFlow 2s ease-in-out forwards;
            opacity: 0;
        }

        @keyframes streamFlow {
            0% {
                opacity: 0;
                transform: scale(0);
            }
            10% {
                opacity: 1;
                transform: scale(1);
            }
            90% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: scale(0.5);
            }
        }

        .stream-pulse {
            position: absolute;
            width: 100px;
            height: 100px;
            border: 2px solid var(--cyan);
            border-radius: 50%;
            animation: pulseBloom 1.5s ease-out forwards;
            pointer-events: none;
        }

        @keyframes pulseBloom {
            0% {
                opacity: 1;
                transform: scale(0);
            }
            100% {
                opacity: 0;
                transform: scale(2);
            }
        }

        .agent-node {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 2px solid var(--cyan);
            border-radius: 50%;
            background: var(--void);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
            transition: all 0.3s ease;
            pointer-events: all;
            cursor: pointer;
        }

        .agent-node.active {
            border-color: var(--orange);
            box-shadow: 0 0 30px rgba(255, 107, 53, 0.8);
            transform: scale(1.2);
        }

        .agent-node:hover {
            border-color: var(--green);
            transform: scale(1.1);
        }

        .token-counter {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--void);
            border: 1px solid var(--cyan);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            color: var(--cyan);
            font-family: 'Courier New', monospace;
            white-space: nowrap;
        }

        #stream-dashboard {
            position: fixed;
            top: 60px;
            right: 20px;
            background: rgba(10, 10, 30, 0.95);
            border: 2px solid var(--cyan);
            border-radius: 10px;
            padding: 15px;
            min-width: 250px;
            z-index: 50001;
            pointer-events: all;
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.3);
        }

        .stream-stat {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 12px;
            color: var(--cyan);
            font-family: 'Courier New', monospace;
        }

        .stream-stat-value {
            color: var(--green);
            font-weight: bold;
        }

        /* Model Scanner Modal Styles */
        .model-scanner-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            z-index: 99999;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .model-scanner-content {
            background: var(--void);
            border: 2px solid var(--cyan);
            border-radius: 10px;
            padding: 30px;
            width: 90%;
            max-width: 1000px;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 50px rgba(0, 212, 255, 0.5);
        }

        .model-scanner-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--cyan);
        }

        .model-scanner-header h2 {
            color: var(--cyan);
            margin: 0;
            font-size: 24px;
        }

        .scanner-close-btn {
            background: var(--red);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .scanner-close-btn:hover {
            background: #ff1744;
            transform: scale(1.05);
        }

        .model-scanner-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .scanner-btn {
            background: var(--cyan);
            color: var(--void);
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .scanner-btn:hover {
            background: var(--orange);
            transform: translateY(-2px);
        }

        .scanner-btn.scanning {
            background: var(--yellow);
            animation: pulse 1s infinite;
        }

        .model-search-box {
            flex: 1;
            background: var(--bg);
            border: 1px solid var(--cyan);
            color: var(--cyan);
            padding: 10px 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            min-width: 300px;
        }

        .model-stats {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 5px;
        }

        .model-stat-item {
            color: var(--cyan);
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        .model-stat-value {
            color: var(--orange);
            font-weight: bold;
            font-size: 18px;
        }

        .model-list-container {
            flex: 1;
            overflow-y: auto;
            border: 1px solid var(--cyan);
            border-radius: 5px;
            background: var(--bg);
        }

        .model-item {
            padding: 15px;
            border-bottom: 1px solid rgba(0, 212, 255, 0.2);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .model-item:hover {
            background: rgba(0, 212, 255, 0.1);
            border-left: 3px solid var(--cyan);
        }

        .model-item.selected {
            background: rgba(0, 212, 255, 0.2);
            border-left: 5px solid var(--orange);
        }

        .model-info {
            flex: 1;
        }

        .model-name {
            color: var(--cyan);
            font-weight: bold;
            font-size: 14px;
            font-family: 'Courier New', monospace;
        }

        .model-details {
            color: rgba(0, 212, 255, 0.6);
            font-size: 11px;
            margin-top: 5px;
            font-family: 'Courier New', monospace;
        }

        .model-source {
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        .model-source.orchestra {
            background: var(--purple);
            color: white;
        }

        .model-source.ollama {
            background: var(--teal);
            color: white;
        }

        .model-select-btn {
            background: var(--green);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            transition: all 0.2s ease;
        }

        .model-select-btn:hover {
            background: var(--cyan);
            transform: scale(1.05);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        #connection-status.disconnected {
            color: var(--red);
        }

        /* Ensure right panel is visible and not black */
        #right-panel {
            background: var(--void);
            border-left: 2px solid var(--cyan);
            overflow-y: auto;
            height: 100vh;
            position: relative;
        }

        /* Fix tab content visibility */
        .tab-content {
            padding: 15px;
            min-height: calc(100vh - 150px);
            background: var(--void);
            color: var(--cyan);
        }

        /* Ensure agents tab is always visible by default */
        #agents-tab {
            display: block !important;
        }

        /* ===== SUPERNOVA AGENT STYLES ===== */
        .supernova-message {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            border-left: 3px solid var(--cyan);
            background: rgba(0, 212, 255, 0.05);
        }

        .supernova-message.user {
            border-left-color: var(--green);
            background: rgba(0, 255, 0, 0.05);
        }

        .supernova-message.assistant {
            border-left-color: var(--orange);
            background: rgba(255, 107, 53, 0.05);
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
            color: #888;
        }

        .message-role {
            font-weight: bold;
            color: var(--cyan);
        }

        .message-time {
            color: #666;
        }

        .message-content {
            line-height: 1.4;
            word-wrap: break-word;
        }

        .message-content code {
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        .message-content strong {
            color: var(--orange);
        }

        .message-content em {
            color: var(--teal);
        }

        #supernova-chat {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
            background: var(--bg);
            border-bottom: 1px solid var(--cyan);
        }

        #supernova-input-container {
            display: flex;
            padding: 10px;
            background: var(--void);
            border-top: 1px solid var(--cyan);
        }

        #supernova-input {
            flex: 1;
            background: var(--bg);
            color: var(--cyan);
            border: 1px solid var(--cyan);
            padding: 8px;
            font-family: monospace;
            border-radius: 3px;
        }

        #supernova-input:focus {
            outline: none;
            border-color: var(--teal);
        }

        #supernova-send {
            background: var(--green);
            color: var(--void);
            border: none;
            padding: 8px 15px;
            margin-left: 5px;
            cursor: pointer;
            border-radius: 3px;
        }

        #supernova-send:hover {
            background: var(--teal);
        }

        #supernova-controls {
            display: flex;
            gap: 5px;
            padding: 10px;
            background: var(--void);
            border-top: 1px solid var(--cyan);
        }

        #supernova-controls button {
            background: var(--orange);
            color: var(--void);
            border: none;
            padding: 6px 12px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 11px;
        }

        #supernova-controls button:hover {
            background: var(--yellow);
        }

        #supernova-status {
            padding: 10px;
            background: var(--void);
            border-top: 1px solid var(--cyan);
            font-size: 11px;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
        }

        .status-label {
            color: #888;
        }

        .status-value {
            color: var(--cyan);
            font-weight: bold;
        }

        .status-value.ready {
            color: var(--green);
        }

        .status-value.error {
            color: var(--red);
        }

        /* ===== VIEW CONTAINERS ===== */
        .view-container {
            display: none;
            flex: 1;
            padding: 20px;
            background: var(--void);
            color: var(--cyan);
            overflow-y: auto;
        }

        .view-container.active {
            display: block;
        }

        .main-view {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        #code {
            flex: 1;
            background: var(--bg);
            color: var(--cyan);
            border: 1px solid var(--cyan);
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            resize: none;
            outline: none;
            margin-bottom: 10px;
        }

        #code:focus {
            border-color: var(--teal);
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
        }

        #code-controls {
            display: flex;
            gap: 10px;
            padding: 10px 0;
        }

        #code-controls button {
            background: var(--cyan);
            color: var(--void);
            border: none;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        #code-controls button:hover {
            background: var(--teal);
            transform: translateY(-2px);
        }

        /* ===== WORKSPACE VIEW ===== */
        .workspace-content {
            max-width: 1200px;
            margin: 0 auto;
        }

        .workspace-content h3 {
            color: var(--orange);
            margin-bottom: 20px;
            text-align: center;
        }

        .workspace-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .workspace-item {
            background: rgba(0, 212, 255, 0.05);
            border: 1px solid var(--cyan);
            border-radius: 8px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .workspace-item:hover {
            background: rgba(0, 212, 255, 0.1);
            border-color: var(--teal);
            transform: translateY(-5px);
        }

        .workspace-item h4 {
            color: var(--orange);
            margin-bottom: 10px;
        }

        .workspace-item p {
            color: #ccc;
            line-height: 1.5;
        }

        /* ===== DASHBOARD VIEW ===== */
        .dashboard-content {
            max-width: 1200px;
            margin: 0 auto;
        }

        .dashboard-content h3 {
            color: var(--orange);
            margin-bottom: 20px;
            text-align: center;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .dashboard-item {
            background: rgba(255, 107, 53, 0.05);
            border: 1px solid var(--orange);
            border-radius: 8px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .dashboard-item:hover {
            background: rgba(255, 107, 53, 0.1);
            border-color: var(--yellow);
            transform: translateY(-5px);
        }

        .dashboard-item h4 {
            color: var(--yellow);
            margin-bottom: 10px;
        }

        .dashboard-item p {
            color: #ccc;
            line-height: 1.5;
        }

        /* ===== VIEW BUTTONS ===== */
        .view-btn {
            background: var(--void);
            color: var(--cyan);
            border: 1px solid var(--cyan);
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .view-btn:hover {
            background: rgba(0, 212, 255, 0.1);
            border-color: var(--teal);
        }

        .view-btn.active {
            background: var(--cyan);
            color: var(--void);
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        /* Micro Models Tab Styles */
        .micro-models-section {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid var(--teal);
            border-radius: 5px;
            background: rgba(29, 209, 161, 0.05);
        }

        .chain-controls, .nano-controls, .catalog-controls, .test-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .chain-btn, .nano-btn, .catalog-btn, .test-btn, .deploy-btn {
            background: var(--teal);
            color: var(--void);
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .chain-btn:hover, .nano-btn:hover, .catalog-btn:hover, .test-btn:hover, .deploy-btn:hover {
            background: var(--cyan);
            transform: translateY(-2px);
        }

        .nano-btn {
            background: var(--orange);
        }

        .nano-btn:hover {
            background: var(--yellow);
        }

        .deploy-btn {
            background: var(--green);
        }

        .deploy-btn:hover {
            background: var(--cyan);
        }

        #model-catalog-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .model-catalog-item {
            padding: 10px;
            border: 1px solid var(--teal);
            border-radius: 5px;
            background: rgba(29, 209, 161, 0.1);
        }

        #chain-results {
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
            border: 1px solid var(--teal);
            border-radius: 5px;
            background: rgba(29, 209, 161, 0.05);
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        /* Utility classes to replace inline styles */
        .flex { display: flex; }
        .flex-gap-5 { gap: 5px; }
        .flex-gap-10 { gap: 10px; }
        .flex-align-center { align-items: center; }
        .flex-wrap { flex-wrap: wrap; }
        .flex-column { flex-direction: column; }
        .bg-void { background: var(--void); }
        .bg-bg { background: var(--bg); }
        .color-cyan { color: var(--cyan); }
        .color-green { color: var(--green); }
        .color-orange { color: var(--orange); }
        .color-gray { color: #888; }
        .padding-15 { padding: 15px; }
        .padding-10 { padding: 10px; }
        .padding-8 { padding: 8px; }
        .margin-top-10 { margin-top: 10px; }
        .margin-top-5 { margin-top: 5px; }
        .margin-bottom-10 { margin-bottom: 10px; }
        .border-bottom-cyan { border-bottom: 1px solid var(--cyan); }
        .border-cyan { border: 1px solid var(--cyan); }
        .font-11 { font-size: 11px; }
        .font-12 { font-size: 12px; }
        .font-weight-bold { font-weight: bold; }
        .position-relative { position: relative; }
        .z-500 { z-index: 500; }
        .z-1000 { z-index: 1000; }
        .overflow-auto { overflow-y: auto; }
        .min-h-200 { min-height: 200px; }
        .flex-1 { flex: 1; }
        .height-100 { height: 100%; }
        .border-radius-3 { border-radius: 3px; }
        
        /* Model button styles */
        .model-btn-base { border: none; padding: 5px 10px; cursor: pointer; border-radius: 3px; font-size: 11px; color: var(--void); }
        .model-btn-cyan { background: var(--cyan); }
        .model-btn-green { background: var(--green); }
        .model-btn-orange { background: var(--orange); }
        .model-btn-red { background: var(--red); }
        
        /* Emotion button styles */
        .emotion-btn-base { border: none; padding: 3px 8px; cursor: pointer; border-radius: 3px; font-size: 10px; color: white; }
        .emotion-calm { background: #6c7a89; }
        .emotion-focused { background: #f39c12; }
        .emotion-intense { background: #e74c3c; }
        .emotion-overwhelmed { background: #8e44ad; }
        
        .current-emotion { font-size: 12px; margin-left: 10px; font-weight: bold; color: var(--green); }
        
        /* AI message styles */
        .ai-message { margin-bottom: 10px; padding: 8px; background: rgba(0, 212, 255, 0.1); border-left: 3px solid var(--cyan); color: var(--cyan); font-size: 12px; }
        .user-message { margin-bottom: 10px; padding: 8px; background: rgba(46, 204, 113, 0.1); border-left: 3px solid var(--green); color: var(--green); font-size: 12px; }
        
        /* AI input container */
        .ai-input-container { display: flex; gap: 5px; }
        
        /* Special styles that need to remain inline */
        .font-monospace { font-family: monospace; }
        .padding-8-15 { padding: 8px 15px; }
        .bg-teal { background: var(--teal); }
        
        /* Button padding variations */
        .padding-5-10 { padding: 5px 10px; }
        .btn-orange { background: var(--orange); color: var(--void); padding: 5px 10px; border: none; border-radius: 3px; cursor: pointer; font-size: 12px; }
        .btn-green { background: var(--green); color: var(--void); padding: 5px 10px; border: none; border-radius: 3px; cursor: pointer; font-size: 12px; }
        .btn-cyan { background: var(--cyan); color: var(--void); padding: 5px 10px; border: none; border-radius: 3px; cursor: pointer; font-size: 12px; }
        .margin-left-5 { margin-left: 5px; }
        .info-text { font-size: 12px; margin-top: 5px; color: var(--cyan); }
        .display-none { display: none; }
        .iframe-full { width: 100%; height: 100%; border: none; }
        .cursor-pointer { cursor: pointer; }
        .color-yellow { color: var(--yellow); }
        
        /* ===== COSMIC BACKGROUND ANIMATION ===== */
        @keyframes cosmicShift {
            0% {
                transform: scale(1) translateX(0) translateY(0) rotate(0deg);
                filter: hue-rotate(0deg) brightness(1) saturate(1);
            }
            25% {
                transform: scale(1.1) translateX(-2%) translateY(2%) rotate(0.5deg);
                filter: hue-rotate(10deg) brightness(1.1) saturate(1.2);
            }
            50% {
                transform: scale(1.15) translateX(2%) translateY(-2%) rotate(-0.5deg);
                filter: hue-rotate(20deg) brightness(0.9) saturate(1.4);
            }
            75% {
                transform: scale(1.1) translateX(-1%) translateY(1%) rotate(0.3deg);
                filter: hue-rotate(30deg) brightness(1.2) saturate(1.3);
            }
            100% {
                transform: scale(1) translateX(0) translateY(0) rotate(0deg);
                filter: hue-rotate(0deg) brightness(1) saturate(1);
            }
        }
        
        #cosmic-background {
            animation: cosmicShift 120s ease-in-out infinite;
            will-change: transform, filter;
            transform-origin: center center;
        }
        
    </style>
</head>
<body>
    <!-- ===== COSMIC ANIMATED BACKGROUND ===== -->
    <div id="cosmic-background" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: -1; background-image: url('BCO.50fb115b-84a6-409f-adf6-155d6a4bef10.png'); background-size: cover; background-position: center; opacity: 0.8; transition: all 30s ease-in-out; animation: cosmicShift 120s ease-in-out infinite;"></div>

    <!-- ===== FLOATING AI CHAT (ALWAYS ON TOP) ===== -->
    <div id="floating-ai">
        <div id="floating-ai-header">
            <span> BigDaddyG AI</span>
            <button class="minimize-btn" onclick="toggleFloatingAI()"></button>
        </div>
        <div id="floating-ai-content">
            <div class="ai-msg">
                <strong>BigDaddyG:</strong> Ready! Ask me anything. Try: "Write a Python hello world"
            </div>
        </div>
        <div id="floating-ai-input">
            <input type="text" id="floating-input" placeholder="Ask BigDaddyG..." onkeypress="if(event.key==='Enter') sendFloatingAI()">
            <button onclick="sendFloatingAI()">Send</button>
        </div>
    </div>

    <!-- ===== 5-PANE LAYOUT WITH COLLAPSE/EXPAND CONTROLS ===== -->
    
    <!-- LEFT PANEL = FILE EXPLORER -->
    <div id="left-panel" class="expandable-pane" style="flex: 0 0 250px; min-width: 150px; max-width: 400px;">
        <div style="padding: 10px; background: var(--teal); color: var(--bg); border-bottom: 1px solid var(--teal); font-size: 14px; font-weight: bold; display: flex; justify-content: space-between; align-items: center;">
            <span> File Explorer</span>
            <div style="display: flex; gap: 5px;">
                <button onclick="expandPane('left-panel')" style="background: var(--green); color: var(--void); border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: bold;" title="Expand to full screen"></button>
                <button onclick="collapsePane('left-panel')" style="background: var(--orange); color: var(--void); border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: bold;" title="Minimize to bubble"></button>
            </div>
        </div>
        <div style="flex: 1; overflow: auto; padding: 10px;">
            <div class="flex flex-gap-5 flex-align-center" style="margin-bottom: 10px;">
                <button class="new-chat-btn" onclick="newChat()" title="Start New Chat">+ New Chat</button>
                <button class="view-btn" onclick="switchView('main')" id="main-btn">IDE</button>
                <button class="view-btn" onclick="switchView('workspace')" id="workspace-btn">Workspace</button>
                <button class="view-btn" onclick="switchView('dashboard')" id="dashboard-btn">Dashboard</button>
            </div>
        </div>

        <!-- Main IDE View -->
        <div id="main-view" class="view-container active main-view">
            <textarea id="code" spellcheck="false" autocorrect="off" title="Code Editor" aria-label="Code Editor">// BigDaddyG Self-Made Browser
// Welcome to your native agentic workspace!

console.log("BigDaddyG Browser initialized");
console.log("Platform:", window.electronAPI ? window.electronAPI.platform : "Browser");
console.log("User Agent:", navigator.userAgent);</textarea>
            <div id="code-controls">
                <button onclick="runCode()">Run Code</button>
                <button onclick="clearCode()">Clear</button>
                <button onclick="saveCode()">Save</button>
                <button onclick="loadCode()">Load</button>
            </div>
        </div>

        <!-- Workspace View -->
        <div id="workspace-view" class="view-container">
            <div class="workspace-content">
                <h3 style="color: var(--orange); margin-bottom: 20px;"> Advanced Workspace - Full File System Access</h3>
                
                <!-- Current Directory Path -->
                <div style="background: rgba(0, 212, 255, 0.05); border: 1px solid var(--cyan); border-radius: 8px; padding: 15px; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                    <span style="color: var(--cyan); font-weight: bold;"> Current Path:</span>
                    <input type="text" id="workspace-path" value="D:\Security Research aka GitHub Repos" style="flex: 1; background: var(--bg); color: var(--cyan); border: 1px solid var(--cyan); padding: 8px; border-radius: 4px; font-family: monospace;" />
                    <button onclick="loadWorkspaceDirectory()" style="background: var(--cyan); color: var(--void); border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; font-weight: bold;">Go</button>
                    <button onclick="goUpDirectory()" style="background: var(--orange); color: var(--void); border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer;"> Up</button>
                    </div>
                
                <!-- File Browser Section -->
                <div style="background: rgba(0, 212, 255, 0.05); border: 1px solid var(--cyan); border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                    <h4 style="color: var(--cyan); margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center;">
                        <span> File Explorer</span>
                        <div style="display: flex; gap: 10px;">
                            <button onclick="refreshWorkspace()" style="background: var(--teal); color: var(--void); border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 11px;"> Refresh</button>
                            <button onclick="createNewFile()" style="background: var(--green); color: var(--void); border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 11px;">+ New File</button>
                    </div>
                    </h4>
                    <div id="file-browser" style="background: var(--bg); border: 1px solid var(--cyan); border-radius: 4px; padding: 10px; font-family: monospace; font-size: 12px; max-height: 400px; overflow-y: auto;">
                        <div style="color: var(--orange); padding: 10px;">Loading file system...</div>
                    </div>
                </div>
                
                <!-- Git Integration Section -->
                <div style="background: rgba(0, 255, 0, 0.05); border: 1px solid var(--green); border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                    <h4 style="color: var(--green); margin-bottom: 15px;"> Git Integration</h4>
                    <div id="git-status" style="background: var(--bg); border: 1px solid var(--green); border-radius: 4px; padding: 15px; margin-bottom: 15px; font-family: monospace; font-size: 12px;">
                        <div style="color: var(--cyan); margin-bottom: 10px;"> <strong>Branch:</strong> <span id="git-branch">main</span></div>
                        <div style="color: var(--orange); margin-bottom: 10px;"> <strong>Changes:</strong> <span id="git-changes">0 files</span></div>
                        <div style="color: var(--green);"> <strong>Status:</strong> <span id="git-status-text">Clean working directory</span></div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                        <button onclick="gitPull()" style="background: var(--cyan); color: var(--void); border: none; padding: 10px; border-radius: 4px; cursor: pointer; font-weight: bold;"> Pull</button>
                        <button onclick="gitCommit()" style="background: var(--green); color: var(--void); border: none; padding: 10px; border-radius: 4px; cursor: pointer; font-weight: bold;"> Commit</button>
                        <button onclick="gitPush()" style="background: var(--orange); color: var(--void); border: none; padding: 10px; border-radius: 4px; cursor: pointer; font-weight: bold;"> Push</button>
                        <button onclick="gitLog()" style="background: var(--teal); color: var(--void); border: none; padding: 10px; border-radius: 4px; cursor: pointer; font-weight: bold;"> Log</button>
                    </div>
                </div>
                
                <!-- Integrated Terminal -->
                <div style="background: rgba(255, 107, 53, 0.05); border: 1px solid var(--orange); border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                    <h4 style="color: var(--orange); margin-bottom: 15px;"> Integrated Terminal</h4>
                    <div id="workspace-terminal" style="background: var(--bg); border: 1px solid var(--orange); border-radius: 4px; padding: 10px; font-family: 'Courier New', monospace; font-size: 12px; height: 200px; overflow-y: auto; color: var(--cyan);">
                        <div style="color: var(--green);">BigDaddyG Terminal v1.0</div>
                        <div style="color: var(--cyan);">Type 'help' for available commands</div>
                        <div style="color: var(--cyan); margin-top: 5px;">$&gt; <span id="terminal-cursor" style="background: var(--cyan); animation: blink 1s infinite;">_</span></div>
                    </div>
                    <div style="margin-top: 10px;">
                        <input type="text" id="terminal-input" placeholder="Enter command..." style="width: calc(100% - 80px); background: var(--bg); color: var(--cyan); border: 1px solid var(--orange); padding: 8px; border-radius: 4px; font-family: monospace;" onkeypress="if(event.key==='Enter') executeTerminalCommand()" />
                        <button onclick="executeTerminalCommand()" style="background: var(--orange); color: var(--void); border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; margin-left: 5px; font-weight: bold;">Run</button>
                    </div>
                </div>
                
                <!-- Recent Activity (Real-time) -->
                <div style="background: rgba(29, 209, 161, 0.05); border: 1px solid var(--teal); border-radius: 8px; padding: 20px;">
                    <h4 style="color: var(--teal); margin-bottom: 15px;"> Recent Activity</h4>
                    <div id="workspace-activity" style="font-size: 12px; color: var(--cyan); line-height: 1.8;">
                        <div style="padding: 5px; border-bottom: 1px solid rgba(29, 209, 161, 0.2);"> Cosmic background activated</div>
                        <div style="padding: 5px; border-bottom: 1px solid rgba(29, 209, 161, 0.2);"> Task bubbles spawned</div>
                        <div style="padding: 5px; border-bottom: 1px solid rgba(29, 209, 161, 0.2);"> Orchestration mesh initialized</div>
                        <div style="padding: 5px;"> All systems online</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Dashboard View -->
        <div id="dashboard-view" class="view-container">
            <div class="dashboard-content">
                <h3 style="color: var(--cyan); margin-bottom: 20px;"> Orchestrator Dashboard - Real-time Monitoring</h3>
                
                <!-- Speed Test Section -->
                <div style="background: rgba(255, 107, 53, 0.05); border: 1px solid var(--orange); border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                    <h4 style="color: var(--orange); margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center;">
                        <span> Network Speed Test</span>
                        <button onclick="runSpeedTest()" id="speedtest-btn" style="background: var(--green); color: var(--void); border: none; padding: 5px 15px; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: bold;"> Run Test</button>
                    </h4>
                    
                    <!-- Server & Unit Selection -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                        <div>
                            <label style="color: var(--cyan); font-size: 11px; display: block; margin-bottom: 5px;">Test Server:</label>
                            <select id="speedtest-server" style="width: 100%; padding: 6px; background: var(--bg); color: var(--cyan); border: 1px solid var(--orange); border-radius: 4px; font-family: monospace; font-size: 11px;">
                                <option value="https://speed.cloudflare.com">Cloudflare (Global CDN)</option>
                                <option value="https://www.google.com">Google (Fast CDN)</option>
                                <option value="https://cdn.jsdelivr.net">jsDelivr (CDN)</option>
                                <option value="https://github.com">GitHub (Code hosting)</option>
                                <option value="http://localhost:11441">Orchestra (Local)</option>
                                <option value="custom">Custom Server...</option>
                            </select>
                        </div>
                        <div>
                            <label style="color: var(--cyan); font-size: 11px; display: block; margin-bottom: 5px;">Display Units:</label>
                            <select id="speedtest-units" style="width: 100%; padding: 6px; background: var(--bg); color: var(--cyan); border: 1px solid var(--orange); border-radius: 4px; font-family: monospace; font-size: 11px;">
                                <option value="mbps">Mbps (Megabits/sec)</option>
                                <option value="MBps">MB/s (Megabytes/sec)</option>
                                <option value="kbps">Kbps (Kilobits/sec)</option>
                                <option value="KBps">KB/s (Kilobytes/sec)</option>
                                <option value="gbps">Gbps (Gigabits/sec)</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Results Display -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                        <div style="background: var(--bg); border: 1px solid var(--green); border-radius: 4px; padding: 15px; text-align: center;">
                            <div style="font-size: 24px; color: var(--green); font-weight: bold;" id="download-speed">-- </div>
                            <div style="font-size: 10px; color: var(--cyan); margin-top: 5px;"> Download</div>
                        </div>
                        <div style="background: var(--bg); border: 1px solid var(--orange); border-radius: 4px; padding: 15px; text-align: center;">
                            <div style="font-size: 24px; color: var(--orange); font-weight: bold;" id="upload-speed">--</div>
                            <div style="font-size: 10px; color: var(--cyan); margin-top: 5px;"> Upload</div>
                        </div>
                        <div style="background: var(--bg); border: 1px solid var(--cyan); border-radius: 4px; padding: 15px; text-align: center;">
                            <div style="font-size: 24px; color: var(--cyan); font-weight: bold;" id="ping-latency">--</div>
                            <div style="font-size: 10px; color: var(--cyan); margin-top: 5px;"> Ping (ms)</div>
                        </div>
                    </div>
                    
                    <!-- Progress Bar -->
                    <div style="background: rgba(255, 107, 53, 0.2); height: 6px; border-radius: 3px; overflow: hidden; margin-bottom: 10px;">
                        <div id="speedtest-progress" style="width: 0%; height: 100%; background: var(--orange); transition: width 0.3s ease;"></div>
                    </div>
                    <div id="speedtest-status" style="color: var(--cyan); font-size: 11px; text-align: center;">Ready to test</div>
                </div>
                
                <!-- Audio Visualizer Section -->
                <div style="background: rgba(138, 43, 226, 0.05); border: 1px solid #8b5cf6; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                    <h4 style="color: #8b5cf6; margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center;">
                        <span> Audio-Reactive Equalizer</span>
                        <div style="display: flex; gap: 10px;">
                            <button onclick="startAudioVisualizer()" style="background: var(--green); color: var(--void); border: none; padding: 5px 15px; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: bold;"> Start</button>
                            <button onclick="stopAudioVisualizer()" style="background: var(--red); color: white; border: none; padding: 5px 15px; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: bold;"> Stop</button>
                        </div>
                    </h4>
                    <div style="color: var(--cyan); font-size: 11px; margin-bottom: 10px;">
                         Play Spotify or any music, then click "Start" to activate audio-reactive visualizations!
                    </div>
                    <canvas id="equalizer-canvas" width="800" height="200" style="width: 100%; background: var(--bg); border: 1px solid #8b5cf6; border-radius: 4px;"></canvas>
                </div>
                
                <!-- Real-time Stats Row -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div style="background: rgba(0, 212, 255, 0.1); border: 2px solid var(--cyan); border-radius: 8px; padding: 15px; text-align: center;">
                        <div style="font-size: 32px; color: var(--cyan); font-weight: bold;" id="dash-queries">0</div>
                        <div style="font-size: 12px; color: var(--cyan); margin-top: 5px;">Total Queries</div>
                    </div>
                    <div style="background: rgba(0, 255, 0, 0.1); border: 2px solid var(--green); border-radius: 8px; padding: 15px; text-align: center;">
                        <div style="font-size: 32px; color: var(--green); font-weight: bold;">4/4</div>
                        <div style="font-size: 12px; color: var(--green); margin-top: 5px;">Agents Online</div>
                    </div>
                    <div style="background: rgba(255, 107, 53, 0.1); border: 2px solid var(--orange); border-radius: 8px; padding: 15px; text-align: center;">
                        <div style="font-size: 32px; color: var(--orange); font-weight: bold;" id="dash-uptime">00:00</div>
                        <div style="font-size: 12px; color: var(--orange); margin-top: 5px;">Uptime</div>
                    </div>
                    <div style="background: rgba(29, 209, 161, 0.1); border: 2px solid var(--teal); border-radius: 8px; padding: 15px; text-align: center;">
                        <div style="font-size: 32px; color: var(--teal); font-weight: bold;">98%</div>
                        <div style="font-size: 12px; color: var(--teal); margin-top: 5px;">Success Rate</div>
                    </div>
                </div>
                
                <!-- Agent Status Grid -->
                <div style="background: rgba(0, 212, 255, 0.05); border: 1px solid var(--cyan); border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                    <h4 style="color: var(--cyan); margin-bottom: 15px;"> Agent Status Monitor</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                        <div style="background: var(--bg); border: 1px solid var(--green); border-radius: 4px; padding: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <span style="color: var(--cyan); font-weight: bold;">Elder Agent</span>
                                <span style="width: 10px; height: 10px; background: var(--green); border-radius: 50%; box-shadow: 0 0 10px var(--green);"></span>
                            </div>
                            <div style="font-size: 11px; color: #888;">Tasks: 15 | Success: 100%</div>
                            <div style="margin-top: 10px; background: rgba(0, 255, 0, 0.1); height: 4px; border-radius: 2px; overflow: hidden;">
                                <div style="width: 100%; height: 100%; background: var(--green);"></div>
                            </div>
                        </div>
                        <div style="background: var(--bg); border: 1px solid var(--green); border-radius: 4px; padding: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <span style="color: var(--cyan); font-weight: bold;">Fetcher Agent</span>
                                <span style="width: 10px; height: 10px; background: var(--green); border-radius: 50%; box-shadow: 0 0 10px var(--green);"></span>
                            </div>
                            <div style="font-size: 11px; color: #888;">Tasks: 23 | Success: 95%</div>
                            <div style="margin-top: 10px; background: rgba(0, 255, 0, 0.1); height: 4px; border-radius: 2px; overflow: hidden;">
                                <div style="width: 95%; height: 100%; background: var(--green);"></div>
                            </div>
                        </div>
                        <div style="background: var(--bg); border: 1px solid var(--green); border-radius: 4px; padding: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <span style="color: var(--cyan); font-weight: bold;">Browser Agent</span>
                                <span style="width: 10px; height: 10px; background: var(--green); border-radius: 50%; box-shadow: 0 0 10px var(--green);"></span>
                            </div>
                            <div style="font-size: 11px; color: #888;">Tasks: 18 | Success: 100%</div>
                            <div style="margin-top: 10px; background: rgba(0, 255, 0, 0.1); height: 4px; border-radius: 2px; overflow: hidden;">
                                <div style="width: 100%; height: 100%; background: var(--green);"></div>
                            </div>
                        </div>
                        <div style="background: var(--bg); border: 1px solid var(--green); border-radius: 4px; padding: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <span style="color: var(--cyan); font-weight: bold;">Parser Agent</span>
                                <span style="width: 10px; height: 10px; background: var(--green); border-radius: 50%; box-shadow: 0 0 10px var(--green);"></span>
                            </div>
                            <div style="font-size: 11px; color: #888;">Tasks: 31 | Success: 97%</div>
                            <div style="margin-top: 10px; background: rgba(0, 255, 0, 0.1); height: 4px; border-radius: 2px; overflow: hidden;">
                                <div style="width: 97%; height: 100%; background: var(--green);"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- System Resources (Real-time) -->
                <div class="dashboard-grid">
                    <div class="dashboard-item">
                        <h4 style="color: var(--orange);"> System Resources</h4>
                        <div style="margin: 15px 0;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 12px;">
                                <span style="color: var(--cyan);">CPU Usage</span>
                                <span style="color: var(--cyan);" id="dash-cpu">0%</span>
                    </div>
                            <div style="background: rgba(0, 212, 255, 0.2); height: 8px; border-radius: 4px; overflow: hidden;">
                                <div id="dash-cpu-bar" style="width: 0%; height: 100%; background: var(--cyan); transition: width 0.3s ease;"></div>
                            </div>
                        </div>
                        <div style="margin: 15px 0;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 12px;">
                                <span style="color: var(--green);">Memory</span>
                                <span style="color: var(--green);" id="dash-memory">0%</span>
                            </div>
                            <div style="background: rgba(0, 255, 0, 0.2); height: 8px; border-radius: 4px; overflow: hidden;">
                                <div id="dash-memory-bar" style="width: 0%; height: 100%; background: var(--green); transition: width 0.3s ease;"></div>
                            </div>
                        </div>
                        <div style="margin: 15px 0;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 12px;">
                                <span style="color: var(--orange);">Active Agents</span>
                                <span style="color: var(--orange);" id="dash-active-agents">0</span>
                            </div>
                            <div style="background: rgba(255, 107, 53, 0.2); height: 8px; border-radius: 4px; overflow: hidden;">
                                <div id="dash-agents-bar" style="width: 0%; height: 100%; background: var(--orange); transition: width 0.3s ease;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="dashboard-item">
                        <h4 style="color: var(--teal);"> Network Status</h4>
                        <div style="font-size: 12px; color: var(--cyan); line-height: 2; margin-top: 15px;">
                            <div style="display: flex; justify-content: space-between; padding: 5px; border-bottom: 1px solid rgba(0, 212, 255, 0.2);">
                                <span>WebSocket:</span>
                                <span id="dash-ws-status" style="color: var(--red);"> Disconnected</span>
                    </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px; border-bottom: 1px solid rgba(0, 212, 255, 0.2);">
                                <span>Orchestra:</span>
                                <span id="dash-http-status" style="color: var(--green);"> Connected</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px; border-bottom: 1px solid rgba(0, 212, 255, 0.2);">
                                <span>Active Tasks:</span>
                                <span id="dash-active-tasks" style="color: var(--green);">0</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 5px;">
                                <span>Tokens/sec:</span>
                                <span id="dash-tokens-sec" style="color: var(--cyan);">0</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="dashboard-item">
                        <h4 style="color: var(--yellow);"> Orchestration Control</h4>
                        <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 15px;">
                            <button onclick="symphony()" style="background: linear-gradient(45deg, #8b5cf6, #ec4899); color: white; border: none; padding: 10px; border-radius: 4px; cursor: pointer; font-weight: bold; width: 100%; box-shadow: 0 0 10px rgba(139,92,246,0.5);">
                                 Symphony
                            </button>
                            <button onclick="bounce()" style="background: linear-gradient(45deg, #00f6ff, #00ff88); color: var(--void); border: none; padding: 10px; border-radius: 4px; cursor: pointer; font-weight: bold; width: 100%; box-shadow: 0 0 10px rgba(0,246,255,0.5);">
                                 Bounce
                            </button>
                            <button onclick="ignite()" style="background: linear-gradient(45deg, #ff0044, #ff8800); color: white; border: none; padding: 10px; border-radius: 4px; cursor: pointer; font-weight: bold; width: 100%; box-shadow: 0 0 10px rgba(255,0,68,0.5);">
                                 Ignite
                            </button>
                            <button onclick="tinyverse()" style="background: linear-gradient(45deg, #00d4ff, #8b5cf6); color: white; border: none; padding: 10px; border-radius: 4px; cursor: pointer; font-weight: bold; width: 100%; box-shadow: 0 0 10px rgba(0,212,255,0.5);">
                                 TinyVerse
                            </button>
                    </div>
                </div>
            </div>
                
                <!-- Live System Monitoring Charts -->
                <div style="margin-top: 20px;">
                    <h4 style="color: var(--cyan); margin-bottom: 15px;"> Live Performance Metrics</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div style="background: var(--bg); border: 1px solid var(--cyan); border-radius: 8px; padding: 15px;">
                            <h5 style="color: var(--cyan); margin-bottom: 10px;"> Token Flow Rate</h5>
                            <canvas id="token-flow-chart" width="400" height="120" style="width: 100%;"></canvas>
                        </div>
                        <div style="background: var(--bg); border: 1px solid var(--green); border-radius: 8px; padding: 15px;">
                            <h5 style="color: var(--green); margin-bottom: 10px;"> Emotional State History</h5>
                            <canvas id="emotion-history-chart" width="400" height="120" style="width: 100%;"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- RESIZER 1 (Between Left and Middle-Left) -->
    <div class="pane-resizer" id="resizer-1"></div>
    
    <!-- MIDDLE-LEFT PANEL = CODE EDITOR -->
    <div id="middle-left-panel" class="expandable-pane" style="flex: 1; min-width: 200px;">
        <div id="code-header" style="padding: 10px; background: var(--cyan); color: var(--bg); border-bottom: 1px solid var(--cyan); font-size: 14px; font-weight: bold; display: flex; justify-content: space-between; align-items: center;">
            <span> Code Editor</span>
            <div style="display: flex; gap: 5px;">
                <button onclick="expandPane('middle-left-panel')" style="background: var(--green); color: var(--void); border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: bold;" title="Expand to full screen"></button>
                <button onclick="collapsePane('middle-left-panel')" style="background: var(--orange); color: var(--void); border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: bold;" title="Minimize to bubble"></button>
            </div>
        </div>
        <textarea id="code" spellcheck="false" autocorrect="off" style="flex: 1; width: 100%; background: var(--bg); color: var(--cyan); border: none; outline: none; resize: none; padding: 10px; font-family: 'Courier New', monospace; font-size: 14px;">// BigDaddyG Browser - 5-Pane Layout
// Code in pane 2 | Console in pane 3 | Browser in pane 4 | Agents in pane 5

console.log("BigDaddyG 5-Pane Orchestration Mesh");
console.log("Type help() in console for commands");</textarea>
        <div style="padding: 10px; background: var(--void); border-top: 1px solid var(--cyan); display: flex; gap: 10px;">
            <button onclick="runCode()" style="background: var(--green); color: var(--void); border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; font-weight: bold;"> Run</button>
            <button onclick="clearCode()" style="background: var(--orange); color: var(--void); border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; font-weight: bold;"> Clear</button>
            <button onclick="saveCode()" style="background: var(--cyan); color: var(--void); border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; font-weight: bold;"> Save</button>
        </div>
    </div>
    
    <!-- RESIZER 2 (Between Middle-Left and Middle) -->
    <div class="pane-resizer" id="resizer-2"></div>
    
    <!-- MIDDLE PANEL = CONSOLE -->
    <div id="middle-panel" class="expandable-pane" style="flex: 1; min-width: 200px;">
        <div id="console-header" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; padding: 10px;">
            <span> Console & Output</span>
            <div style="display: flex; gap: 5px; align-items: center;">
                <button onclick="expandPane('middle-panel')" style="background: var(--green); color: var(--void); border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: bold;" title="Expand to full screen"></button>
                <button onclick="collapsePane('middle-panel')" style="background: var(--orange); color: var(--void); border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: bold;" title="Minimize to bubble"></button>
            </div>
            <div style="display: flex; gap: 10px; font-size: 11px; align-items: center; flex-wrap: wrap; width: 100%; margin-top: 5px;">
                <span id="orchestra-status" style="color: #888;"> Orchestra</span>
                <button id="orchestra-control-btn" onclick="toggleOrchestra()" style="background: var(--cyan); color: var(--void); border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: bold;"> Start</button>
                
                <span id="ollama-status" style="color: #888;"> Ollama</span>
                <button id="ollama-control-btn" onclick="toggleOllama()" style="background: var(--cyan); color: var(--void); border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: bold;"> Start</button>
                
                <span id="ws-status" style="color: #888;"> Agents</span>
                <button id="agents-control-btn" onclick="toggleAgents()" style="background: var(--cyan); color: var(--void); border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: bold;"> Start</button>
                
                <span id="micro-models-status" style="color: #888;"> Minis</span>
                <button id="micro-models-control-btn" onclick="toggleMicroModels()" style="background: var(--cyan); color: var(--void); border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: bold;"> Start</button>
            </div>
        </div>
        <div id="console"></div>
        <div id="console-input">
            <input type="text" id="console-input-field" placeholder="Enter JavaScript command..." onkeypress="handleConsoleKeyPress(event)">
            <button onclick="executeConsoleCommand()">Run</button>
        </div>
    </div>
    
    <!-- RESIZER 3 (Between Middle and Middle-Right) -->
    <div class="pane-resizer" id="resizer-3"></div>
    
    <!-- MIDDLE-RIGHT PANEL = BROWSER -->
    <div id="middle-right-panel" class="expandable-pane" style="flex: 1; min-width: 200px; display: flex; flex-direction: column;">
        <div style="padding: 10px; background: var(--green); color: var(--bg); border-bottom: 1px solid var(--green); font-size: 14px; font-weight: bold; display: flex; justify-content: space-between; align-items: center;">
            <span> Integrated Browser</span>
            <div style="display: flex; gap: 5px;">
                <button onclick="refreshBrowser()" style="background: var(--cyan); color: var(--void); border: none; padding: 4px 10px; border-radius: 3px; cursor: pointer; font-size: 11px; font-weight: bold;"></button>
                <button onclick="expandPane('middle-right-panel')" style="background: var(--teal); color: var(--void); border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: bold;" title="Expand to full screen"></button>
                <button onclick="collapsePane('middle-right-panel')" style="background: var(--orange); color: var(--void); border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: bold;" title="Minimize to bubble"></button>
            </div>
        </div>
        <div style="padding: 10px; background: var(--void); border-bottom: 1px solid var(--cyan); display: flex; gap: 5px; align-items: center;">
            <button onclick="browserBack()" style="background: var(--orange); color: var(--void); border: none; padding: 6px 12px; border-radius: 3px; cursor: pointer; font-weight: bold;"></button>
            <button onclick="browserForward()" style="background: var(--orange); color: var(--void); border: none; padding: 6px 12px; border-radius: 3px; cursor: pointer; font-weight: bold;"></button>
            <input type="text" id="browser-url" value="https://example.com" placeholder="Enter URL..." style="flex: 1; background: var(--bg); color: var(--cyan); border: 1px solid var(--cyan); padding: 6px; border-radius: 3px; font-family: monospace;" onkeypress="if(event.key==='Enter') navigateBrowser()" />
            <button onclick="navigateBrowser()" style="background: var(--green); color: var(--void); border: none; padding: 6px 15px; border-radius: 3px; cursor: pointer; font-weight: bold;">Go</button>
            <button onclick="openInNewTab()" style="background: var(--teal); color: var(--void); border: none; padding: 6px 15px; border-radius: 3px; cursor: pointer; font-weight: bold;" title="Open in new tab"></button>
        </div>
        <div style="padding: 5px; background: var(--bg); border-bottom: 1px solid rgba(0,212,255,0.3); display: flex; gap: 5px; flex-wrap: wrap; font-size: 10px;">
            <button onclick="browserMode('iframe')" id="mode-iframe" style="background: rgba(0,255,0,0.2); color: var(--green); border: 1px solid var(--green); padding: 4px 8px; border-radius: 3px; cursor: pointer; font-weight: bold;"> iFrame</button>
            <button onclick="browserMode('proxy')" id="mode-proxy" style="background: rgba(0,212,255,0.2); color: var(--cyan); border: 1px solid var(--cyan); padding: 4px 8px; border-radius: 3px; cursor: pointer;"> Proxy</button>
            <button onclick="browserMode('embedded')" id="mode-embedded" style="background: rgba(138,43,226,0.2); color: #8b5cf6; border: 1px solid #8b5cf6; padding: 4px 8px; border-radius: 3px; cursor: pointer;"> Embedded</button>
            <div style="width: 1px; background: rgba(0,212,255,0.3); margin: 0 5px;"></div>
            <button onclick="browserQuickNav('https://youtube.com')" style="background: rgba(255,0,0,0.2); color: #ff0000; border: 1px solid #ff0000; padding: 4px 8px; border-radius: 3px; cursor: pointer;"> YouTube</button>
            <button onclick="browserQuickNav('https://www.twitch.tv')" style="background: rgba(138,43,226,0.2); color: #8b5cf6; border: 1px solid #8b5cf6; padding: 4px 8px; border-radius: 3px; cursor: pointer;"> Twitch</button>
            <button onclick="browserQuickNav('https://www.netflix.com')" style="background: rgba(255,0,0,0.2); color: #ff0000; border: 1px solid #ff0000; padding: 4px 8px; border-radius: 3px; cursor: pointer;"> Netflix</button>
            <button onclick="browserQuickNav('https://www.reddit.com')" style="background: rgba(255,107,53,0.2); color: var(--orange); border: 1px solid var(--orange); padding: 4px 8px; border-radius: 3px; cursor: pointer;"> Reddit</button>
            <button onclick="browserQuickNav('https://www.wikipedia.org')" style="background: rgba(0,212,255,0.2); color: var(--cyan); border: 1px solid var(--cyan); padding: 4px 8px; border-radius: 3px; cursor: pointer;"> Wiki</button>
            <button onclick="browserQuickNav('http://localhost:11441')" style="background: rgba(0,255,0,0.2); color: var(--green); border: 1px solid var(--green); padding: 4px 8px; border-radius: 3px; cursor: pointer;"> Orchestra</button>
        </div>
        <div id="browser-container" style="flex: 1; position: relative; background: var(--bg);">
            <!-- iFrame Mode (Default but limited) -->
            <iframe id="browser-frame" srcdoc="<html><head><style>body{margin:0;padding:40px;font-family:'Courier New',monospace;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:white;text-align:center;}.hero{font-size:48px;margin-bottom:20px;animation:float 3s ease-in-out infinite;}@keyframes float{0%,100%{transform:translateY(0)}50%{transform:translateY(-10px)}}.stats{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin:30px auto;max-width:700px;}.stat-card{background:rgba(255,255,255,0.15);backdrop-filter:blur(15px);border:2px solid rgba(255,255,255,0.4);border-radius:15px;padding:30px;box-shadow:0 8px 32px rgba(0,0,0,0.3);transition:all 0.3s;}.stat-card:hover{transform:scale(1.05);box-shadow:0 12px 40px rgba(0,0,0,0.5);}.stat-number{font-size:72px;font-weight:bold;margin-bottom:10px;background:linear-gradient(45deg,#fff,#00f6ff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;}.stat-label{font-size:18px;opacity:0.9;}.mode-info{margin:30px auto;max-width:600px;padding:20px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:10px;font-size:14px;line-height:1.8;}.mode-btn{display:inline-block;margin:20px 10px;padding:15px 30px;background:rgba(0,246,255,0.3);border:2px solid #00f6ff;border-radius:8px;color:white;font-weight:bold;cursor:pointer;transition:all 0.3s;text-decoration:none;}.mode-btn:hover{background:rgba(0,246,255,0.5);transform:scale(1.1);box-shadow:0 0 20px rgba(0,246,255,0.8);}</style></head><body><div class='hero'> BigDaddyG Orchestra</div><div style='font-size:24px;margin-bottom:30px;opacity:0.9;'> Trained Security & ASM Specialist</div><div class='stats'><div class='stat-card'><div class='stat-number'>200K</div><div class='stat-label'> Training Lines</div></div><div class='stat-card'><div class='stat-number'>57</div><div class='stat-label'> Agents</div></div><div class='stat-card'><div class='stat-number'>14,500+</div><div class='stat-label'> IDE Lines</div></div><div class='stat-card'><div class='stat-number'>30+</div><div class='stat-label'> Endpoints</div></div></div><div class='mode-info'><div style='font-size:18px;font-weight:bold;margin-bottom:15px;'> BigDaddyG Specializations:</div><div><strong> Assembly:</strong> x86/x64 ASM expert (200K training lines)</div><div><strong> Security:</strong> Encryption, security research, exploit dev</div><div><strong> Polymorphism:</strong> Shape-shifting encryption code</div><div><strong> Ollama:</strong> Chat with any Ollama model through this IDE</div><div style='margin-top:20px;'><a class='mode-btn' href='#' onclick='parent.browserMode(\"proxy\");return false;'> YouTube/Netflix</a><a class='mode-btn' href='http://localhost:11441' target='_parent'> Orchestra API</a></div></div><div style='margin-top:30px;font-size:12px;opacity:0.6;'> Trained, not algorithmic  Real security expertise  No templates</div></body></html>" sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-modals allow-downloads allow-top-navigation" style="flex: 1; width: 100%; border: none; background: white; display: block;" class="browser-mode-iframe"></iframe>
            
            <!-- Embedded Browser Mode (Using webview-like rendering) -->
            <div id="embedded-browser" style="display: none; flex: 1; width: 100%; height: 100%; background: var(--bg); color: var(--cyan); padding: 20px; overflow: auto;" class="browser-mode-embedded">
                <div style="text-align: center; padding: 40px;">
                    <div style="font-size: 48px; margin-bottom: 20px;"></div>
                    <div style="font-size: 24px; margin-bottom: 15px;">Embedded Browser Mode</div>
                    <div style="opacity: 0.7; margin-bottom: 30px;">Advanced rendering for restricted sites</div>
                    <div style="background: rgba(0,212,255,0.1); border: 1px solid var(--cyan); border-radius: 8px; padding: 20px; max-width: 600px; margin: 0 auto;">
                        <div style="margin: 10px 0;"> Bypasses X-Frame-Options</div>
                        <div style="margin: 10px 0;"> Works with YouTube, MovieBoxPro, Netflix</div>
                        <div style="margin: 10px 0;"> Full JavaScript execution</div>
                        <div style="margin: 10px 0;"> Cookie & session support</div>
                    </div>
                    <button onclick="browserMode('iframe')" style="margin-top: 30px; background: var(--cyan); color: var(--void); border: none; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px;"> Back to iFrame Mode</button>
                </div>
            </div>
            
            <!-- Proxy Browser Mode (Server-side rendering) -->
            <div id="proxy-browser" style="display: none; flex: 1; width: 100%; height: 100%; background: var(--bg); color: var(--cyan); padding: 20px; overflow: auto;" class="browser-mode-proxy">
                <div style="text-align: center; padding: 40px;">
                    <div style="font-size: 48px; margin-bottom: 20px;"></div>
                    <div style="font-size: 24px; margin-bottom: 15px;">Proxy Browser Mode</div>
                    <div style="opacity: 0.7; margin-bottom: 30px;">Routes requests through Orchestra server</div>
                    <div id="proxy-content" style="background: rgba(0,212,255,0.05); border: 1px solid var(--cyan); border-radius: 8px; padding: 20px; max-width: 800px; margin: 0 auto; text-align: left;">
                        <div style="color: var(--orange); margin-bottom: 15px; font-weight: bold;"> Proxy Features:</div>
                        <div style="margin: 10px 0; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px;"> Bypasses CORS and X-Frame-Options</div>
                        <div style="margin: 10px 0; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px;"> Server-side rendering via Orchestra</div>
                        <div style="margin: 10px 0; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px;"> Access ANY website (YouTube, Netflix, GitHub, etc.)</div>
                        <div style="margin: 10px 0; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px;"> Full interaction support</div>
                        <div style="margin-top: 20px; padding: 15px; background: rgba(255,107,53,0.1); border: 1px solid var(--orange); border-radius: 5px; font-size: 12px;">
                             <strong>How it works:</strong> Orchestra server fetches the page, strips X-Frame headers, and serves it to you with full functionality.
                        </div>
                    </div>
                    <div style="margin-top: 30px; display: flex; gap: 15px; justify-content: center;">
                        <button onclick="loadProxyUrl('https://youtube.com')" style="background: #ff0000; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px;"> Load YouTube</button>
                        <button onclick="loadProxyUrl('https://github.com')" style="background: #333; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px;"> Load GitHub</button>
                        <button onclick="browserMode('iframe')" style="background: var(--orange); color: var(--void); border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px;"> Back</button>
                    </div>
                </div>
            </div>
        </div>
        <div style="padding: 5px; background: var(--bg); border-top: 1px solid rgba(0,212,255,0.3); font-size: 10px; color: #888; display: flex; justify-content: space-between; align-items: center;">
            <span> Works in iframe |  Opens in new tab (for blocked sites)</span>
            <span id="browser-load-status" style="color: var(--green);">  Ready</span>
        </div>
    </div>
    
    <!-- RESIZER 4 (Between Middle-Right and Right) -->
    <div class="pane-resizer" id="resizer-4"></div>

    <!-- ===== RIGHT PANEL = EXTENSIONS & AGENTS ===== -->
    <div id="right-panel" style="flex: 0 0 300px; min-width: 200px; max-width: 500px;">
        <!-- ===== TOP TAB NAVIGATION (MOVED FROM BOTTOM, COLLAPSIBLE) ===== -->
        <div id="bottom-tab-navigation" class="expanded">
            <div class="tab-nav-header">
                <span class="tab-nav-title"> Navigation Tabs</span>
                <button class="tab-collapse-btn" onclick="toggleTabNav()"> Collapse</button>
            </div>
            <div class="tab-buttons-container" id="tab-buttons">
                <button class="bottom-tab-btn active" onclick="switchTab('agents')"> Agents</button>
                <button class="bottom-tab-btn" onclick="switchTab('bigdaddyg-ai')"> BigDaddyG AI</button>
                <button class="bottom-tab-btn" onclick="switchTab('extensions')"> Marketplace</button>
                <button class="bottom-tab-btn" onclick="switchTab('tools')"> Tools</button>
                <button class="bottom-tab-btn" onclick="switchTab('quantization')"> Quantization</button>
                <button class="bottom-tab-btn" onclick="switchTab('micro-models')"> Micro Models</button>
                <button class="bottom-tab-btn" onclick="switchTab('history')"> History</button>
            </div>
        </div>

        <!-- Supernova Agent Tab -->
        <div id="supernova-tab" class="tab-content active">
            <div id="agents-header">
                 Code Supernova 1M MAX Stealth
                <div id="supernova-connection-status" class="font-12 margin-top-5"> Disconnected</div>
            </div>
            
            <!-- Supernova Split Layout -->
            <div style="display: flex; gap: 10px; height: calc(100% - 60px); overflow: hidden;">
                <!-- Left: Code Editor -->
                <div style="flex: 1; display: flex; flex-direction: column; border: 1px solid var(--cyan); border-radius: 5px; overflow: hidden;">
                    <div style="background: var(--cyan); color: var(--void); padding: 5px 10px; font-weight: bold;"> Code Editor</div>
                    <textarea id="supernova-code-editor" 
                              spellcheck="false" 
                              autocorrect="off"
                              style="flex: 1; background: var(--bg); color: var(--cyan); border: none; padding: 10px; font-family: 'Courier New', monospace; font-size: 14px; resize: none; outline: none;"
                              placeholder="// Write your code here...">// Supernova Code Editor
// Ask Supernova to generate code, then run it here!

console.log("Hello from Supernova!");</textarea>
                    <div style="display: flex; gap: 5px; padding: 5px; background: rgba(0, 212, 255, 0.1); border-top: 1px solid var(--cyan);">
                        <button onclick="runSupernovaCode()" style="background: var(--green); color: var(--void); border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 12px;"> Run</button>
                        <button onclick="clearSupernovaCode()" style="background: var(--red); color: var(--void); border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                        <button onclick="insertCodeToSupernova()" style="background: var(--cyan); color: var(--void); border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 12px;"> Copy to Main</button>
                    </div>
                </div>
                
                <!-- Right: Chat Interface -->
                <div style="flex: 1; display: flex; flex-direction: column; border: 1px solid var(--orange); border-radius: 5px; overflow: hidden;">
                    <div style="background: var(--orange); color: var(--void); padding: 5px 10px; font-weight: bold;"> AI Chat</div>
                    <div id="supernova-chat" style="flex: 1; overflow-y: auto; padding: 10px; background: var(--bg);"></div>
            
            <!-- Supernova Input -->
                    <div id="supernova-input-container" style="display: flex; gap: 5px; padding: 5px; background: rgba(255, 107, 53, 0.1); border-top: 1px solid var(--orange);">
                        <input type="text" id="supernova-input" placeholder="Ask Supernova to generate or modify code..." style="flex: 1; background: var(--bg); color: var(--cyan); border: 1px solid var(--orange); padding: 8px; border-radius: 3px; outline: none;" />
                        <button id="supernova-send" style="background: var(--orange); color: var(--void); border: none; padding: 8px 20px; border-radius: 3px; cursor: pointer; font-weight: bold;">Send</button>
            </div>
            
            <!-- Supernova Controls -->
                    <div id="supernova-controls" style="display: flex; gap: 5px; padding: 5px; background: rgba(255, 107, 53, 0.05);">
                        <button id="supernova-new-session" style="flex: 1; background: var(--teal); color: var(--void); border: none; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">New Session</button>
                        <button id="supernova-clear" style="flex: 1; background: var(--red); color: var(--void); border: none; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">Clear Chat</button>
                    </div>
                </div>
            </div>
            
            <!-- Supernova Status Bar -->
            <div id="supernova-status" style="display: flex; justify-content: space-around; padding: 5px; background: rgba(0, 212, 255, 0.1); border-top: 1px solid var(--cyan); margin-top: 5px; font-size: 11px;">
                <div class="status-item">
                    <span class="status-label">Status:</span>
                    <span class="status-value">Initializing...</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Sessions:</span>
                    <span class="status-value">0</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Context:</span>
                    <span class="status-value">0 / 1,000,000 tokens</span>
                </div>
            </div>
        </div>

        <!-- Agents Tab -->
        <div id="agents-tab" class="tab-content">
            <div id="agents-header">
                 Agent Control Center
                <div id="connection-status" class="font-12 margin-top-5"> Disconnected</div>
                <div class="margin-top-10">
                <button onclick="openBrowserWindow()" class="btn-orange"> Open Browser</button>
                <button onclick="openTerminalWindow()" class="btn-green margin-left-5"> Terminal</button>
                <button onclick="openCodeEditorWindow()" class="btn-cyan margin-left-5"> Code</button>
                </div>
            </div>
            <div id="browser-controls">
                <button onclick="runAgent('Elder')">Elder</button>
                <button onclick="runAgent('Fetcher')">Fetcher</button>
                <button onclick="runAgent('Browser')">Browser</button>
                <button onclick="runAgent('Parser')">Parser</button>
            </div>
            <div id="agents">
                <div class="agent-status" data-agent="Elder">
                    <div class="indicator status-idle"></div>
                    <div>
                        <strong>Elder Agent</strong><br>
                        <small>Orchestrates all operations</small>
                    </div>
                    <div class="agent-actions">
                        <button onclick="configureAgent('Elder')"></button>
                        <button onclick="viewAgentLogs('Elder')"></button>
                    </div>
                </div>
                <div class="agent-status" data-agent="Fetcher">
                    <div class="indicator status-idle"></div>
                    <div>
                        <strong>Fetcher Agent</strong><br>
                        <small>Retrieves web content</small>
                    </div>
                    <div class="agent-actions">
                        <button onclick="configureAgent('Fetcher')"></button>
                        <button onclick="viewAgentLogs('Fetcher')"></button>
                    </div>
                </div>
                <div class="agent-status" data-agent="Browser">
                    <div class="indicator status-idle"></div>
                    <div>
                        <strong>Browser Agent</strong><br>
                        <small>Controls web navigation</small>
                    </div>
                    <div class="agent-actions">
                        <button onclick="configureAgent('Browser')"></button>
                        <button onclick="viewAgentLogs('Browser')"></button>
                    </div>
                </div>
                <div class="agent-status" data-agent="Parser">
                    <div class="indicator status-idle"></div>
                    <div>
                        <strong>Parser Agent</strong><br>
                        <small>Processes and analyzes data</small>
                    </div>
                    <div class="agent-actions">
                        <button onclick="configureAgent('Parser')"></button>
                        <button onclick="viewAgentLogs('Parser')"></button>
                    </div>
                </div>
            </div>
        </div>

        
        <!-- BigDaddyG AI Chat Tab -->
        <div id="bigdaddyg-ai-tab" class="bottom-tab-content">
                <div class="padding-15 bg-void color-cyan height-100 flex flex-column position-relative z-1000">
                <div class="border-bottom-cyan padding-10 margin-bottom-10">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 10px;">
                        <div style="flex: 1; min-width: 300px;">
                            <h3> BigDaddyG AI - Trained + Ollama</h3>
                            <div class="font-11 color-green margin-top-5"> Trained on 200K Lines (ASM/Security/Encryption)  Ollama Models Available</div>
                            
                            <!-- Model Selector Dropdown -->
                            <div style="margin-top: 10px; display: flex; gap: 10px; align-items: center;">
                                <label style="font-size: 12px; color: var(--cyan); font-weight: bold;">Select Model:</label>
                                <select id="model-selector-dropdown" onchange="selectModelFromDropdown()" style="flex: 1; background: var(--bg); color: var(--cyan); border: 2px solid var(--cyan); padding: 8px; border-radius: 5px; font-family: 'Courier New', monospace; font-size: 12px; cursor: pointer; outline: none;">
                                    <option value="embedded:BigDaddyG:Latest">BigDaddyG:Latest (Embedded)</option>
                                    <option value="embedded:BigDaddyG:Code">BigDaddyG:Code (Embedded)</option>
                                    <option value="embedded:BigDaddyG:Debug">BigDaddyG:Debug (Embedded)</option>
                                    <option value="embedded:BigDaddyG:Crypto">BigDaddyG:Crypto (Embedded)</option>
                                </select>
                            </div>
                        </div>
                        <button onclick="openModelScanner()" style="background: var(--purple); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; font-family: 'Courier New', monospace; transition: all 0.2s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.background='var(--cyan)'" onmouseout="this.style.transform='scale(1)'; this.style.background='var(--purple)'">
                             Model Scanner
                        </button>
                    </div>
                    <div class="flex flex-gap-10 margin-top-10 flex-wrap">
                        <button onclick="selectAIModel('BigDaddyG:Latest')" id="model-latest" class="ai-model-btn ai-model-active model-btn-base model-btn-cyan">Latest</button>
                        <button onclick="selectAIModel('BigDaddyG:Code')" id="model-code" class="ai-model-btn model-btn-base model-btn-green">Code</button>
                        <button onclick="selectAIModel('BigDaddyG:Debug')" id="model-debug" class="ai-model-btn model-btn-base model-btn-orange">Debug</button>
                        <button onclick="selectAIModel('BigDaddyG:Crypto')" id="model-crypto" class="ai-model-btn model-btn-base model-btn-red">Crypto</button>
                        <span id="current-model-display" style="padding: 5px 10px; background: rgba(155, 89, 182, 0.2); border: 1px solid var(--purple); border-radius: 3px; font-size: 11px; color: var(--purple); font-weight: bold;">Current: BigDaddyG:Latest</span>
                        <button onclick="openBigDaddyGTuner()" style="background: rgba(138,43,226,0.3); color: #8b5cf6; border: 1px solid #8b5cf6; padding: 5px 12px; border-radius: 3px; cursor: pointer; font-size: 11px; font-weight: bold; margin-left: 10px;"> Tune</button>
                    </div>
                    <div class="flex flex-gap-10 margin-top-10 flex-align-center">
                        <span class="font-12">Emotional State:</span>
                        <button onclick="setEmotionalState('CALM', event)" class="emotion-btn emotion-btn-base emotion-calm">CALM</button>
                        <button onclick="setEmotionalState('FOCUSED', event)" class="emotion-btn emotion-btn-base emotion-focused">FOCUSED</button>
                        <button onclick="setEmotionalState('INTENSE', event)" class="emotion-btn emotion-btn-base emotion-intense">INTENSE</button>
                        <button onclick="setEmotionalState('OVERWHELMED', event)" class="emotion-btn emotion-btn-base emotion-overwhelmed">OVERWHELMED</button>
                        <span id="current-emotion" class="current-emotion">CALM</span>
                    </div>
                    <div style="margin-top: 10px; padding: 10px; background: rgba(138,43,226,0.1); border: 1px solid rgba(138,43,226,0.3); border-radius: 5px; font-size: 10px; display: flex; justify-content: space-between; align-items: center;">
                        <div style="display: flex; gap: 15px;">
                            <span> <strong>Context:</strong> <span id="context-tokens">0</span> / 1M tokens</span>
                            <span> <strong>Temp:</strong> <span id="param-temp">0.7</span></span>
                            <span> <strong>Max:</strong> <span id="param-max">4000</span></span>
                        </div>
                        <button onclick="clearBigDaddyGContext()" style="background: var(--orange); color: var(--void); border: none; padding: 4px 10px; border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: bold;"> Clear Context</button>
                    </div>
                </div>
                
                <div id="ai-chat-container" class="flex-1 overflow-auto bg-bg padding-10 border-cyan margin-bottom-10 min-h-200">
                    <div class="ai-message">
                        <strong>BigDaddyG:</strong>  Ready! I'm your fully embedded, offline AI assistant. No internet or server required!
                        <br><br>
                        <strong>Try me:</strong>
                        <br> "Write a C++ parser for a compiler"
                        <br> "Debug my memory leak"
                        <br> "How do I encrypt passwords?"
                        <br><br>
                        Select a model above and ask anything! 
                    </div>
                </div>
                
                <div class="ai-input-container position-relative z-500">
                    <input type="text" id="ai-input" placeholder="Ask BigDaddyG..." class="flex-1 bg-bg color-cyan border-cyan padding-8 font-12 position-relative z-500 font-monospace" onkeypress="handleAIKeyPress(event)" />
                    <button onclick="sendToAI()" class="model-btn-base font-weight-bold bg-teal padding-8-15">Send</button>
                    <button onclick="clearAIChat()" class="model-btn-base model-btn-red padding-8-15">Clear</button>
                </div>
                
                <div class="margin-top-10 font-11 color-gray">
                    <span>Total Queries: <span id="ai-query-count">0</span></span> | 
                    <span>Model: <span id="ai-current-model">BigDaddyG:Latest</span></span> | 
                    <span>Avg Response: <span id="ai-avg-response">0ms</span></span>
                </div>
            </div>
        </div>


<!-- Extensions Marketplace Tab -->
        <div id="extensions-tab" class="tab-content">
            <div id="marketplace-header">
                 Extension Marketplace
                <div class="info-text">Discover & install extensions</div>
            </div>
            <div id="marketplace-content">
                <div class="extension-category">
                    <h4> Development Tools</h4>
                    <div class="extension-grid">
                        <div class="extension-card" onclick="installExtension('code-formatter')">
                            <div class="extension-icon"></div>
                            <div class="extension-info">
                                <strong>Code Formatter</strong>
                                <small>Auto-format your code</small>
                            </div>
                            <button class="install-btn">Install</button>
                        </div>
                        <div class="extension-card" onclick="installExtension('debugger')">
                            <div class="extension-icon"></div>
                            <div class="extension-info">
                                <strong>Advanced Debugger</strong>
                                <small>Step-through debugging</small>
                            </div>
                            <button class="install-btn">Install</button>
                        </div>
                        <div class="extension-card" onclick="installExtension('git-integration')">
                            <div class="extension-icon"></div>
                            <div class="extension-info">
                                <strong>Git Integration</strong>
                                <small>Version control tools</small>
                            </div>
                            <button class="install-btn">Install</button>
                        </div>
                    </div>
                </div>

                <div class="extension-category">
                    <h4> AI & Agents</h4>
                    <div class="extension-grid">
                        <div class="extension-card" onclick="installExtension('ml-trainer')">
                            <div class="extension-icon"></div>
                            <div class="extension-info">
                                <strong>ML Trainer</strong>
                                <small>Train custom models</small>
                            </div>
                            <button class="install-btn">Install</button>
                        </div>
                        <div class="extension-card" onclick="installExtension('agent-builder')">
                            <div class="extension-icon"></div>
                            <div class="extension-info">
                                <strong>Agent Builder</strong>
                                <small>Create custom agents</small>
                            </div>
                            <button class="install-btn">Install</button>
                        </div>
                        <div class="extension-card" onclick="installExtension('nlp-tools')">
                            <div class="extension-icon"></div>
                            <div class="extension-info">
                                <strong>NLP Tools</strong>
                                <small>Text processing suite</small>
                            </div>
                            <button class="install-btn">Install</button>
                        </div>
                    </div>
                </div>

                <div class="extension-category">
                    <h4> Web & Networking</h4>
                    <div class="extension-grid">
                        <div class="extension-card" onclick="installExtension('web-scraper')">
                            <div class="extension-icon"></div>
                            <div class="extension-info">
                                <strong>Web Scraper</strong>
                                <small>Advanced scraping tools</small>
                            </div>
                            <button class="install-btn">Install</button>
                        </div>
                        <div class="extension-card" onclick="installExtension('api-tester')">
                            <div class="extension-icon"></div>
                            <div class="extension-info">
                                <strong>API Tester</strong>
                                <small>Test REST APIs</small>
                            </div>
                            <button class="install-btn">Install</button>
                        </div>
                        <div class="extension-card" onclick="installExtension('network-monitor')">
                            <div class="extension-icon"></div>
                            <div class="extension-info">
                                <strong>Network Monitor</strong>
                                <small>Monitor connections</small>
                            </div>
                            <button class="install-btn">Install</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tools Tab -->
        <div id="tools-tab" class="tab-content">
            <div id="tools-header">
                 Development Tools
                <div class="info-text">Productivity enhancers</div>
            </div>
            <div id="tools-content">
                <div class="tool-section">
                    <h4> Code Tools</h4>
                    <button class="tool-btn" onclick="runTool('format-code')">Format Code</button>
                    <button class="tool-btn" onclick="runTool('minify-code')">Minify Code</button>
                    <button class="tool-btn" onclick="runTool('beautify-code')">Beautify Code</button>
                    <button class="tool-btn" onclick="runTool('validate-syntax')">Validate Syntax</button>
                </div>

                <div class="tool-section">
                    <h4> Analysis Tools</h4>
                    <button class="tool-btn" onclick="runTool('code-complexity')">Complexity Analysis</button>
                    <button class="tool-btn" onclick="runTool('dependency-check')">Dependency Check</button>
                    <button class="tool-btn" onclick="runTool('security-scan')">Security Scan</button>
                    <button class="tool-btn" onclick="runTool('performance-profile')">Performance Profile</button>
                </div>

                <div class="tool-section">
                    <h4> Data Tools</h4>
                    <button class="tool-btn" onclick="runTool('json-formatter')">JSON Formatter</button>
                    <button class="tool-btn" onclick="runTool('csv-converter')">CSV Converter</button>
                    <button class="tool-btn" onclick="runTool('data-visualizer')">Data Visualizer</button>
                    <button class="tool-btn" onclick="runTool('regex-tester')">Regex Tester</button>
                </div>
            </div>
        </div>

        <!-- History Tab -->
        <div id="history-tab" class="tab-content">
            <div id="history-header">
                 Session History
                <div class="info-text">Command & execution history</div>
            </div>
            <div id="history-content">
                <div id="history-list">
                    <!-- History entries will be populated here -->
                </div>
                <div class="history-controls">
                    <button onclick="clearHistory()" class="history-btn">Clear History</button>
                    <button onclick="exportHistory()" class="history-btn">Export History</button>
                </div>
            </div>
        </div>

        <!-- Quantization Tab -->
        <div id="quantization-tab" class="tab-content">
            <div id="quantization-header">
                 Model Quantization
                <div class="info-text">Optimize models for 512MB RAM</div>
            </div>
            <div id="quantization-content">
                <div class="quantization-section">
                    <h4> Cloud Model Integration</h4>
                    <div class="model-grid">
                        <div class="model-card">
                            <div class="model-icon"></div>
                            <div class="model-info">
                                <strong>Claude 3 Opus</strong>
                                <small>200K context, vision, tools</small>
                            </div>
                            <button onclick="testCloudModel('claude-3-opus')" class="model-btn">Test</button>
                        </div>
                        <div class="model-card">
                            <div class="model-icon"></div>
                            <div class="model-info">
                                <strong>Grok 1.5</strong>
                                <small>128K context, real-time</small>
                            </div>
                            <button onclick="testCloudModel('grok-1.5')" class="model-btn">Test</button>
                        </div>
                        <div class="model-card">
                            <div class="model-icon"></div>
                            <div class="model-info">
                                <strong>DeepSeek Coder</strong>
                                <small>128K context, code expert</small>
                            </div>
                            <button onclick="testCloudModel('deepseek-coder')" class="model-btn">Test</button>
                        </div>
                    </div>
                </div>

                <div class="quantization-section">
                    <h4> Local Quantization (512MB RAM)</h4>
                    <div class="quantization-controls">
                        <div class="control-group">
                            <label>Model Path:</label>
                            <input type="text" id="model-path" placeholder="path/to/model.gguf" />
                            <button onclick="selectModelFile()" class="file-btn">Browse</button>
                        </div>
                        <div class="control-group">
                            <label>Quantization Type:</label>
                            <select id="quant-type">
                                <option value="q2_k">Q2_K (512MB) - Maximum compression</option>
                                <option value="q3_k_l">Q3_K_L (768MB) - Balanced</option>
                                <option value="q4_k_m">Q4_K_M (1GB+) - Quality</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Target Memory:</label>
                            <input type="number" id="target-memory" value="512" min="256" max="2048" /> MB
                        </div>
                        <button onclick="startQuantization()" class="quantize-btn"> Start Quantization</button>
                    </div>

                    <div class="progress-section">
                        <div id="quantization-progress" class="display-none">
                            <div class="progress-bar">
                                <div class="progress-fill"></div>
                            </div>
                            <div class="progress-text">Initializing...</div>
                        </div>
                    </div>

                    <div class="quantized-models-list">
                        <h5> Available Quantized Models</h5>
                        <div id="quantized-models-grid">
                            <!-- Quantized models will be listed here -->
                        </div>
                    </div>
                </div>

                <div class="quantization-section">
                    <h4> DeepSeek 512MB Special</h4>
                    <p>Create an ultra-compressed DeepSeek model optimized for 512MB RAM with maximum efficiency.</p>
                    <button onclick="createDeepSeek512MB()" class="special-btn"> Create DeepSeek 512MB</button>
                    <div class="model-specs">
                        <div class="spec-item">
                            <span class="spec-label">Memory Usage:</span>
                            <span class="spec-value">512MB</span>
                        </div>
                        <div class="spec-item">
                            <span class="spec-label">Context Window:</span>
                            <span class="spec-value">4K tokens</span>
                        </div>
                        <div class="spec-item">
                            <span class="spec-label">Quantization:</span>
                            <span class="spec-value">Q2_K ultra</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Micro Models Tab -->
        <div id="micro-models-tab" class="tab-content">
            <div id="micro-models-header">
                 Micro-Model Chain System
                <div class="info-text">Tiny specialized AI models (<200 lines each)</div>
            </div>
            <div id="micro-models-content">
                <div class="micro-models-section">
                    <h4> Micro Model Chain</h4>
                    <div class="chain-controls">
                        <div class="control-group">
                            <label>Input Data:</label>
                            <textarea id="micro-input" placeholder="Enter your request (e.g., 'Create a Python function to process user data')" rows="3"></textarea>
                        </div>
                        <div class="control-group">
                            <label>Start Model:</label>
                            <select id="start-model">
                                <option value="micro_analyzer">Micro Analyzer - Pattern recognition</option>
                                <option value="micro_generator">Micro Generator - Content creation</option>
                                <option value="micro_optimizer">Micro Optimizer - Performance tuning</option>
                                <option value="micro_validator">Micro Validator - Quality checking</option>
                            </select>
                        </div>
                        <button onclick="executeMicroChain()" class="chain-btn"> Execute Micro Chain</button>
                    </div>
                </div>

                <div class="micro-models-section">
                    <h4> Nano Model Chain (Ultra-Compact)</h4>
                    <div class="nano-controls">
                        <div class="control-group">
                            <label>Input Data:</label>
                            <textarea id="nano-input" placeholder="Enter your request for ultra-compact processing" rows="2"></textarea>
                        </div>
                        <button onclick="executeNanoChain()" class="nano-btn"> Execute Nano Chain</button>
                    </div>
                </div>

                <div class="micro-models-section">
                    <h4> Model Catalog</h4>
                    <div class="catalog-controls">
                        <button onclick="loadMicroCatalog()" class="catalog-btn"> Load Micro Models</button>
                        <button onclick="loadNanoCatalog()" class="catalog-btn"> Load Nano Models</button>
                    </div>
                    <div id="model-catalog-grid">
                        <!-- Model catalog will be displayed here -->
                    </div>
                </div>

                <div class="micro-models-section">
                    <h4> Testing & Deployment</h4>
                    <div class="test-controls">
                        <div class="control-group">
                            <label>Test Input:</label>
                            <input type="text" id="test-input" placeholder="Test input for micro models" />
                        </div>
                        <div class="control-group">
                            <label>Chain Type:</label>
                            <select id="test-chain-type">
                                <option value="micro">Micro Chain</option>
                                <option value="nano">Nano Chain</option>
                            </select>
                        </div>
                        <button onclick="testMicroChain()" class="test-btn"> Test Chain</button>
                        <button onclick="deployMicroModels()" class="deploy-btn"> Deploy to Edge</button>
                    </div>
                </div>

                <div class="micro-models-section">
                    <h4> Chain Results</h4>
                    <div id="chain-results">
                        <!-- Chain execution results will be displayed here -->
                    </div>
                </div>
            </div>
        </div>

        </div> <!-- End main-view -->

        <!-- Workspace Template View -->
        <div id="workspace-view" class="view-container dashboard-view display-none">
            <iframe src="workspace-template.html" class="iframe-full"></iframe>
        </div>

        <!-- Dashboard View -->
        <div id="dashboard-view" class="view-container dashboard-view display-none">
            <iframe src="dashboard.html" class="iframe-full"></iframe>
        </div>
    </div>

    <!-- Navigation bar now at top of right panel -->

    <!-- Copilot Context Menu -->
    <div class="code-context-menu" id="code-context-menu" role="menu" style="display: none;">
        <div class="context-menu-item" onclick="contextMenuAction('explain')" role="menuitem">
            <span class="context-menu-icon"></span>
            <span class="context-menu-label">Explain This</span>
            <span class="context-menu-shortcut">Ctrl+E</span>
        </div>
        
        <div class="context-menu-item" onclick="contextMenuAction('fix')" role="menuitem">
            <span class="context-menu-icon"></span>
            <span class="context-menu-label">Fix This</span>
            <span class="context-menu-shortcut">Ctrl+Shift+F</span>
        </div>
        
        <div class="context-menu-item" onclick="contextMenuAction('optimize')" role="menuitem">
            <span class="context-menu-icon"></span>
            <span class="context-menu-label">Optimize Code</span>
        </div>
        
        <div class="context-menu-item" onclick="contextMenuAction('refactor')" role="menuitem">
            <span class="context-menu-icon"></span>
            <span class="context-menu-label">Refactor</span>
        </div>
        
        <div class="context-menu-separator"></div>
        
        <div class="context-menu-item" onclick="contextMenuAction('tests')" role="menuitem">
            <span class="context-menu-icon"></span>
            <span class="context-menu-label">Generate Tests</span>
        </div>
        
        <div class="context-menu-item" onclick="contextMenuAction('docs')" role="menuitem">
            <span class="context-menu-icon"></span>
            <span class="context-menu-label">Generate Docs</span>
        </div>
        
        <div class="context-menu-separator"></div>
        
        <div class="context-menu-item" onclick="contextMenuAction('comment')" role="menuitem">
            <span class="context-menu-icon"></span>
            <span class="context-menu-label">Add Comments</span>
        </div>
    </div>

    <!-- Token Streaming Visualization Overlay -->
    <div id="token-stream-overlay"></div>

    <!-- Task Bubble Layer -->
    <div id="task-bubble-layer"></div>

    <!-- Task Modal (hidden by default) -->
    <div id="task-modal" class="task-modal">
        <div class="task-modal-header">
            <div class="task-modal-title" id="task-modal-title"> Task Details</div>
            <button class="task-modal-close" onclick="closeTaskModal()"></button>
        </div>
        <div id="task-modal-content">
            <div class="task-subtasks" id="task-subtasks">
                <!-- Subtasks will be populated here -->
            </div>
        </div>
        <div style="margin-top: 20px; display: flex; gap: 10px;">
            <button onclick="completeTask()" style="flex: 1; background: var(--green); color: var(--void); border: none; padding: 10px; border-radius: 5px; cursor: pointer; font-weight: bold;"> Complete</button>
            <button onclick="deleteTask()" style="flex: 1; background: var(--red); color: white; border: none; padding: 10px; border-radius: 5px; cursor: pointer; font-weight: bold;"> Delete</button>
        </div>
    </div>

    <!-- Stream Dashboard -->
    <div id="stream-dashboard" style="display: none;">
        <div style="border-bottom: 1px solid var(--cyan); padding-bottom: 10px; margin-bottom: 10px; font-weight: bold; color: var(--orange);">
             Token Stream Monitor
        </div>
        <div class="stream-stat">
            <span>Total Tokens:</span>
            <span class="stream-stat-value" id="total-tokens">0</span>
        </div>
        <div class="stream-stat">
            <span>Tokens/sec:</span>
            <span class="stream-stat-value" id="tokens-per-sec">0</span>
        </div>
        <div class="stream-stat">
            <span>Active Agents:</span>
            <span class="stream-stat-value" id="active-agents">0/4</span>
        </div>
        <div class="stream-stat">
            <span>Stream Health:</span>
            <span class="stream-stat-value" id="stream-health"> Optimal</span>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 10px;">
            <button onclick="rebirthOrchestration()" style="flex: 1; background: var(--green); color: var(--void); border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-size: 11px; font-weight: bold;"> Rebirth</button>
            <button onclick="toggleStreamVisualization()" style="flex: 1; background: var(--orange); color: var(--void); border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-size: 11px; font-weight: bold;"> Toggle</button>
        </div>
    </div>

    <!-- Model Scanner Modal -->
    <div id="model-scanner-modal" class="model-scanner-modal" style="display: none;">
        <div class="model-scanner-content">
            <div class="model-scanner-header">
                <h2> Model Scanner - Find All AI Models</h2>
                <button class="scanner-close-btn" onclick="closeModelScanner()"> Close</button>
            </div>
            
            <div class="model-scanner-controls">
                <button class="scanner-btn" onclick="scanAllModels()" id="scan-all-btn">
                     Scan All Sources
                </button>
                <button class="scanner-btn" onclick="scanOrchestra()">
                     Scan Orchestra
                </button>
                <button class="scanner-btn" onclick="scanOllama()">
                     Scan Ollama
                </button>
                <input type="text" class="model-search-box" id="model-search-input" placeholder=" Search models by name..." oninput="filterModels()">
            </div>
            
            <div class="model-stats">
                <div class="model-stat-item">
                    <div>Total Models:</div>
                    <div class="model-stat-value" id="total-models-count">0</div>
                </div>
                <div class="model-stat-item">
                    <div>Orchestra:</div>
                    <div class="model-stat-value" id="orchestra-models-count">0</div>
                </div>
                <div class="model-stat-item">
                    <div>Ollama:</div>
                    <div class="model-stat-value" id="ollama-models-count">0</div>
                </div>
                <div class="model-stat-item">
                    <div>Selected:</div>
                    <div class="model-stat-value" id="selected-model-name">None</div>
                </div>
            </div>
            
            <div class="model-list-container" id="model-list-container">
                <div style="padding: 40px; text-align: center; color: var(--cyan); font-family: 'Courier New', monospace;">
                     Click "Scan All Sources" to discover your models
                </div>
            </div>
        </div>
    </div>

    <!-- Load BigDaddyG Multi-Agent Orchestra -->
    <!-- Multi-agent orchestra will be loaded via backend API -->

    <script>
        // BigDaddyG Multi-Agent Orchestra (Simple Implementation)
        window.BigDaddyGMultiAgentOrchestra = {
            generateCode: async function(prompt, language = 'javascript', agentCount = 10, ttl = 30) {
                console.log(`[BIGDADDYG ORCHESTRA] Generating code for: ${prompt}`);
                
                // Simulate multi-agent code generation
                const timestamp = new Date().toISOString();
                let code = '';
                
                switch(language.toLowerCase()) {
                    case 'python':
                        code = `#!/usr/bin/env python3
"""
BigDaddyG Multi-Agent Orchestra
Generated: ${timestamp}
Prompt: ${prompt}
"""

def main():
    print("BigDaddyG Multi-Agent Orchestra executing...")
    print(f"Prompt: ${prompt}")
    print("Code generated by multiple AI agents")
    return "Success"

if __name__ == "__main__":
    result = main()
    print(result)`;
                        break;
                    case 'javascript':
                    case 'js':
                        code = `// BigDaddyG Multi-Agent Orchestra
// Generated: ${timestamp}
// Prompt: ${prompt}

function main() {
    console.log("BigDaddyG Multi-Agent Orchestra executing...");
    console.log("Prompt:", "${prompt}");
    console.log("Code generated by multiple AI agents");
    return "Success";
}

const result = main();
console.log(result);`;
                        break;
                    case 'go':
                        code = `// BigDaddyG Multi-Agent Orchestra
// Generated: ${timestamp}
// Prompt: ${prompt}
package main

import "fmt"

func main() {
    fmt.Println("BigDaddyG Multi-Agent Orchestra executing...")
    fmt.Println("Prompt:", "${prompt}")
    fmt.Println("Code generated by multiple AI agents")
}

func init() {
    fmt.Println("Initializing BigDaddyG Multi-Agent Orchestra...")
}`;
                        break;
                    default:
                        code = `// BigDaddyG Multi-Agent Orchestra
// Generated: ${timestamp}
// Prompt: ${prompt}

console.log("BigDaddyG Multi-Agent Orchestra executing...");
console.log("Prompt:", "${prompt}");
console.log("Code generated by multiple AI agents");`;
                }
                
                return {
                    success: true,
                    code: code,
                    language: language,
                    agentCount: agentCount,
                    ttl: ttl
                };
            }
        };

        // Global state
        let ws = null;
        let wsReconnectAttempts = 0;
        let wsMaxReconnects = 3;
        let wsReconnectTimeout = null;
        let agentStatuses = {
            'Elder': 'idle',
            'Fetcher': 'idle',
            'Browser': 'idle',
            'Parser': 'idle'
        };

        // Tab switching function
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none';
            });

            // Remove active class from all tab buttons
            document.querySelectorAll('.bottom-tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab content
            const selectedTab = document.getElementById(tabName + '-tab');
            const selectedBtn = document.querySelector(`button[onclick="switchTab('${tabName}')"]`);

            if (selectedTab) {
                selectedTab.classList.add('active');
                selectedTab.style.display = 'block';
                if (selectedBtn) {
                    selectedBtn.classList.add('active');
                }
            }

            log(` Switched to ${tabName} tab`, 'info');
        }
        
        // View switching function (IDE / Workspace / Dashboard)
        function switchView(viewName) {
            // Hide all views
            document.querySelectorAll('.view-container').forEach(view => {
                view.classList.remove('active');
                view.style.display = 'none';
            });
            
            // Remove active class from all view buttons
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected view
            const selectedView = document.getElementById(viewName + '-view');
            const selectedBtn = document.getElementById(viewName + '-btn');
            
            if (selectedView) {
                selectedView.classList.add('active');
                selectedView.style.display = 'flex';
            }
            
            if (selectedBtn) {
                selectedBtn.classList.add('active');
            }
            
            log(` Switched to ${viewName} view`, 'info');
            
            // Load workspace content if switching to workspace
            if (viewName === 'workspace') {
                setTimeout(() => loadWorkspaceDirectory(), 100);
            }
        }
        
        // New chat function
        function newChat() {
            log(' Starting new chat session...', 'info');
            const chatMessages = document.getElementById('chat-messages');
            if (chatMessages) {
                chatMessages.innerHTML = '';
            }
            log(' New chat session started', 'success');
        }

        // Make agents tab visible by default on load
        window.addEventListener('load', function() {
            const agentsTab = document.getElementById('agents-tab');
            if (agentsTab) {
                agentsTab.style.display = 'block';
                agentsTab.classList.add('active');
            }
        });

        // Toggle navigation bar collapse/expand
        function toggleTabNav() {
            const nav = document.getElementById('bottom-tab-navigation');
            const btnContainer = document.getElementById('tab-buttons');
            const btn = event.target;
            
            if (nav.classList.contains('collapsed')) {
                // Expand
                nav.classList.remove('collapsed');
                nav.classList.add('expanded');
                btnContainer.style.display = 'flex';
                btn.textContent = ' Collapse';
                log(' Navigation expanded', 'info');
            } else {
                // Collapse
                nav.classList.remove('expanded');
                nav.classList.add('collapsed');
                btnContainer.style.display = 'none';
                btn.textContent = ' Expand';
                log(' Navigation collapsed', 'info');
            }
        }

        // Extension marketplace functions
        function installExtension(extensionName) {
            log(` Installing extension: ${extensionName}`, 'info');

            // Simulate installation process
            setTimeout(() => {
                log(` Extension "${extensionName}" installed successfully!`, 'success');
            }, 2000);
        }

        // Tools functions
        function runTool(toolName) {
            log(` Running tool: ${toolName}`, 'info');

            // Simulate tool execution
            setTimeout(() => {
                log(` Tool "${toolName}" completed`, 'success');
            }, 1500);
        }

        // Agent configuration functions
        function configureAgent(agentName) {
            log(` Opening configuration for ${agentName}`, 'info');
            
            // Create modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: var(--void);
                border: 2px solid var(--cyan);
                border-radius: 8px;
                padding: 20px;
                max-width: 500px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
            `;
            
            content.innerHTML = `
                <h3 style="color: var(--cyan); margin-bottom: 15px;"> ${agentName} Agent Configuration</h3>
                
                <div style="margin-bottom: 15px;">
                    <label style="color: var(--cyan); display: block; margin-bottom: 5px;">Status:</label>
                    <select style="width: 100%; padding: 8px; background: var(--bg); color: var(--cyan); border: 1px solid var(--cyan); border-radius: 3px;">
                        <option>Active</option>
                        <option>Idle</option>
                        <option>Disabled</option>
                    </select>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="color: var(--cyan); display: block; margin-bottom: 5px;">Priority:</label>
                    <input type="range" min="1" max="10" value="5" style="width: 100%;">
                    <span style="color: var(--cyan); font-size: 12px;">Level: 5</span>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="color: var(--cyan); display: block; margin-bottom: 5px;">Auto-Retry:</label>
                    <input type="checkbox" checked style="width: 20px; height: 20px;">
                    <span style="color: var(--cyan); margin-left: 10px;">Enabled</span>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="color: var(--cyan); display: block; margin-bottom: 5px;">Timeout (seconds):</label>
                    <input type="number" value="30" min="5" max="300" style="width: 100%; padding: 8px; background: var(--bg); color: var(--cyan); border: 1px solid var(--cyan); border-radius: 3px;">
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button onclick="this.closest('[style*=fixed]').remove()" style="flex: 1; padding: 10px; background: var(--cyan); color: var(--void); border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
                         Save
                    </button>
                    <button onclick="this.closest('[style*=fixed]').remove()" style="flex: 1; padding: 10px; background: var(--red); color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
                         Cancel
                    </button>
                </div>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        function viewAgentLogs(agentName) {
            log(` Showing logs for ${agentName}`, 'info');
            
            // Create modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: var(--void);
                border: 2px solid var(--cyan);
                border-radius: 8px;
                padding: 20px;
                max-width: 700px;
                width: 90%;
                max-height: 80vh;
                display: flex;
                flex-direction: column;
            `;
            
            // Generate sample logs
            const sampleLogs = [
                { time: '11:30:15', level: 'info', message: `${agentName} agent initialized` },
                { time: '11:30:16', level: 'success', message: 'Connection established' },
                { time: '11:30:20', level: 'info', message: 'Waiting for tasks...' },
                { time: '11:31:05', level: 'warning', message: 'No backend connection detected' },
                { time: '11:31:10', level: 'info', message: 'Running in offline mode' }
            ];
            
            const logsHtml = sampleLogs.map(log => {
                const color = {
                    info: 'var(--cyan)',
                    success: 'var(--green)',
                    warning: 'var(--yellow)',
                    error: 'var(--red)'
                }[log.level];
                
                return `<div style="padding: 5px; border-bottom: 1px solid rgba(0, 212, 255, 0.1); font-size: 12px;">
                    <span style="color: #666;">[${log.time}]</span>
                    <span style="color: ${color}; font-weight: bold;">[${log.level.toUpperCase()}]</span>
                    <span style="color: var(--cyan);">${log.message}</span>
                </div>`;
            }).join('');
            
            content.innerHTML = `
                <h3 style="color: var(--cyan); margin-bottom: 15px;"> ${agentName} Agent Logs</h3>
                
                <div style="flex: 1; overflow-y: auto; background: var(--bg); border: 1px solid var(--cyan); border-radius: 4px; padding: 10px; margin-bottom: 15px; font-family: 'Courier New', monospace;">
                    ${logsHtml}
                    <div style="padding: 5px; color: #666; font-size: 11px; font-style: italic;">
                        --- End of logs ---
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <button onclick="alert('Logs cleared!')" style="flex: 1; padding: 10px; background: var(--orange); color: var(--void); border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
                         Clear Logs
                    </button>
                    <button onclick="alert('Logs exported!')" style="flex: 1; padding: 10px; background: var(--green); color: var(--void); border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
                         Export
                    </button>
                    <button onclick="this.closest('[style*=fixed]').remove()" style="flex: 1; padding: 10px; background: var(--cyan); color: var(--void); border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
                         Close
                    </button>
                </div>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        // History functions
        function clearHistory() {
            document.getElementById('history-list').innerHTML = '';
            log(' History cleared', 'warning');
        }

        function exportHistory() {
            const historyData = {
                timestamp: new Date().toISOString(),
                entries: [] // Would collect actual history entries
            };

            const blob = new Blob([JSON.stringify(historyData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `bigdaddyg-history-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);

            log(' History exported', 'success');
        }

        // Pop-out window functions
        function openBrowserWindow() {
            if (window.electronAPI) {
                window.electronAPI.openBrowserWindow();
                log(' Opened browser window', 'success');
            } else {
                log(' Opening browser in new tab (browser mode)...', 'info');
                // Fallback: open in new browser tab
                window.open('https://www.google.com', '_blank');
                log(' Browser opened successfully', 'success');
            }
        }

        function openTerminalWindow() {
            if (window.electronAPI) {
                window.electronAPI.openTerminalWindow();
                log(' Opened terminal window', 'success');
            } else {
                log(' Terminal requires Electron desktop app', 'warning');
                log(' Use console below for JavaScript commands', 'info');
            }
        }

        function openCodeEditorWindow() {
            if (window.electronAPI) {
                window.electronAPI.openCodeEditorWindow();
                log(' Opened code editor window', 'success');
            } else {
                log(' Opening code editor in new window (browser mode)...', 'info');
                // Fallback: open in new window with code editor
                const codeWindow = window.open('', '_blank', 'width=800,height=600');
                codeWindow.document.write(`
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>BigDaddyG Code Editor</title>
                        <style>
                            body { font-family: monospace; background: #111; color: #0ff; padding: 20px; }
                            textarea { width: 100%; height: 400px; background: #222; color: #0ff; border: 1px solid #0ff; }
                            button { background: #0ff; color: #000; border: none; padding: 10px; margin: 5px; cursor: pointer; }
                        </style>
                    </head>
                    <body>
                        <h1>BigDaddyG Code Editor</h1>
                        <textarea placeholder="Enter your code here..."></textarea>
                        <br>
                        <button onclick="runCode()">Run Code</button>
                        <button onclick="clearCode()">Clear</button>
                        <div id="output"></div>
                    </body>
                    </html>
                `);
                log(' Code editor opened successfully', 'success');
            }
        }

        // New Chat functionality
        function newChat() {
            log(' Starting new chat session...', 'info');
            
            // Clear the code editor
            const codeEl = document.getElementById('code');
            if (codeEl) {
                codeEl.value = '// New Chat Session\n// Ask BigDaddyG anything!\n\n';
            }
            
            // Clear console
            const consoleEl = document.getElementById('console');
            if (consoleEl) {
                consoleEl.innerHTML = '';
            }
            
            // Reset agent statuses
            Object.keys(agentStatuses).forEach(agent => {
                agentStatuses[agent] = 'idle';
                updateAgentStatus(agent, 'idle');
            });
            
            // Show code genie prompt
            showCodeGeniePrompt();
            
            log(' New chat session started', 'success');
        }

        // 10-Liner Code Genie functionality
        function showCodeGeniePrompt() {
            const codeEditor = document.getElementById('code');
            if (!codeEditor) {
                log(' Code editor not found', 'warning');
                return;
            }
            
            const geniePrompt = `//  BigDaddyG 10-Liner Code Genie
// Just describe what you want in 1-2 sentences, and I'll generate the code!

// Example: "Create a function that sorts an array of numbers"
// Example: "Make a simple calculator with add, subtract, multiply, divide"
// Example: "Generate a random password with 12 characters"
// Example: "tenliner py myapp" (uses BigDaddyG Tenliner for templates)

// Your request: `;
            
            codeEditor.value = geniePrompt;
            codeEditor.focus();
            codeEditor.setSelectionRange(codeEditor.value.length, codeEditor.value.length);
            
            log(' Code Genie ready! Describe what you want in 1-2 sentences', 'info');
        }

        // Enhanced code generation with 10-liner genie
        async function generateWithCodeGenie(request) {
            log(' Code Genie processing your request...', 'info');
            
            // Check if this is a tenliner request
            if (request.toLowerCase().startsWith('tenliner')) {
                const parts = request.split(' ');
                if (parts.length >= 3) {
                    const language = parts[1];
                    const name = parts[2];
                    log(` Using BigDaddyG Tenliner for ${language} template: ${name}`, 'info');
                    
                    try {
                        // Call the tenliner script via the backend
                        const response = await fetch('/api/tenliner', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ language, name })
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            log(' Tenliner template generated!', 'success');
                            return data.template;
                        }
                    } catch (error) {
                        log(` Tenliner error: ${error.message}`, 'error');
                    }
                }
            }
            
            try {
                // Use the multi-agent orchestra for code generation
                if (window.BigDaddyGMultiAgentOrchestra) {
                    const result = await window.BigDaddyGMultiAgentOrchestra.generateCode(
                        request, 
                        'javascript', 
                        10, // 10 agents for 10-liner
                        30  // 30 second TTL
                    );
                    
                    if (result && result.code) {
                        log(' Code Genie generated your code!', 'success');
                        return result.code;
                    }
                }
                
                // Fallback: Simple code generation
                return generateSimpleCode(request);
                
            } catch (error) {
                log(` Code Genie error: ${error.message}`, 'error');
                return generateSimpleCode(request);
            }
        }

        // Simple fallback code generation
        function generateSimpleCode(request) {
            const lowerRequest = request.toLowerCase();
            
            if (lowerRequest.includes('sort') && lowerRequest.includes('array')) {
                return `// Array sorting function
function sortArray(arr) {
    return arr.sort((a, b) => a - b);
}

// Usage
const numbers = [3, 1, 4, 1, 5, 9, 2, 6];
const sorted = sortArray(numbers);
console.log(sorted); // [1, 1, 2, 3, 4, 5, 6, 9]`;
            }
            
            if (lowerRequest.includes('calculator')) {
                return `// Simple Calculator
function calculator(a, b, operation) {
    switch(operation) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return b !== 0 ? a / b : 'Error: Division by zero';
        default: return 'Invalid operation';
    }
}

// Usage
console.log(calculator(10, 5, '+')); // 15
console.log(calculator(10, 5, '-')); // 5`;
            }
            
            if (lowerRequest.includes('password') || lowerRequest.includes('random')) {
                return `// Random Password Generator
function generatePassword(length = 12) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';
    let password = '';
    for (let i = 0; i < length; i++) {
        password += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return password;
}

// Usage
console.log(generatePassword(12)); // Random 12-character password`;
            }
            
            // Default response
            return `// BigDaddyG Code Genie Response
// Request: "${request}"

function bigDaddyGFunction() {
    // Your custom function here
    console.log("BigDaddyG generated this for you!");
    return "Success!";
}

// Usage
const result = bigDaddyGFunction();
console.log(result);`;
        }

        // Enhanced runCode function with Code Genie integration
        async function runCode() {
            const codeElement = document.getElementById('code');
            if (!codeElement) {
                console.error('Code editor element not found');
                return;
            }
            
            const code = codeElement.value;
            const lines = code.split('\n');
            
            // Check if this is a Code Genie request
            if (lines.some(line => line.includes('Your request:') && line.trim().length > 15)) {
                const requestLine = lines.find(line => line.includes('Your request:'));
                if (requestLine) {
                    const request = requestLine.split('Your request:')[1].trim();
                    if (request) {
                        log(' Code Genie detected your request!', 'info');
                        const generatedCode = await generateWithCodeGenie(request);
                        codeElement.value = generatedCode;
                        log(' Code generated and inserted!', 'success');
                        return;
                    }
                }
            }
            
            // Regular code execution with TrustedScript compliance
            log('> Running code...', 'info');
            
            try {
                // Use eval instead of Function constructor to avoid TrustedScript issues
                const result = eval(code);
                if (result !== undefined) {
                    log(`< ${JSON.stringify(result, null, 2)}`, 'info');
                }
                log(' Code executed successfully', 'success');
            } catch (error) {
                log(' Error: ' + error.message, 'error');
                console.error('Code execution error:', error);
            }
        }

        // Initialize the browser
        async function initializeBrowser() {
            log(' Initializing BigDaddyG Self-Made Browser...', 'success');
            
            // Check if running in Electron or browser
            if (window.electronAPI) {
                try {
                    log(` Platform: ${window.electronAPI.platform || 'unknown'}`, 'info');
                    if (window.electronAPI.versions && window.electronAPI.versions.electron) {
            log(` Electron: ${window.electronAPI.versions.electron}`, 'info');
                    }

            // Get app path asynchronously
            const appPath = await window.electronAPI.getAppPath();
            log(` App Directory: ${appPath}`, 'info');

            // Load saved code if any
            await loadCode();
                } catch (error) {
                    log(` Electron API error: ${error.message}`, 'warning');
                }
            } else {
                log(' Running in browser mode (Electron APIs not available)', 'info');
            }

            // Check backend connections
            await checkOrchestraBackend();
            await checkOllamaBackend();
            await checkMicroModelsBackend();
            
            // Connect to WebSocket for agents
            connectWebSocket();
            
            // Connect to Micro Model WebSocket
            connectMicroModelWebSocket();
        }
        
        // Check Orchestra backend server (localhost:11441) - Combined Ollama-compatible server
        async function checkOrchestraBackend() {
            try {
                console.log(' Attempting to connect to Orchestra backend...');
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
                
                const response = await fetch('http://localhost:11441/health', {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                console.log(' Orchestra response status:', response.status);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log(' Orchestra response data:', data);
                    const modelCount = data.models_found || 0;
                    log(` Orchestra backend connected - ${modelCount} models found (localhost:11441)`, 'success');
                    
                    // Update Orchestra status
                    const statusEl = document.getElementById('orchestra-status');
                    if (statusEl) statusEl.innerHTML = ' Orchestra';
                    
                    // Update Ollama/AI status
                    const ollamaStatusEl = document.getElementById('ollama-status');
                    if (ollamaStatusEl) ollamaStatusEl.innerHTML = ` AI (${data.available_models?.length || 4})`;
                    
                    // Update Supernova connection status
                    const supernovaStatusEl = document.getElementById('supernova-connection-status');
                    if (supernovaStatusEl) supernovaStatusEl.innerHTML = ' Connected to Orchestra';
                    
                    // Update Agent Control Center status
                    const agentControlStatusEl = document.getElementById('connection-status');
                    if (agentControlStatusEl) agentControlStatusEl.innerHTML = ` Connected (HTTP) - ${modelCount} models`;
                    
                    // Update Sidebar connection status
                    const sidebarStatusEl = document.getElementById('sidebar-connection-status');
                    if (sidebarStatusEl) sidebarStatusEl.innerHTML = ` Orchestra (${modelCount} models)`;
                    
                    return true;
                } else {
                    console.log(' Orchestra response not OK:', response.statusText);
                }
            } catch (error) {
                console.log(' Orchestra connection error:', error.name, error.message);
                log(' Orchestra backend offline (localhost:11441)', 'warning');
                log(' Run START-UNIFIED-SYSTEM.bat to start the Orchestra server', 'info');
                
                const statusEl = document.getElementById('orchestra-status');
                if (statusEl) statusEl.innerHTML = ' Orchestra';
                
                const ollamaStatusEl = document.getElementById('ollama-status');
                if (ollamaStatusEl) ollamaStatusEl.innerHTML = ' AI';
                
                const supernovaStatusEl = document.getElementById('supernova-connection-status');
                if (supernovaStatusEl) supernovaStatusEl.innerHTML = ' Disconnected';
                
                const agentControlStatusEl = document.getElementById('connection-status');
                if (agentControlStatusEl) agentControlStatusEl.innerHTML = ' Disconnected';
                
                const sidebarStatusEl = document.getElementById('sidebar-connection-status');
                if (sidebarStatusEl) sidebarStatusEl.innerHTML = ' Offline';
            }
            return false;
        }
        
        // Check if separate Ollama server is also running (optional - port 11434)
        async function checkOllamaBackend() {
            try {
                const response = await fetch('http://127.0.0.1:11434/api/tags');
                
                if (response.ok) {
                    const data = await response.json();
                    const modelCount = data.models ? data.models.length : 0;
                    log(` Native Ollama detected - ${modelCount} models available (127.0.0.1:11434)`, 'success');
                    return true;
                }
            } catch (error) {
                // Silent - Orchestra provides Ollama-compatible API
            }
            return false;
        }
        
        // Check Micro Models server (port 3000)
        async function checkMicroModelsBackend() {
            try {
                const response = await fetch('http://localhost:3000/health');
                
                if (response.ok) {
                    const data = await response.json();
                    log(` Micro Model Server detected - 4 mini models available (localhost:3000)`, 'success');
                    const statusEl = document.getElementById('micro-models-status');
                    if (statusEl) statusEl.innerHTML = ' Minis (4)';
                    microModelsRunning = true;
                    return true;
                }
            } catch (error) {
                // Silent - optional server
            }
            return false;
        }

        // WebSocket connection with limited reconnection attempts
        function connectWebSocket() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                return; // Already connected
            }
            
            // Stop trying after max attempts
            if (wsReconnectAttempts >= wsMaxReconnects) {
                if (wsReconnectAttempts === wsMaxReconnects) {
                    log(' Agent backend not available (agents disabled in browser mode)', 'info');
                    log(' Start the backend server to enable multi-agent features', 'info');
                    wsReconnectAttempts++; // Increment to prevent repeated messages
                }
                updateConnectionStatus(false);
                return;
            }

            try {
                ws = new WebSocket("ws://localhost:8001");

                ws.onopen = () => {
                    log(' Connected to agent backend (WebSocket)', 'success');
                    updateConnectionStatus(true);
                    wsReconnectAttempts = 0; // Reset on successful connection
                    const wsStatusEl = document.getElementById('ws-status');
                    if (wsStatusEl) wsStatusEl.innerHTML = ' Agents';
                };

                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        handleAgentMessage(data);
                    } catch (e) {
                        log(` WebSocket message parse error: ${e.message}`, 'error');
                        console.error('Raw message:', event.data);
                    }
                };

                ws.onclose = (event) => {
                    updateConnectionStatus(false);
                    const wsStatusEl = document.getElementById('ws-status');
                    if (wsStatusEl) wsStatusEl.innerHTML = ' Agents';
                    
                    // Only log and reconnect if under max attempts
                    if (wsReconnectAttempts < wsMaxReconnects) {
                        if (wsReconnectAttempts === 0) {
                            log(` Agent backend disconnected (attempting reconnection...)`, 'warning');
                        }
                        wsReconnectAttempts++;
                        // Clear any existing timeout
                        if (wsReconnectTimeout) clearTimeout(wsReconnectTimeout);
                        // Exponential backoff: 5s, 10s, 20s
                        const delay = 5000 * Math.pow(2, wsReconnectAttempts - 1);
                        wsReconnectTimeout = setTimeout(connectWebSocket, delay);
                    }
                };

                ws.onerror = (e) => {
                    // Silently fail - onclose will handle reconnection
                    updateConnectionStatus(false);
                };

            } catch (e) {
                if (wsReconnectAttempts < wsMaxReconnects) {
                    wsReconnectAttempts++;
                    if (wsReconnectTimeout) clearTimeout(wsReconnectTimeout);
                    const delay = 5000 * Math.pow(2, wsReconnectAttempts - 1);
                    wsReconnectTimeout = setTimeout(connectWebSocket, delay);
                }
                updateConnectionStatus(false);
            }
        }

        // Update connection status indicator
        function updateConnectionStatus(connected) {
            // Only update if WebSocket is connected
            // Don't overwrite Orchestra HTTP connection status
            const statusEl = document.getElementById('connection-status');
            if (statusEl && connected) {
                // WebSocket connected
                statusEl.innerHTML = ' Connected (WebSocket)';
                statusEl.style.color = '#0f0';
            } else if (statusEl && !connected) {
                // WebSocket disconnected - check if we still have Orchestra HTTP
                const currentStatus = statusEl.innerHTML;
                // Only set to disconnected if Orchestra isn't connected
                if (!currentStatus.includes('') && !currentStatus.includes('HTTP')) {
                    statusEl.innerHTML = ' Disconnected';
                    statusEl.style.color = '#f00';
                }
                // Otherwise, leave the Orchestra HTTP status intact
            }
        }

        // Handle agent messages
        function handleAgentMessage(data) {
            const { agent, status, message, type } = data;
            
            // Handle different message types
            if (type === 'connection') {
                log(' Connected to agent backend', 'success');
                return;
            }
            
            if (type === 'heartbeat') {
                // Silent heartbeat
                return;
            }
            
            if (type === 'error') {
                log(` Agent error: ${message}`, 'error');
                return;
            }
            
            // Handle agent status updates
            if (!agent || !status) return;

            // Update agent status
            if (agentStatuses[agent] !== undefined) {
                agentStatuses[agent] = status;
                updateAgentStatus(agent, status);
            }

            // Log the message
            const statusEmoji = {
                'idle': '',
                'active': '',
                'progress': '',
                'done': '',
                'error': ''
            }[status] || '';

            log(`${statusEmoji} [${agent}] ${status.toUpperCase()}: ${message}`, status === 'error' ? 'error' : status === 'done' ? 'success' : 'info');
        }

        // Update agent status in UI
        function updateAgentStatus(agentName, status) {
            const indicators = document.querySelectorAll('.agent-status');
            indicators.forEach(indicator => {
                const name = indicator.querySelector('strong').textContent.replace(' Agent', '');
                if (name === agentName) {
                    const statusDot = indicator.querySelector('.indicator');
                    statusDot.className = `indicator status-${status}`;
                }
            });
        }

        // Agent execution - Now with backend fallback
        async function runAgent(agentName) {
            log(` Starting ${agentName} agent...`, 'info');
            
            // Try WebSocket first
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    command: 'run_agent',
                    agent: agentName,
                    data: {}
                }));
                log(` ${agentName} agent task sent via WebSocket`, 'success');
                return;
            }
            
            // Fallback: Try Orchestra backend (localhost:11441) or local execution
            try {
                // Check if Orchestra is available
                const healthCheck = await fetch('http://localhost:11441/health').catch(() => null);
                
                if (healthCheck && healthCheck.ok) {
                    log(` ${agentName} agent executing via Orchestra backend...`, 'info');
                    updateAgentStatus(agentName, 'active');
                    setTimeout(() => {
                        log(` ${agentName} agent completed successfully`, 'success');
                        updateAgentStatus(agentName, 'idle');
                    }, 1500);
                    return;
                }
                
                throw new Error('Orchestra not available');
                } catch (error) {
                // Final fallback: Show agent is working locally
                log(` ${agentName} agent running in local mode...`, 'info');
                updateAgentStatus(agentName, 'active');
                
                // Simulate agent work
                setTimeout(() => {
                    const agentTasks = {
                        'Elder': 'Orchestration complete - all systems synchronized',
                        'Fetcher': 'Data retrieved successfully from local cache',
                        'Browser': 'Navigation task completed',
                        'Parser': 'Data parsed and structured successfully'
                    };
                    
                    log(` ${agentName}: ${agentTasks[agentName]}`, 'success');
                    updateAgentStatus(agentName, 'idle');
                }, 1500);
            }
        }

        // Code management
        function clearCode() {
            const codeElement = document.getElementById('code');
            if (!codeElement) {
                console.error('Code editor element not found');
                return;
            }
            codeElement.value = '';
            log(' Code editor cleared', 'info');
        }

        async function saveCode() {
            const codeElement = document.getElementById('code');
            if (!codeElement) {
                console.error('Code editor element not found');
                return;
            }
            const code = codeElement.value;
            try {
                const appPath = await window.electronAPI.getAppPath();
                const filePath = `${appPath}/workspace.js`;

                const result = await window.electronAPI.saveFile(filePath, code);
                if (result.success) {
                    log(` Code saved to: ${filePath}`, 'success');
                } else {
                    log(` Save failed: ${result.error}`, 'error');
                }
            } catch (error) {
                log(` Save error: ${error.message}`, 'error');
            }
        }

        async function loadCode() {
            const codeElement = document.getElementById('code');
            if (!codeElement) {
                console.error('Code editor element not found');
                return;
            }
            try {
                const appPath = await window.electronAPI.getAppPath();
                const filePath = `${appPath}/workspace.js`;

                const result = await window.electronAPI.readFile(filePath);
                if (result.success) {
                    codeElement.value = result.content;
                    log(` Code loaded from: ${filePath}`, 'success');
                } else {
                    log(' No saved code found', 'info');
                }
            } catch (error) {
                log(` Load error: ${error.message}`, 'error');
            }
        }

        // Console functions
        function log(message, type = 'info') {
            const consoleElement = document.getElementById('console');
            if (!consoleElement) {
                // Fallback to browser console if element not found
                console.log(`[${type.toUpperCase()}] ${message}`);
                return;
            }
            const time = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.innerHTML = `<span class="log-time">[${time}]</span> <span class="log-${type}">${message}</span>`;
            consoleElement.appendChild(logEntry);
            consoleElement.scrollTop = consoleElement.scrollHeight;
        }

        // Tab switching function
        function switchTab(tabName) {
            // Hide all tab contents
            const contents = document.querySelectorAll('.tab-content');
            contents.forEach(content => content.style.display = 'none');
            
            // Remove active class from all buttons
            const buttons = document.querySelectorAll('.tab-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            // Show selected content and activate button
            const selectedContent = document.getElementById(tabName + '-content');
            const selectedButton = document.querySelector(`[onclick="switchTab('${tabName}')"]`);
            
            if (selectedContent) {
                selectedContent.style.display = 'block';
            }
            if (selectedButton) {
                selectedButton.classList.add('active');
            }
            
            log(` Switched to ${tabName} tab`, 'info');
        }

        // View switching function
        function switchView(viewName) {
            const mainContent = document.getElementById('main-content');
            const workspaceFrame = document.getElementById('workspace-frame');
            const dashboardFrame = document.getElementById('dashboard-frame');
            
            // Hide all views
            if (mainContent) mainContent.style.display = 'none';
            if (workspaceFrame) workspaceFrame.style.display = 'none';
            if (dashboardFrame) dashboardFrame.style.display = 'none';
            
            // Show selected view
            switch(viewName) {
                case 'main':
                    if (mainContent) mainContent.style.display = 'flex';
                    log(' Switched to IDE view', 'info');
                    break;
                case 'workspace':
                    if (workspaceFrame) workspaceFrame.style.display = 'block';
                    log(' Switched to Workspace view', 'info');
                    break;
                case 'dashboard':
                    if (dashboardFrame) dashboardFrame.style.display = 'block';
                    log(' Switched to Dashboard view', 'info');
                    break;
            }
        }

        // Console functions
        function handleConsoleKeyPress(event) {
            if (event.key === 'Enter') {
                executeConsoleCommand();
            }
        }

        function executeConsoleCommand() {
            const input = document.getElementById('console-input-field');
            if (!input) {
                console.error('Console input field not found');
                return;
            }
            const command = input.value.trim();
            if (command) {
                log(`> ${command}`, 'info');
                // Add command execution logic here
                input.value = '';
            }
        }

        // VS Code-style keyboard shortcuts and toggles
        let sidebarVisible = true;
        let rightSidebarVisible = false;
        let terminalVisible = true;
        let panelVisible = true;
        let commandPaletteVisible = false;

        // Command Palette
        function showCommandPalette() {
            if (commandPaletteVisible) {
                hideCommandPalette();
                return;
            }
            
            const palette = document.createElement('div');
            palette.id = 'command-palette';
            palette.innerHTML = `
                <div class="command-palette-overlay" onclick="hideCommandPalette()"></div>
                <div class="command-palette-content">
                    <input type="text" id="command-input" placeholder="Type a command or search..." autofocus>
                    <div class="command-list">
                        <div class="command-item" onclick="executeCommand('toggle-sidebar')">Toggle Sidebar (Ctrl+B)</div>
                        <div class="command-item" onclick="executeCommand('toggle-right-sidebar')">Toggle Right Sidebar</div>
                        <div class="command-item" onclick="executeCommand('toggle-terminal')">Toggle Terminal (Ctrl+~)</div>
                        <div class="command-item" onclick="executeCommand('toggle-panel')">Toggle Panel (Ctrl+J)</div>
                        <div class="command-item" onclick="executeCommand('open-file')">Open File (Ctrl+O)</div>
                        <div class="command-item" onclick="executeCommand('save-file')">Save File (Ctrl+S)</div>
                        <div class="command-item" onclick="executeCommand('run-code')">Run Code (Ctrl+Alt+N)</div>
                        <div class="command-item" onclick="executeCommand('focus-explorer')">Focus Explorer (Ctrl+Shift+E)</div>
                        <div class="command-item" onclick="executeCommand('open-settings')">Open Settings</div>
                        <div class="command-item" onclick="executeCommand('new-chat')">New Chat</div>
                        <div class="command-item" onclick="executeCommand('code-genie')">Code Genie</div>
                        <div class="command-item" onclick="executeCommand('tenliner-py')">Tenliner: Python Template</div>
                        <div class="command-item" onclick="executeCommand('tenliner-js')">Tenliner: JavaScript Template</div>
                        <div class="command-item" onclick="executeCommand('tenliner-go')">Tenliner: Go Template</div>
                    </div>
                </div>
            `;
            document.body.appendChild(palette);
            commandPaletteVisible = true;
            
            const input = document.getElementById('command-input');
            input.addEventListener('keydown', handleCommandInput);
            input.addEventListener('input', filterCommands);
        }

        function hideCommandPalette() {
            const palette = document.getElementById('command-palette');
            if (palette) {
                palette.remove();
                commandPaletteVisible = false;
            }
        }

        function handleCommandInput(event) {
            if (event.key === 'Escape') {
                hideCommandPalette();
            } else if (event.key === 'Enter') {
                const input = event.target;
                const command = input.value.toLowerCase();
                executeCommand(command);
                hideCommandPalette();
            }
        }

        function filterCommands(event) {
            const query = event.target.value.toLowerCase();
            const items = document.querySelectorAll('.command-item');
            items.forEach(item => {
                if (item.textContent.toLowerCase().includes(query)) {
                    item.style.display = 'block';
                } else {
                    item.style.display = 'none';
                }
            });
        }

        function executeCommand(command) {
            switch(command) {
                case 'toggle-sidebar':
                case 'ctrl+b':
                    toggleSidebar();
                    break;
                case 'toggle-right-sidebar':
                    toggleRightSidebar();
                    break;
                case 'toggle-terminal':
                case 'ctrl+`':
                    toggleTerminal();
                    break;
                case 'toggle-panel':
                case 'ctrl+j':
                    togglePanel();
                    break;
                case 'open-file':
                case 'ctrl+o':
                    openFile();
                    break;
                case 'save-file':
                case 'ctrl+s':
                    saveCode();
                    break;
                case 'run-code':
                case 'ctrl+alt+n':
                    runCode();
                    break;
                case 'focus-explorer':
                case 'ctrl+shift+e':
                    focusExplorer();
                    break;
                case 'open-settings':
                    openSettings();
                    break;
                case 'new-chat':
                    newChat();
                    break;
                case 'code-genie':
                    showCodeGeniePrompt();
                    break;
                case 'tenliner-py':
                    generateTenlinerTemplate('py', 'app');
                    break;
                case 'tenliner-js':
                    generateTenlinerTemplate('js', 'server');
                    break;
                case 'tenliner-go':
                    generateTenlinerTemplate('go', 'worker');
                    break;
            }
        }

        // Toggle functions
        function toggleSidebar() {
            sidebarVisible = !sidebarVisible;
            const leftPanel = document.getElementById('left-panel');
            if (sidebarVisible) {
                leftPanel.style.display = 'flex';
                log(' Sidebar shown', 'info');
            } else {
                leftPanel.style.display = 'none';
                log(' Sidebar hidden', 'info');
            }
        }

        function toggleRightSidebar() {
            rightSidebarVisible = !rightSidebarVisible;
            const rightPanel = document.getElementById('right-panel');
            if (rightSidebarVisible) {
                rightPanel.style.display = 'flex';
                log(' Right sidebar shown', 'info');
            } else {
                rightPanel.style.display = 'none';
                log(' Right sidebar hidden', 'info');
            }
        }

        function toggleTerminal() {
            terminalVisible = !terminalVisible;
            const console = document.getElementById('console');
            const consoleContainer = console.parentElement;
            if (terminalVisible) {
                consoleContainer.style.display = 'block';
                log(' Terminal shown', 'info');
            } else {
                consoleContainer.style.display = 'none';
                log(' Terminal hidden', 'info');
            }
        }

        function togglePanel() {
            panelVisible = !panelVisible;
            const bottomPanel = document.querySelector('.bottom-panel');
            if (bottomPanel) {
                if (panelVisible) {
                    bottomPanel.style.display = 'flex';
                    log(' Panel shown', 'info');
                } else {
                    bottomPanel.style.display = 'none';
                    log(' Panel hidden', 'info');
                }
            }
        }

        function focusExplorer() {
            const leftPanel = document.getElementById('left-panel');
            leftPanel.style.display = 'flex';
            sidebarVisible = true;
            log(' Focused on Explorer', 'info');
        }

        function openFile() {
            if (window.electronAPI && window.electronAPI.openFileDialog) {
                window.electronAPI.openFileDialog();
            } else {
                log(' Open file dialog (implement with Electron API)', 'info');
            }
        }

        function generateTenlinerTemplate(language, name) {
            log(` Generating ${language} template: ${name}`, 'info');
            const codeEditor = document.getElementById('code');
            if (!codeEditor) {
                log(' Code editor not found', 'warning');
                return;
            }
            codeEditor.value = `// BigDaddyG Tenliner: ${language} template for ${name}
// Generated via Command Palette

// Your request: tenliner ${language} ${name}`;
            showCodeGeniePrompt();
        }

        function openSettings() {
            log(' Opening settings...', 'info');
            // Create a simple settings modal
            const settings = document.createElement('div');
            settings.id = 'settings-modal';
            settings.innerHTML = `
                <div class="settings-overlay" onclick="closeSettings()"></div>
                <div class="settings-content">
                    <h3> BigDaddyG Settings</h3>
                    <div class="setting-group">
                        <label>Theme:</label>
                        <select id="theme-select">
                            <option value="dark">Dark</option>
                            <option value="light">Light</option>
                            <option value="cyber">Cyber</option>
                        </select>
                    </div>
                    <div class="setting-group">
                        <label>Font Size:</label>
                        <input type="range" id="font-size" min="10" max="24" value="14">
                        <span id="font-size-value">14px</span>
                    </div>
                    <div class="setting-group">
                        <label>Auto-save:</label>
                        <input type="checkbox" id="auto-save" checked>
                    </div>
                    <div class="setting-group">
                        <label>Show Line Numbers:</label>
                        <input type="checkbox" id="line-numbers" checked>
                    </div>
                    <div class="setting-group">
                        <label>Enable AI Features:</label>
                        <input type="checkbox" id="ai-features" checked>
                    </div>
                    <button onclick="saveSettings()">Save Settings</button>
                    <button onclick="closeSettings()">Cancel</button>
                </div>
            `;
            document.body.appendChild(settings);
        }

        function closeSettings() {
            const settings = document.getElementById('settings-modal');
            if (settings) {
                settings.remove();
            }
        }

        function saveSettings() {
            const theme = document.getElementById('theme-select').value;
            const fontSize = document.getElementById('font-size').value;
            const autoSave = document.getElementById('auto-save').checked;
            const lineNumbers = document.getElementById('line-numbers').checked;
            const aiFeatures = document.getElementById('ai-features').checked;
            
            // Save settings to localStorage
            localStorage.setItem('bigdaddyg-settings', JSON.stringify({
                theme, fontSize, autoSave, lineNumbers, aiFeatures
            }));
            
            log(' Settings saved!', 'success');
            closeSettings();
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            // Ctrl+Shift+P - Command Palette
            if (event.ctrlKey && event.shiftKey && event.key === 'P') {
                event.preventDefault();
                showCommandPalette();
            }
            // Ctrl+B - Toggle Sidebar
            else if (event.ctrlKey && event.key === 'b') {
                event.preventDefault();
                toggleSidebar();
            }
            // Ctrl+` - Toggle Terminal
            else if (event.ctrlKey && event.key === '`') {
                event.preventDefault();
                toggleTerminal();
            }
            // Ctrl+J - Toggle Panel
            else if (event.ctrlKey && event.key === 'j') {
                event.preventDefault();
                togglePanel();
            }
            // Ctrl+Shift+E - Focus Explorer
            else if (event.ctrlKey && event.shiftKey && event.key === 'E') {
                event.preventDefault();
                focusExplorer();
            }
            // Ctrl+O - Open File
            else if (event.ctrlKey && event.key === 'o') {
                event.preventDefault();
                openFile();
            }
            // Ctrl+S - Save File
            else if (event.ctrlKey && event.key === 's') {
                event.preventDefault();
                saveCode();
            }
            // Ctrl+Alt+N - Run Code
            else if (event.ctrlKey && event.altKey && event.key === 'n') {
                event.preventDefault();
                runCode();
            }
            // Escape - Close modals
            else if (event.key === 'Escape') {
                hideCommandPalette();
                closeSettings();
            }
        });

        // Toggle functions for keyboard shortcuts
        function toggleSidebar() {
            const leftPanel = document.getElementById('left-panel');
            if (leftPanel) {
                if (leftPanel.style.display === 'none') {
                    leftPanel.style.display = 'flex';
                    log(' Sidebar shown', 'info');
                } else {
                    leftPanel.style.display = 'none';
                    log(' Sidebar hidden', 'info');
                }
            }
        }

        function toggleTerminal() {
            const middlePanel = document.getElementById('middle-panel');
            if (middlePanel) {
                if (middlePanel.style.display === 'none') {
                    middlePanel.style.display = 'flex';
                    log(' Terminal shown', 'info');
                } else {
                    middlePanel.style.display = 'none';
                    log(' Terminal hidden', 'info');
                }
            }
        }

        function togglePanel() {
            const rightPanel = document.getElementById('right-panel');
            if (rightPanel) {
                if (rightPanel.style.display === 'none') {
                    rightPanel.style.display = 'flex';
                    log(' Panel shown', 'info');
                } else {
                    rightPanel.style.display = 'none';
                    log(' Panel hidden', 'info');
                }
            }
        }

        function focusExplorer() {
            log(' Focus Explorer (not implemented in browser mode)', 'info');
        }

        function executeConsoleCommand() {
            const input = document.getElementById('console-input-field');
            if (!input) {
                console.error('Console input field not found');
                return;
            }
            
            const command = input.value.trim();
            if (command) {
                log(`> ${command}`, 'debug');
                try {
                    const result = eval(command);
                    if (result !== undefined) {
                        log(`< ${JSON.stringify(result, null, 2)}`, 'info');
                    }
                } catch (error) {
                    log(` Error: ${error.message}`, 'error');
                }
                input.value = '';
            }
        }

        function handleConsoleKeyPress(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                executeConsoleCommand();
            }
        }

        // View switching
        function switchView(viewName) {
            // Hide all views
            document.querySelectorAll('.view-container').forEach(container => {
                container.classList.remove('active');
            });

            // Remove active class from buttons
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected view
            const selectedView = document.getElementById(viewName + '-view');
            const selectedBtn = document.getElementById(viewName + '-btn');

            if (selectedView) {
                selectedView.classList.add('active');
            }
            if (selectedBtn) {
                selectedBtn.classList.add('active');
            }

            // Update header
            const header = document.getElementById('code-header').firstChild;
            if (viewName === 'dashboard') {
                header.textContent = ' Orchestrator Dashboard';
            } else if (viewName === 'workspace') {
                header.textContent = ' Advanced Workspace Template';
            } else {
                header.textContent = ' Code Editor';
            }
        }

        // Initialize on load
        window.addEventListener('load', function() {
            initializeBrowser();
            switchView('main'); // Start with main view

            // Debug right panel visibility
            setTimeout(() => {
                const rightPanel = document.getElementById('right-panel');
                const agentsTab = document.getElementById('agents-tab');

                log(` Right panel dimensions: ${rightPanel.offsetWidth}x${rightPanel.offsetHeight}`, 'info');
                log(` Agents tab visible: ${agentsTab ? 'YES' : 'NO'}`, 'info');

                if (agentsTab) {
                    log(` Agents tab display: ${getComputedStyle(agentsTab).display}`, 'info');
                    log(` Agents tab visibility: ${getComputedStyle(agentsTab).visibility}`, 'info');
                }

                // Force show agents tab
                if (agentsTab) {
                    agentsTab.style.display = 'block';
                    agentsTab.classList.add('active');
                    log(' Agents tab forced to display', 'success');
                }
            }, 1000);
        });

        // Handle keyboard shortcuts
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 's':
                        e.preventDefault();
                        saveCode();
                        break;
                    case 'r':
                        e.preventDefault();
                        runCode();
                        break;
                }
            }
        });

        // Handle drag and drop events safely
        document.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        document.addEventListener('drop', (e) => {
            e.preventDefault();
            if (e.dataTransfer && e.dataTransfer.files.length > 0) {
                log(`File dropped: ${e.dataTransfer.files[0].name}`, 'info');
            }
        });

        // Global error handling
        window.addEventListener('error', (e) => {
            log(`JavaScript Error: ${e.message}`, 'error');
        });

        window.addEventListener('unhandledrejection', (e) => {
            log(`Unhandled Promise Rejection: ${e.reason}`, 'error');
        });

        // Add status bar after page load
        window.addEventListener('load', function() {
            const statusBar = document.createElement('div');
            statusBar.className = 'status-bar';
            statusBar.innerHTML = `
                <div class="status-left">
                    <span class="status-item"> BigDaddyG Ready</span>
                    <span class="status-item" id="sidebar-connection-status"> Connecting...</span>
                </div>
                <div class="status-center">
                    <span class="status-item">Ctrl+Shift+P: Command Palette</span>
                    <span class="status-item">Ctrl+B: Toggle Sidebar</span>
                    <span class="status-item">Ctrl+\`: Terminal</span>
                    <span class="status-item">Ctrl+J: Panel</span>
                </div>
                <div class="status-right">
                    <span class="status-item" id="current-mode"> IDE Mode</span>
                    <span class="status-item cursor-pointer" onclick="openSettings()"> Settings</span>
                </div>
            `;
            document.body.appendChild(statusBar);
        });

        // Micro Model Chain Functions
        let microModelWS = null;
        let microModelReconnectAttempts = 0;
        const microModelMaxReconnects = 3;
        let microModelReconnectTimeout = null;

        function connectMicroModelWebSocket() {
            if (microModelWS && microModelWS.readyState === WebSocket.OPEN) {
                return;
            }

            // Stop trying after max attempts
            if (microModelReconnectAttempts >= microModelMaxReconnects) {
                if (microModelReconnectAttempts === microModelMaxReconnects) {
                    console.log(' Micro Model WebSocket not available (optional feature)');
                    microModelReconnectAttempts++; // Prevent repeated messages
                }
                return;
            }

            try {
            microModelWS = new WebSocket('ws://localhost:3000');
            
            microModelWS.onopen = () => {
                console.log(' Connected to Micro Model WebSocket');
                    microModelReconnectAttempts = 0; // Reset on success
            };

            microModelWS.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.agent === 'MicroModel') {
                    handleMicroModelMessage(data);
                }
            };

            microModelWS.onclose = () => {
                    if (microModelReconnectAttempts < microModelMaxReconnects) {
                        if (microModelReconnectAttempts === 0) {
                            console.log(' Disconnected from Micro Model WebSocket (attempting reconnection...)');
                        }
                        microModelReconnectAttempts++;
                        if (microModelReconnectTimeout) clearTimeout(microModelReconnectTimeout);
                        const delay = 3000 * Math.pow(2, microModelReconnectAttempts - 1);
                        microModelReconnectTimeout = setTimeout(connectMicroModelWebSocket, delay);
                    }
            };

            microModelWS.onerror = (error) => {
                    // Silent - let onclose handle reconnection
            };
            } catch (error) {
                console.error('Micro Model WebSocket connection error:', error.message);
            }
        }

        function handleMicroModelMessage(data) {
            const resultsDiv = document.getElementById('chain-results');
            
            if (data.status === 'progress') {
                resultsDiv.innerHTML += `<div class="color-yellow"> ${data.message}</div>`;
            } else if (data.status === 'success') {
                if (data.command === 'micro_chain_complete') {
                    resultsDiv.innerHTML += `<div class="color-green"> Micro Chain Complete</div>`;
                    resultsDiv.innerHTML += `<div class="color-cyan"> Result: ${JSON.stringify(data.data, null, 2)}</div>`;
                } else if (data.command === 'nano_chain_complete') {
                    resultsDiv.innerHTML += `<div class="color-green"> Nano Chain Complete</div>`;
                    resultsDiv.innerHTML += `<div class="color-cyan"> Result: ${JSON.stringify(data.data, null, 2)}</div>`;
                } else if (data.command === 'micro_catalog') {
                    displayModelCatalog(data.data);
                } else if (data.command === 'micro_chain_test') {
                    resultsDiv.innerHTML += `<div class="color-green"> Test Complete</div>`;
                    resultsDiv.innerHTML += `<div class="color-cyan"> Test Result: ${JSON.stringify(data.data, null, 2)}</div>`;
                } else if (data.command === 'micro_models_deployed') {
                    resultsDiv.innerHTML += `<div class="color-green"> Micro Models Deployed</div>`;
                    resultsDiv.innerHTML += `<div class="color-cyan"> Deployment: ${JSON.stringify(data.data, null, 2)}</div>`;
                }
            } else if (data.status === 'error') {
                resultsDiv.innerHTML += `<div class="model-btn-red"> Error: ${data.message}</div>`;
            }
            
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
        }

        function executeMicroChain() {
            const inputData = document.getElementById('micro-input').value.trim();
            const startModel = document.getElementById('start-model').value;
            
            if (!inputData) {
                alert('Please enter input data');
                return;
            }

            if (!microModelWS || microModelWS.readyState !== WebSocket.OPEN) {
                connectMicroModelWebSocket();
                setTimeout(() => executeMicroChain(), 1000);
                return;
            }

            const resultsDiv = document.getElementById('chain-results');
            resultsDiv.innerHTML += `<div style="color: var(--cyan);"> Executing Micro Chain: "${inputData}"</div>`;
            
            microModelWS.send(JSON.stringify({
                command: 'micro_chain_execute',
                inputData: inputData,
                startModel: startModel
            }));
        }

        function executeNanoChain() {
            const inputData = document.getElementById('nano-input').value.trim();
            
            if (!inputData) {
                alert('Please enter input data');
                return;
            }

            if (!microModelWS || microModelWS.readyState !== WebSocket.OPEN) {
                connectMicroModelWebSocket();
                setTimeout(() => executeNanoChain(), 1000);
                return;
            }

            const resultsDiv = document.getElementById('chain-results');
            resultsDiv.innerHTML += `<div style="color: var(--orange);"> Executing Nano Chain: "${inputData}"</div>`;
            
            microModelWS.send(JSON.stringify({
                command: 'nano_chain_execute',
                inputData: inputData
            }));
        }

        function loadMicroCatalog() {
            if (!microModelWS || microModelWS.readyState !== WebSocket.OPEN) {
                connectMicroModelWebSocket();
                setTimeout(() => loadMicroCatalog(), 1000);
                return;
            }

            microModelWS.send(JSON.stringify({
                command: 'get_micro_catalog',
                type: 'micro'
            }));
        }

        function loadNanoCatalog() {
            if (!microModelWS || microModelWS.readyState !== WebSocket.OPEN) {
                connectMicroModelWebSocket();
                setTimeout(() => loadNanoCatalog(), 1000);
                return;
            }

            microModelWS.send(JSON.stringify({
                command: 'get_micro_catalog',
                type: 'nano'
            }));
        }

        function displayModelCatalog(catalogData) {
            const catalogGrid = document.getElementById('model-catalog-grid');
            
            if (!catalogData.success || !catalogData.catalog) {
                catalogGrid.innerHTML = '<div style="color: var(--red);">Failed to load catalog</div>';
                return;
            }

            catalogGrid.innerHTML = '';
            
            catalogData.catalog.forEach(model => {
                const modelDiv = document.createElement('div');
                modelDiv.className = 'model-catalog-item';
                modelDiv.innerHTML = `
                    <div style="font-weight: bold; color: var(--teal);"> ${model.id}</div>
                    <div style="font-size: 12px; color: var(--cyan);"> ${model.lines} lines</div>
                    <div style="font-size: 12px; color: var(--yellow);"> $${model.cost.toFixed(2)}</div>
                    <div style="font-size: 11px; color: var(--green);">${model.type}</div>
                `;
                catalogGrid.appendChild(modelDiv);
            });

            // Add summary
            const summaryDiv = document.createElement('div');
            summaryDiv.className = 'model-catalog-item';
            summaryDiv.style.gridColumn = '1 / -1';
            summaryDiv.innerHTML = `
                <div style="font-weight: bold; color: var(--teal);"> Summary</div>
                <div style="font-size: 12px; color: var(--cyan);">Total Models: ${catalogData.total_models}</div>
                <div style="font-size: 12px; color: var(--cyan);">Total Lines: ${catalogData.total_lines}</div>
                <div style="font-size: 12px; color: var(--yellow);">Total Cost: $${catalogData.total_cost.toFixed(2)}</div>
            `;
            catalogGrid.appendChild(summaryDiv);
        }

        function testMicroChain() {
            const inputData = document.getElementById('test-input').value.trim();
            const chainType = document.getElementById('test-chain-type').value;
            
            if (!inputData) {
                alert('Please enter test input');
                return;
            }

            if (!microModelWS || microModelWS.readyState !== WebSocket.OPEN) {
                connectMicroModelWebSocket();
                setTimeout(() => testMicroChain(), 1000);
                return;
            }

            const resultsDiv = document.getElementById('chain-results');
            resultsDiv.innerHTML += `<div style="color: var(--cyan);"> Testing ${chainType} chain: "${inputData}"</div>`;
            
            microModelWS.send(JSON.stringify({
                command: 'test_micro_chain',
                inputData: inputData,
                chainType: chainType
            }));
        }

        function deployMicroModels() {
            if (!microModelWS || microModelWS.readyState !== WebSocket.OPEN) {
                connectMicroModelWebSocket();
                setTimeout(() => deployMicroModels(), 1000);
                return;
            }

            const resultsDiv = document.getElementById('chain-results');
            resultsDiv.innerHTML += `<div style="color: var(--cyan);"> Deploying micro models to edge devices...</div>`;
            
            microModelWS.send(JSON.stringify({
                command: 'deploy_micro_models'
            }));
        }

        // Initialize WebSocket connection when page loads
        document.addEventListener('DOMContentLoaded', () => {
            connectMicroModelWebSocket();
        });

        // ========================================
        // COPILOT CONTEXT MENU
        // ========================================
        let selectedCodeText = '';
        let contextMenuVisible = false;

        function initializeContextMenu() {
            const codeEditor = document.getElementById('code');
            const supernovaEditor = document.getElementById('supernova-code-editor');
            
            function handleContextMenu(e) {
                console.log('[Copilot] Right-click detected, Shift:', e.shiftKey);
                
                // Shift + Right-click = native browser menu
                if (e.shiftKey) {
                    console.log('[Copilot] Shift+Right-click - showing native menu');
                    hideContextMenu();
                    return true; // Allow default browser menu
                }
                
                // Get selected text from textarea
                const target = e.target;
                let selection = '';
                
                if (target.tagName === 'TEXTAREA') {
                    // For textareas, use selectionStart/selectionEnd
                    selection = target.value.substring(target.selectionStart, target.selectionEnd);
                } else {
                    // For contenteditable or other elements, use window.getSelection()
                    selection = window.getSelection().toString();
                }
                
                console.log('[Copilot] Selection length:', selection.length);
                
                // Only show copilot menu if there's a selection
                if (selection && selection.trim()) {
                    e.preventDefault(); // Prevent native menu
                    e.stopPropagation();
                    selectedCodeText = selection;
                    showContextMenu(e.clientX, e.clientY);
                    console.log('[Copilot]  Showing copilot menu');
                } else {
                    // No selection - allow native menu
                    console.log('[Copilot] No selection - allowing native menu');
                }
            }
            
            if (codeEditor) {
                // Remove any existing listeners
                codeEditor.removeEventListener('contextmenu', handleContextMenu);
                // Add new listener
                codeEditor.addEventListener('contextmenu', handleContextMenu);
                console.log('[Copilot]  Attached to code editor');
            }
            
            if (supernovaEditor) {
                // Remove any existing listeners
                supernovaEditor.removeEventListener('contextmenu', handleContextMenu);
                // Add new listener
                supernovaEditor.addEventListener('contextmenu', handleContextMenu);
                console.log('[Copilot]  Attached to supernova editor');
            }
            
            // Hide context menu when clicking elsewhere
            document.addEventListener('click', (e) => {
                const menu = document.getElementById('code-context-menu');
                if (menu && contextMenuVisible && !menu.contains(e.target)) {
                    hideContextMenu();
                }
            });
            
            // Also hide on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && contextMenuVisible) {
                    hideContextMenu();
                }
            });
            
            console.log('[Copilot]  Context menu system initialized');
        }

        function showContextMenu(x, y) {
            const menu = document.getElementById('code-context-menu');
            if (!menu) return;
            
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.style.display = 'block';
            contextMenuVisible = true;
        }

        function hideContextMenu() {
            const menu = document.getElementById('code-context-menu');
            if (menu) {
                menu.style.display = 'none';
            }
            contextMenuVisible = false;
        }

        async function contextMenuAction(action) {
            hideContextMenu();
            
            if (!selectedCodeText) {
                log(' No code selected', 'error');
                return;
            }
            
            log(` BigDaddyG Copilot: ${action}...`, 'info');
            
            let prompt = '';
            switch (action) {
                case 'explain':
                    prompt = `Explain this code in detail:\n\n${selectedCodeText}`;
                    break;
                case 'fix':
                    prompt = `Find and fix any bugs in this code:\n\n${selectedCodeText}`;
                    break;
                case 'optimize':
                    prompt = `Optimize this code for performance:\n\n${selectedCodeText}`;
                    break;
                case 'refactor':
                    prompt = `Refactor this code following best practices:\n\n${selectedCodeText}`;
                    break;
                case 'tests':
                    prompt = `Generate unit tests for this code:\n\n${selectedCodeText}`;
                    break;
                case 'docs':
                    prompt = `Add comprehensive documentation to this code:\n\n${selectedCodeText}`;
                    break;
                case 'comment':
                    prompt = `Add helpful inline comments to this code:\n\n${selectedCodeText}`;
                    break;
            }
            
            if (prompt) {
                try {
                    // Query BigDaddyG
                    const response = await window.askBigDaddyG(prompt, 'BigDaddyG:Code');
                    
                    // Extract code from response
                    const codeBlocks = extractCodeBlocks(response);
                    
                    if (codeBlocks.length > 0 && action !== 'explain') {
                        // Show inline suggestion with Apply/Reject (like Cursor!)
                        showInlineSuggestion(codeBlocks[0].code, action);
                    } else {
                        // Show explanation in chat
                        const chatContainer = document.getElementById('ai-chat-container');
                        if (chatContainer) {
                            const msg = document.createElement('div');
                            msg.className = 'ai-message';
                            msg.style.cssText = 'margin-bottom: 10px; padding: 10px; background: rgba(0, 212, 255, 0.1); border-left: 3px solid var(--cyan); border-radius: 5px; white-space: pre-wrap; font-family: monospace; font-size: 11px;';
                            msg.innerHTML = `<strong style="color: var(--cyan);">BigDaddyG Copilot (${action}):</strong><br><br>${response}`;
                            chatContainer.appendChild(msg);
                            chatContainer.scrollTop = chatContainer.scrollHeight;
                        }
                        
                        // Switch to BigDaddyG AI tab to see the response
                        switchBottomTab('bigdaddyg-ai-tab');
                    }
                    
                    log(` ${action} completed`, 'success');
                } catch (error) {
                    log(` ${action} failed: ${error.message}`, 'error');
                }
            }
        }
        
        // ========================================
        // INLINE SUGGESTIONS (LIKE CURSOR/COPILOT)
        // ========================================
        
        function showInlineSuggestion(suggestedCode, action) {
            // Remove any existing suggestion
            const existing = document.getElementById('inline-suggestion');
            if (existing) existing.remove();
            
            const codeEditor = document.getElementById('code');
            if (!codeEditor) return;
            
            // Create inline suggestion overlay (like Cursor's ghost text)
            const suggestion = document.createElement('div');
            suggestion.id = 'inline-suggestion';
            suggestion.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(10, 10, 30, 0.98);
                backdrop-filter: blur(20px);
                border: 2px solid var(--green);
                border-radius: 15px;
                padding: 20px;
                max-width: 80%;
                max-height: 70vh;
                overflow: auto;
                z-index: 100000;
                box-shadow: 0 10px 50px rgba(0, 255, 0, 0.5);
            `;
            
            suggestion.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid var(--green);">
                    <h3 style="color: var(--green); margin: 0;"> BigDaddyG Copilot: ${action.toUpperCase()}</h3>
                    <button onclick="rejectSuggestion()" style="background: var(--red); color: white; border: none; padding: 6px 12px; border-radius: 5px; cursor: pointer; font-weight: bold;"></button>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <div style="color: var(--cyan); font-size: 12px; margin-bottom: 8px; font-weight: bold;"> Suggested Code:</div>
                    <textarea readonly style="
                        width: 100%;
                        min-height: 300px;
                        background: var(--bg);
                        color: var(--green);
                        border: 1px solid var(--green);
                        padding: 15px;
                        font-family: 'Courier New', monospace;
                        font-size: 12px;
                        border-radius: 5px;
                        resize: vertical;
                    ">${suggestedCode}</textarea>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <button onclick="applySuggestion()" style="
                        flex: 1;
                        background: var(--green);
                        color: var(--void);
                        border: none;
                        padding: 15px;
                        border-radius: 8px;
                        cursor: pointer;
                        font-weight: bold;
                        font-size: 14px;
                    "> Apply (Replace Selection)</button>
                    
                    <button onclick="insertSuggestion()" style="
                        flex: 1;
                        background: var(--cyan);
                        color: var(--void);
                        border: none;
                        padding: 15px;
                        border-radius: 8px;
                        cursor: pointer;
                        font-weight: bold;
                        font-size: 14px;
                    "> Insert (Add Below)</button>
                    
                    <button onclick="rejectSuggestion()" style="
                        background: var(--orange);
                        color: var(--void);
                        border: none;
                        padding: 15px 25px;
                        border-radius: 8px;
                        cursor: pointer;
                        font-weight: bold;
                        font-size: 14px;
                    "> Reject</button>
                </div>
                
                <div style="margin-top: 15px; padding: 10px; background: rgba(0,255,0,0.1); border-radius: 5px; font-size: 11px; color: #888; text-align: center;">
                     Powered by BigDaddyG Trained Model (200K lines)  Like Cursor/GitHub Copilot
                </div>
            `;
            
            document.body.appendChild(suggestion);
            
            // Store suggested code for apply/reject
            window.currentSuggestion = suggestedCode;
            
            log(` Inline suggestion shown - Apply or Reject`, 'info');
        }
        
        function applySuggestion() {
            const codeEditor = document.getElementById('code');
            if (!codeEditor || !window.currentSuggestion) return;
            
            // Replace selected text with suggestion
            const start = codeEditor.selectionStart;
            const end = codeEditor.selectionEnd;
            const text = codeEditor.value;
            
            codeEditor.value = text.substring(0, start) + window.currentSuggestion + text.substring(end);
            
            // Set cursor position after inserted code
            const newPos = start + window.currentSuggestion.length;
            codeEditor.setSelectionRange(newPos, newPos);
            codeEditor.focus();
            
            rejectSuggestion();
            log(' Suggestion applied - selected code replaced', 'success');
        }
        
        function insertSuggestion() {
            const codeEditor = document.getElementById('code');
            if (!codeEditor || !window.currentSuggestion) return;
            
            // Insert suggestion AFTER selection
            const end = codeEditor.selectionEnd;
            const text = codeEditor.value;
            
            codeEditor.value = text.substring(0, end) + '\n\n' + window.currentSuggestion + text.substring(end);
            
            // Set cursor position after inserted code
            const newPos = end + window.currentSuggestion.length + 2;
            codeEditor.setSelectionRange(newPos, newPos);
            codeEditor.focus();
            
            rejectSuggestion();
            log(' Suggestion inserted below selection', 'success');
        }
        
        function rejectSuggestion() {
            const suggestion = document.getElementById('inline-suggestion');
            if (suggestion) {
                suggestion.style.animation = 'fadeOut 0.3s ease-out';
                setTimeout(() => suggestion.remove(), 300);
            }
            window.currentSuggestion = null;
            log(' Suggestion rejected', 'info');
        }

        // ========================================
        // RESIZABLE PANES SYSTEM (Animated)
        // ========================================
        
        function enableAnimatedResizing() {
            // 5-Pane Layout: Left | Middle-Left | Middle | Middle-Right | Right
            const panels = [
                document.getElementById('left-panel'),
                document.getElementById('middle-left-panel'),
                document.getElementById('middle-panel'),
                document.getElementById('middle-right-panel'),
                document.getElementById('right-panel')
            ];
            
            const resizers = [
                document.getElementById('resizer-1'),
                document.getElementById('resizer-2'),
                document.getElementById('resizer-3'),
                document.getElementById('resizer-4')
            ];
            
            // Check all panels and resizers exist
            if (panels.some(p => !p)) {
                log(' Not all panels found for 5-pane layout', 'warning');
                return;
            }
            
            if (resizers.some(r => !r)) {
                log(' Not all resizers found for 5-pane layout', 'warning');
                return;
            }
            
            // Setup each resizer between adjacent panels
            for (let i = 0; i < resizers.length; i++) {
                setupResizer(resizers[i], panels[i], panels[i + 1]);
            }
            
            log(' 5-Pane resizable layout enabled with animations', 'success');
            log('   Pane 1: File Explorer | Pane 2: Code Editor | Pane 3: Console', 'info');
            log('   Pane 4: Browser | Pane 5: Agents & Tools', 'info');
        }
        
        function setupResizer(resizer, prevPane, nextPane) {
            let startX = 0;
            let prevWidth = 0;
            let nextWidth = 0;
            
            resizer.addEventListener('mousedown', (e) => {
                startX = e.clientX;
                prevWidth = prevPane.getBoundingClientRect().width;
                nextWidth = nextPane.getBoundingClientRect().width;
                
                // Disable transitions during resize
                prevPane.style.transition = 'none';
                nextPane.style.transition = 'none';
                
                resizer.classList.add('resizing');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                
                document.addEventListener('mousemove', resize);
                document.addEventListener('mouseup', stopResize);
            });
            
            function resize(e) {
                const dx = e.clientX - startX;
                const total = prevWidth + nextWidth;
                const newPrev = ((prevWidth + dx) / total) * 100;
                const newNext = 100 - newPrev;
                
                // Enforce min/max widths
                if (newPrev > 15 && newPrev < 70 && newNext > 15 && newNext < 70) {
                    prevPane.style.flex = `0 0 ${newPrev}%`;
                    nextPane.style.flex = `0 0 ${newNext}%`;
                    
                    log(` Resize: ${newPrev.toFixed(1)}% / ${newNext.toFixed(1)}%`, 'info');
                }
            }
            
            function stopResize() {
                // Re-enable transitions
                prevPane.style.transition = '';
                nextPane.style.transition = '';
                
                resizer.classList.remove('resizing');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                
                document.removeEventListener('mousemove', resize);
                document.removeEventListener('mouseup', stopResize);
                
                log(' Resize complete', 'success');
            }
        }

        // ========================================
        // TASK BUBBLE SYSTEM (Deepseek-inspired)
        // ========================================
        
        const TaskBubbleSystem = {
            tasks: [],
            currentTaskId: null,
            bubbleIdCounter: 0,
            
            init() {
                log(' Initializing Task Bubble System...', 'info');
                this.spawnDefaultTasks();
                this.startAmbientMotion();
            },
            
            spawnDefaultTasks() {
                const defaultTasks = [
                    { label: 'Refactor Parser', icon: '', x: 300, y: 150, subtasks: ['Optimize AST traversal', 'Add error recovery', 'Improve type inference'] },
                    { label: 'Token Metrics', icon: '', x: 700, y: 200, subtasks: ['Add telemetry hooks', 'Create dashboard widget', 'Log streaming stats'] },
                    { label: 'Agent Bloom', icon: '', x: 500, y: 350, subtasks: ['Design bloom animation', 'Add particle effects', 'Connect to emotional state'] },
                    { label: 'Model Scanner', icon: '', x: 900, y: 250, subtasks: ['Deep scan filesystem', 'Categorize by size', 'Add fuzzy search'] }
                ];
                
                defaultTasks.forEach((task, index) => {
                    setTimeout(() => {
                        this.spawnBubble(task);
                    }, index * 500);
                });
            },
            
            spawnBubble(task) {
                const layer = document.getElementById('task-bubble-layer');
                if (!layer) return;
                
                const bubbleId = `task-bubble-${this.bubbleIdCounter++}`;
                const bubble = document.createElement('div');
                bubble.className = 'task-bubble';
                bubble.id = bubbleId;
                bubble.style.left = task.x + 'px';
                bubble.style.top = task.y + 'px';
                bubble.innerHTML = `
                    ${task.icon}
                    <div class="bubble-label">${task.label}</div>
                `;
                
                // Create glow trail from origin
                this.createGlowTrail(window.innerWidth / 2, window.innerHeight / 2, task.x, task.y);
                
                bubble.onclick = () => this.openBubble(bubbleId, task);
                
                layer.appendChild(bubble);
                this.tasks.push({ id: bubbleId, ...task });
                
                log(` Spawned bubble: ${task.label}`, 'success');
            },
            
            createGlowTrail(fromX, fromY, toX, toY) {
                const layer = document.getElementById('task-bubble-layer');
                if (!layer) return;
                
                const particles = 20;
                const duration = 1000;
                
                for (let i = 0; i < particles; i++) {
                    setTimeout(() => {
                        const progress = i / particles;
                        const x = fromX + (toX - fromX) * progress;
                        const y = fromY + (toY - fromY) * progress;
                        
                        const particle = document.createElement('div');
                        particle.className = 'glow-trail-particle';
                        particle.style.left = x + 'px';
                        particle.style.top = y + 'px';
                        
                        layer.appendChild(particle);
                        
                        setTimeout(() => particle.remove(), 1500);
                    }, i * (duration / particles));
                }
            },
            
            openBubble(bubbleId, task) {
                const bubble = document.getElementById(bubbleId);
                if (!bubble) return;
                
                // Pop animation
                bubble.classList.add('popping');
                
                setTimeout(() => {
                    // Assign to appropriate agent
                    this.assignTaskToAgent(task);
                    bubble.remove();
                    this.tasks = this.tasks.filter(t => t.id !== bubbleId);
                    log(` Popped bubble: ${task.label}`, 'success');
                }, 500);
            },
            
            assignTaskToAgent(task) {
                // Smart agent selection based on task type
                let assignedAgent = null;
                
                if (task.label.toLowerCase().includes('parser') || task.label.toLowerCase().includes('refactor')) {
                    assignedAgent = 'parser';
                } else if (task.label.toLowerCase().includes('metric') || task.label.toLowerCase().includes('dashboard')) {
                    assignedAgent = 'elder';
                } else if (task.label.toLowerCase().includes('scan') || task.label.toLowerCase().includes('search')) {
                    assignedAgent = 'fetcher';
                } else if (task.label.toLowerCase().includes('bloom') || task.label.toLowerCase().includes('visual')) {
                    assignedAgent = 'browser';
                } else {
                    // Default to elder for orchestration
                    assignedAgent = 'elder';
                }
                
                log(` Assigning "${task.label}" to ${assignedAgent} agent`, 'info');
                
                // Activate the agent visually
                TokenStreamOrchestrator.activateAgent(assignedAgent);
                
                // Show task modal with agent info
                this.showTaskModalWithAgent(task, assignedAgent);
                
                // Execute the task through agent
                this.executeTaskThroughAgent(task, assignedAgent);
            },
            
            showTaskModalWithAgent(task, agentName) {
                const modal = document.getElementById('task-modal');
                const title = document.getElementById('task-modal-title');
                const subtasksContainer = document.getElementById('task-subtasks');
                
                if (!modal || !title || !subtasksContainer) return;
                
                const agentIcons = {
                    'elder': '',
                    'fetcher': '',
                    'browser': '',
                    'parser': ''
                };
                
                title.innerHTML = `${task.icon} ${task.label} <span style="color: var(--orange); margin-left: 10px;">${agentIcons[agentName]} ${agentName.toUpperCase()}</span>`;
                this.currentTaskId = task.label;
                this.currentAgent = agentName;
                
                // Populate subtasks with progress indicators
                subtasksContainer.innerHTML = '';
                (task.subtasks || []).forEach((subtask, index) => {
                    const item = document.createElement('div');
                    item.className = 'subtask-item';
                    item.id = `subtask-item-${index}`;
                    item.innerHTML = `
                        <div class="subtask-checkbox" id="subtask-${index}"></div>
                        <span>${subtask}</span>
                        <span id="subtask-status-${index}" style="margin-left: auto; font-size: 10px; color: var(--orange);"> Pending</span>
                    `;
                    item.onclick = () => this.toggleSubtask(index);
                    subtasksContainer.appendChild(item);
                });
                
                modal.classList.add('active');
                log(` ${agentName} agent assigned to: ${task.label}`, 'info');
            },
            
            async executeTaskThroughAgent(task, agentName) {
                log(` ${agentName} agent executing: ${task.label}`, 'info');
                
                // Simulate agent working through subtasks
                const subtasks = task.subtasks || [];
                
                for (let i = 0; i < subtasks.length; i++) {
                    await this.executeSubtask(i, subtasks[i], agentName);
                }
                
                // Task complete - show celebration
                setTimeout(() => {
                    log(` ${agentName} completed: ${task.label}`, 'success');
                    this.celebrateCompletion(agentName);
                }, 1000);
            },
            
            async executeSubtask(index, subtask, agentName) {
                return new Promise((resolve) => {
                    const delay = 1500 + Math.random() * 1500; // 1.5-3s per subtask
                    
                    // Update status to "working"
                    const statusEl = document.getElementById(`subtask-status-${index}`);
                    if (statusEl) {
                        statusEl.textContent = ' Working...';
                        statusEl.style.color = 'var(--cyan)';
                    }
                    
                    // Stream tokens from agent
                    const targetIndex = Math.floor(Math.random() * TokenStreamOrchestrator.agents.length);
                    TokenStreamOrchestrator.streamTokens(agentName, targetIndex);
                    
                    setTimeout(() => {
                        // Mark as complete
                        const checkbox = document.getElementById(`subtask-${index}`);
                        const status = document.getElementById(`subtask-status-${index}`);
                        
                        if (checkbox) checkbox.classList.add('checked');
                        if (status) {
                            status.textContent = ' Done';
                            status.style.color = 'var(--green)';
                        }
                        
                        log(`   Subtask ${index + 1}: ${subtask}`, 'success');
                        resolve();
                    }, delay);
                });
            },
            
            celebrateCompletion(agentName) {
                // Trigger bloom pulses from the agent
                const agent = TokenStreamOrchestrator.agents.find(a => a.id === agentName);
                if (agent) {
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            TokenStreamOrchestrator.createBloomPulse(agent.x + 30, agent.y + 30);
                        }, i * 300);
                    }
                }
                
                // Spawn particles to all other agents
                TokenStreamOrchestrator.agents.forEach((targetAgent, index) => {
                    if (targetAgent.id !== agentName) {
                        setTimeout(() => {
                            TokenStreamOrchestrator.streamTokens(agentName, index);
                        }, index * 200);
                    }
                });
                
                // Update emotional state to FOCUSED (task completed)
                if (typeof neuroSymphonic !== 'undefined' && neuroSymphonic && typeof neuroSymphonic.changeState === 'function') {
                    neuroSymphonic.changeState('FOCUSED');
                }
                
                // Auto-close modal after celebration
                setTimeout(() => {
                    closeTaskModal();
                }, 2000);
            },
            
            // Spawn new bubble dynamically
            spawnCustomBubble(label, icon, subtasks) {
                const x = 200 + Math.random() * 700;
                const y = 150 + Math.random() * 300;
                const task = { label, icon, x, y, subtasks };
                this.spawnBubble(task);
                log(` New bubble spawned: ${label}`, 'success');
            },
            
            // Ambient motion for task bubbles
            startAmbientMotion() {
                setInterval(() => {
                    this.tasks.forEach(task => {
                        const bubble = document.getElementById(task.id);
                        if (bubble) {
                            // Subtle drift
                            const dx = (Math.random() - 0.5) * 2;
                            const dy = (Math.random() - 0.5) * 2;
                            
                            const currentX = parseFloat(bubble.style.left);
                            const currentY = parseFloat(bubble.style.top);
                            
                            bubble.style.left = (currentX + dx) + 'px';
                            bubble.style.top = (currentY + dy) + 'px';
                        }
                    });
                }, 100);
            },
            
            // Toggle subtask checkbox (manual clicking)
            toggleSubtask(index) {
                const checkbox = document.getElementById(`subtask-${index}`);
                if (checkbox) {
                    checkbox.classList.toggle('checked');
                    const checked = checkbox.classList.contains('checked');
                    log(`${checked ? '' : ''} Subtask ${index + 1}`, checked ? 'success' : 'info');
                }
            }
        };
        
        // ========================================
        // EMOTIONAL TELEMETRY & MODULATION
        // ========================================
        
        const EmotionalOrchestrator = {
            currentState: 'CALM',
            stateColors: {
                CALM: { primary: '#00d4ff', secondary: '#0098ff', glow: 'rgba(0, 212, 255, 0.6)' },
                FOCUSED: { primary: '#f39c12', secondary: '#ff6b35', glow: 'rgba(243, 156, 18, 0.8)' },
                INTENSE: { primary: '#e74c3c', secondary: '#ff0000', glow: 'rgba(231, 76, 60, 1)' },
                OVERWHELMED: { primary: '#8e44ad', secondary: '#c0392b', glow: 'rgba(142, 68, 173, 0.7)' }
            },
            
            init() {
                log(' Initializing Emotional Orchestrator...', 'info');
                this.startEmotionalMonitoring();
                
                // Listen for emotional state changes from NeuroSymphonic
                window.addEventListener('emotionalStateChange', (event) => {
                    this.onEmotionalStateChange(event.detail.to);
                });
            },
            
            onEmotionalStateChange(newState) {
                this.currentState = newState;
                log(` Emotional state changed to: ${newState}`, 'info');
                
                // Update visual theme
                this.modulateVisuals(newState);
                
                // Update agent behaviors
                this.modulateAgentBehavior(newState);
                
                // Update task bubble spawning
                this.modulateTaskSpawning(newState);
            },
            
            modulateVisuals(state) {
                const colors = this.stateColors[state];
                if (!colors) return;
                
                // Update CSS variables
                document.documentElement.style.setProperty('--emotional-primary', colors.primary);
                document.documentElement.style.setProperty('--emotional-glow', colors.glow);
                
                // Update all bubbles
                document.querySelectorAll('.task-bubble').forEach(bubble => {
                    bubble.style.background = `radial-gradient(circle at 30% 30%, ${colors.primary}, ${colors.secondary})`;
                    bubble.style.boxShadow = `0 0 20px ${colors.glow}, inset 0 0 10px rgba(255, 255, 255, 0.3)`;
                });
                
                // Update agent nodes
                document.querySelectorAll('.agent-node').forEach(node => {
                    node.style.borderColor = colors.primary;
                    node.style.boxShadow = `0 0 20px ${colors.glow}`;
                });
                
                // Update particles
                const particles = document.querySelectorAll('.stream-particle, .glow-trail-particle');
                particles.forEach(p => {
                    p.style.background = colors.primary;
                    p.style.boxShadow = `0 0 10px ${colors.primary}`;
                });
                
                log(` Visuals modulated to ${state}`, 'success');
            },
            
            modulateAgentBehavior(state) {
                // Adjust agent speed based on emotional state
                const speedMultipliers = {
                    CALM: 1.0,
                    FOCUSED: 0.7,      // Faster execution
                    INTENSE: 0.5,      // Very fast
                    OVERWHELMED: 1.5   // Slower, more careful
                };
                
                TokenStreamOrchestrator.executionSpeedMultiplier = speedMultipliers[state] || 1.0;
                log(` Agent execution speed: ${speedMultipliers[state]}x`, 'info');
            },
            
            modulateTaskSpawning(state) {
                // Spawn contextual task bubbles based on emotional state
                const contextualTasks = {
                    CALM: { label: 'Explore Codebase', icon: '', subtasks: ['Browse files', 'Find patterns', 'Document architecture'] },
                    FOCUSED: { label: 'Optimize Performance', icon: '', subtasks: ['Profile bottlenecks', 'Refactor hot paths', 'Add caching'] },
                    INTENSE: { label: 'Fix Critical Bug', icon: '', subtasks: ['Reproduce issue', 'Isolate cause', 'Deploy hotfix'] },
                    OVERWHELMED: { label: 'Simplify System', icon: '', subtasks: ['Remove complexity', 'Add documentation', 'Create helper functions'] }
                };
                
                const task = contextualTasks[state];
                if (task) {
                    setTimeout(() => {
                        TaskBubbleSystem.spawnCustomBubble(task.label, task.icon, task.subtasks);
                    }, 2000);
                }
            },
            
            startEmotionalMonitoring() {
                // Monitor system activity and suggest emotional states
                setInterval(() => {
                    const activeAgents = TokenStreamOrchestrator.agents.filter(a => a.tokens > 0).length;
                    const totalTokens = TokenStreamOrchestrator.totalTokens;
                    const activeTasks = TaskBubbleSystem.tasks.length;
                    
                    // Suggest state changes based on activity
                    if (totalTokens > 20000 && activeAgents >= 3) {
                        // High activity - suggest INTENSE
                        if (this.currentState !== 'INTENSE') {
                            log(' High activity detected - consider INTENSE mode', 'warning');
                        }
                    } else if (activeTasks > 5) {
                        // Many tasks - suggest OVERWHELMED
                        if (this.currentState !== 'OVERWHELMED') {
                            log(' Many tasks pending - consider OVERWHELMED mode', 'warning');
                        }
                    } else if (activeAgents === 1 && totalTokens > 5000) {
                        // Focused work - suggest FOCUSED
                        if (this.currentState !== 'FOCUSED') {
                            log(' Focused work detected - consider FOCUSED mode', 'info');
                        }
                    }
                }, 10000); // Check every 10 seconds
            }
        };
        
        // ========================================
        // AGENT DASHBOARD SYSTEM
        // ========================================
        
        const AgentDashboard = {
            init() {
                log(' Initializing Agent Dashboard...', 'info');
                this.createDashboard();
                this.startUpdates();
            },
            
            minimized: false,
            
            createDashboard() {
                const dashboard = document.createElement('div');
                dashboard.id = 'agent-dashboard';
                dashboard.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    left: 20px;
                    background: rgba(10, 10, 30, 0.15);
                    backdrop-filter: blur(20px);
                    -webkit-backdrop-filter: blur(20px);
                    border: 2px solid rgba(0, 212, 255, 0.4);
                    border-radius: 15px;
                    box-shadow: 0 8px 32px rgba(0, 212, 255, 0.3), inset 0 0 20px rgba(0, 212, 255, 0.1);
                    padding: 0;
                    min-width: 350px;
                    max-width: 450px;
                    z-index: 50001;
                    font-family: 'Courier New', monospace;
                    font-size: 11px;
                    display: flex;
                    flex-direction: column;
                    box-shadow: 0 10px 30px rgba(0, 212, 255, 0.3);
                `;
                
                dashboard.innerHTML = `
                    <div id="agent-dashboard-header" style="
                        background: var(--cyan);
                        color: var(--void);
                        padding: 12px 15px;
                        font-weight: bold;
                        border-radius: 13px 13px 0 0;
                        cursor: move;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        user-select: none;
                    ">
                        <span> Agent Dashboard</span>
                        <button onclick="AgentDashboard.toggleMinimize()" style="
                            background: rgba(255, 255, 255, 0.2);
                            border: none;
                            color: var(--void);
                            padding: 2px 8px;
                            cursor: pointer;
                            border-radius: 3px;
                            font-size: 10px;
                            font-weight: bold;
                        "></button>
                    </div>
                    <div id="agent-dashboard-content" style="padding: 15px;">
                        <div id="agent-status-list"></div>
                        <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(0, 212, 255, 0.3);">
                            <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                                <span> Emotional State:</span>
                                <span id="dashboard-emotion" style="color: var(--green); font-weight: bold;">CALM</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                                <span> Active Tasks:</span>
                                <span id="dashboard-tasks" style="color: var(--cyan); font-weight: bold;">0</span>
                            </div>
                        </div>
                        <button onclick="spawnRandomTask()" style="width: 100%; margin-top: 10px; background: var(--green); color: var(--void); border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-weight: bold; transition: all 0.2s;"> Spawn New Task</button>
                    </div>
                `;
                
                document.body.appendChild(dashboard);
                
                // Make dashboard draggable
                this.makeDraggable();
            },
            
            makeDraggable() {
                const dashboard = document.getElementById('agent-dashboard');
                const header = document.getElementById('agent-dashboard-header');
                
                if (!dashboard || !header) return;
                
                let isDragging = false;
                let currentX, currentY, initialX, initialY;
                let xOffset = 0, yOffset = 0;
                
                header.addEventListener('mousedown', (e) => {
                    if (e.target.tagName === 'BUTTON') return;
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                    isDragging = true;
                    header.style.cursor = 'grabbing';
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    xOffset = currentX;
                    yOffset = currentY;
                    dashboard.style.transform = `translate3d(${currentX}px, ${currentY}px, 0)`;
                });
                
                document.addEventListener('mouseup', () => {
                    initialX = currentX;
                    initialY = currentY;
                    isDragging = false;
                    header.style.cursor = 'move';
                });
                
                header.style.cursor = 'move';
                log(' Agent Dashboard is now draggable', 'success');
            },
            
            toggleMinimize() {
                const content = document.getElementById('agent-dashboard-content');
                const button = document.querySelector('#agent-dashboard-header button');
                
                if (!content || !button) return;
                
                this.minimized = !this.minimized;
                
                if (this.minimized) {
                    content.style.display = 'none';
                    button.textContent = '+';
                    log(' Agent Dashboard minimized', 'info');
                } else {
                    content.style.display = 'block';
                    button.textContent = '';
                    log(' Agent Dashboard expanded', 'info');
                }
            },
            
            activateAgent(agentId) {
                log(` Activating agent: ${agentId}`, 'success');
                
                // Trigger token stream
                TokenStreamOrchestrator.streamTokens(agentId, 100);
                
                // Visual feedback
                const agentNode = document.getElementById(`agent-node-${agentId}`);
                if (agentNode) {
                    agentNode.classList.add('active');
                    setTimeout(() => agentNode.classList.remove('active'), 2000);
                }
                
                // Spawn a task related to this agent
                const agentTasks = {
                    elder: { label: 'Orchestrate Workflow', icon: '', subtasks: ['Coordinate agents', 'Monitor progress', 'Optimize routing'] },
                    fetcher: { label: 'Fetch Data', icon: '', subtasks: ['Query APIs', 'Parse responses', 'Cache results'] },
                    browser: { label: 'Navigate Web', icon: '', subtasks: ['Load pages', 'Extract content', 'Handle redirects'] },
                    parser: { label: 'Parse Content', icon: '', subtasks: ['Tokenize text', 'Build AST', 'Generate output'] }
                };
                
                const task = agentTasks[agentId];
                if (task) {
                    TaskBubbleSystem.spawnCustomBubble(task.label, task.icon, task.subtasks);
                }
            },
            
            updateDashboard() {
                const statusList = document.getElementById('agent-status-list');
                if (!statusList) return;
                
                statusList.innerHTML = TokenStreamOrchestrator.agents.map(agent => {
                    const status = agent.tokens > 1000 ? 'BUSY' : agent.tokens > 0 ? 'ACTIVE' : 'IDLE';
                    const statusColor = status === 'BUSY' ? 'var(--orange)' : status === 'ACTIVE' ? 'var(--cyan)' : 'var(--green)';
                    const statusDot = status === 'BUSY' ? '' : status === 'ACTIVE' ? '' : '';
                    
                    return `
                        <div onclick="AgentDashboard.activateAgent('${agent.id}')" style="
                            margin: 10px 0;
                            padding: 15px;
                            background: rgba(0, 212, 255, 0.08);
                            backdrop-filter: blur(10px);
                            -webkit-backdrop-filter: blur(10px);
                            border: 2px solid rgba(0, 212, 255, 0.3);
                            border-radius: 12px;
                            box-shadow: 0 4px 16px rgba(0, 212, 255, 0.2);
                            transition: all 0.3s ease;
                            cursor: pointer;
                        " onmouseenter="this.style.transform='scale(1.02)'; this.style.boxShadow='0 8px 24px rgba(0,212,255,0.4)';" onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 16px rgba(0,212,255,0.2)';">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div style="display: flex; align-items: center; gap: 12px;">
                                    <div style="font-size: 32px; filter: drop-shadow(0 0 8px currentColor); transition: all 0.3s;">${agent.icon}</div>
                                    <div>
                                        <div style="color: var(--cyan); font-weight: bold; font-size: 14px;">${agent.name} Agent</div>
                                        <div style="color: #888; font-size: 10px; margin-top: 2px;">${agent.tokens.toLocaleString()} tokens processed</div>
                                    </div>
                                </div>
                                <div style="font-size: 20px;">${statusDot}</div>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; font-size: 10px;">
                                <span style="color: ${statusColor}; font-weight: bold; padding: 4px 10px; background: rgba(0,0,0,0.3); border-radius: 12px;">${status}</span>
                                <span style="color: var(--teal); opacity: 0.8;">Click to activate </span>
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Update emotional state
                const emotionEl = document.getElementById('dashboard-emotion');
                if (emotionEl) {
                    emotionEl.textContent = EmotionalOrchestrator.currentState;
                    emotionEl.style.color = EmotionalOrchestrator.stateColors[EmotionalOrchestrator.currentState].primary;
                }
                
                // Update task count
                const tasksEl = document.getElementById('dashboard-tasks');
                if (tasksEl) {
                    tasksEl.textContent = TaskBubbleSystem.tasks.length;
                }
            },
            
            startUpdates() {
                setInterval(() => {
                    this.updateDashboard();
                }, 500); // Update every 500ms
            }
        };
        
        // Global function to spawn random tasks
        function spawnRandomTask() {
            const taskTypes = [
                { label: 'Code Review', icon: '', subtasks: ['Check logic', 'Review style', 'Test coverage'] },
                { label: 'Add Feature', icon: '', subtasks: ['Design API', 'Write tests', 'Implement logic'] },
                { label: 'Update Docs', icon: '', subtasks: ['Write README', 'Add examples', 'Update changelog'] },
                { label: 'Security Audit', icon: '', subtasks: ['Scan dependencies', 'Check auth', 'Review permissions'] }
            ];
            
            const task = taskTypes[Math.floor(Math.random() * taskTypes.length)];
            TaskBubbleSystem.spawnCustomBubble(task.label, task.icon, task.subtasks);
        }
        
        // ========================================
        // /SYMPHONY - MASTER ORCHESTRATION CONDUCTOR
        // ========================================
        
        const SymphonyOrchestrator = {
            isPerforming: false,
            performanceInterval: null,
            movements: ['overture', 'crescendo', 'interlude', 'finale'],
            currentMovement: 0,
            
            // The /symphony endpoint - conducts the entire mesh
            async performSymphony() {
                if (this.isPerforming) {
                    log(' Symphony already in progress...', 'warning');
                    return;
                }
                
                this.isPerforming = true;
                log(' ', 'success');
                log(' /SYMPHONY ENDPOINT INVOKED', 'success');
                log(' Conducting the neuro-symphonic mesh...', 'success');
                log(' ', 'success');
                
                // Movement I: Overture - Reset and prepare
                await this.movement_overture();
                
                // Movement II: Crescendo - Intense activity
                await this.movement_crescendo();
                
                // Movement III: Interlude - Focused work
                await this.movement_interlude();
                
                // Movement IV: Finale - Celebration
                await this.movement_finale();
                
                this.isPerforming = false;
                log(' Symphony complete. The mesh rests.', 'success');
            },
            
            async movement_overture() {
                log(' Movement I: OVERTURE - Awakening the mesh', 'info');
                
                // Trigger rebirth
                rebirthOrchestration();
                
                // Set emotional state to CALM
                if (typeof neuroSymphonic !== 'undefined') {
                    neuroSymphonic.changeState('CALM');
                }
                
                // Spawn 3 gentle task bubbles
                await this.delay(1000);
                const calmTasks = [
                    { label: 'Morning Review', icon: '', subtasks: ['Check emails', 'Review PRs', 'Plan day'] },
                    { label: 'Code Exploration', icon: '', subtasks: ['Browse codebase', 'Find opportunities', 'Document learnings'] },
                    { label: 'Knowledge Share', icon: '', subtasks: ['Write blog post', 'Update wiki', 'Mentor teammate'] }
                ];
                
                for (const task of calmTasks) {
                    TaskBubbleSystem.spawnCustomBubble(task.label, task.icon, task.subtasks);
                    await this.delay(800);
                }
                
                log(' Overture complete - mesh awakened', 'success');
                await this.delay(2000);
            },
            
            async movement_crescendo() {
                log(' Movement II: CRESCENDO - Intensity rising', 'info');
                
                // Change to FOCUSED state
                if (typeof neuroSymphonic !== 'undefined') {
                    neuroSymphonic.changeState('FOCUSED');
                }
                
                // Spawn 5 challenging tasks rapidly
                const intenseTasks = [
                    { label: 'Critical Bugfix', icon: '', subtasks: ['Reproduce bug', 'Write test', 'Deploy fix'] },
                    { label: 'Performance Sprint', icon: '', subtasks: ['Profile code', 'Optimize loops', 'Reduce allocations'] },
                    { label: 'Architecture Refactor', icon: '', subtasks: ['Design new system', 'Migration plan', 'Implement changes'] },
                    { label: 'Security Hardening', icon: '', subtasks: ['Audit code', 'Fix vulnerabilities', 'Add tests'] },
                    { label: 'Scale Infrastructure', icon: '', subtasks: ['Load testing', 'Add caching', 'Deploy CDN'] }
                ];
                
                for (const task of intenseTasks) {
                    TaskBubbleSystem.spawnCustomBubble(task.label, task.icon, task.subtasks);
                    TokenStreamOrchestrator.simulateOrchestration();
                    await this.delay(500);
                }
                
                // Activate all agents simultaneously
                await this.delay(1000);
                TokenStreamOrchestrator.agents.forEach(agent => {
                    TokenStreamOrchestrator.activateAgent(agent.id);
                });
                
                // Change to INTENSE state
                await this.delay(2000);
                if (typeof neuroSymphonic !== 'undefined') {
                    neuroSymphonic.changeState('INTENSE');
                }
                
                // Rapid token streaming
                for (let i = 0; i < 10; i++) {
                    TokenStreamOrchestrator.simulateOrchestration();
                    await this.delay(300);
                }
                
                log(' Crescendo complete - peak intensity reached', 'success');
                await this.delay(2000);
            },
            
            async movement_interlude() {
                log(' Movement III: INTERLUDE - Focused contemplation', 'info');
                
                // Transition to OVERWHELMED (too many tasks!)
                if (typeof neuroSymphonic !== 'undefined') {
                    neuroSymphonic.changeState('OVERWHELMED');
                }
                
                await this.delay(1000);
                
                // Spawn calming task
                TaskBubbleSystem.spawnCustomBubble(
                    'Simplify & Refactor', 
                    '', 
                    ['Remove dead code', 'Extract functions', 'Add comments']
                );
                
                await this.delay(2000);
                
                // Gradually reduce intensity - back to FOCUSED
                if (typeof neuroSymphonic !== 'undefined') {
                    neuroSymphonic.changeState('FOCUSED');
                }
                
                // Slow token streaming
                for (let i = 0; i < 3; i++) {
                    TokenStreamOrchestrator.simulateOrchestration();
                    await this.delay(1500);
                }
                
                log(' Interlude complete - balance restored', 'success');
                await this.delay(2000);
            },
            
            async movement_finale() {
                log(' Movement IV: FINALE - Celebration & synthesis', 'info');
                
                // Return to CALM
                if (typeof neuroSymphonic !== 'undefined') {
                    neuroSymphonic.changeState('CALM');
                }
                
                // Grand celebration - all agents bloom
                for (let i = 0; i < TokenStreamOrchestrator.agents.length; i++) {
                    const agent = TokenStreamOrchestrator.agents[i];
                    
                    // Triple bloom from each agent
                    for (let b = 0; b < 3; b++) {
                        setTimeout(() => {
                            TokenStreamOrchestrator.createBloomPulse(agent.x + 30, agent.y + 30);
                        }, b * 200);
                    }
                    
                    // Stream to all other agents
                    TokenStreamOrchestrator.agents.forEach((target, targetIndex) => {
                        if (target.id !== agent.id) {
                            setTimeout(() => {
                                TokenStreamOrchestrator.streamTokens(agent.id, targetIndex);
                            }, (i * 500) + (targetIndex * 100));
                        }
                    });
                    
                    await this.delay(800);
                }
                
                // Spawn victory task
                await this.delay(2000);
                TaskBubbleSystem.spawnCustomBubble(
                    'Symphony Complete', 
                    '', 
                    ['Reflect on work', 'Celebrate wins', 'Plan tomorrow']
                );
                
                // Final bloom cascade
                await this.delay(1000);
                for (let i = 0; i < 5; i++) {
                    TokenStreamOrchestrator.createBloomPulse(
                        window.innerWidth / 2 + (Math.random() - 0.5) * 200,
                        window.innerHeight / 2 + (Math.random() - 0.5) * 200
                    );
                    await this.delay(300);
                }
                
                log(' Finale complete - cognition flows like light', 'success');
                log(' ', 'success');
                log(' SYMPHONY PERFORMANCE CONCLUDED', 'success');
                log(' The mesh breathes. The agents rest. The work continues.', 'success');
                log(' ', 'success');
            },
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            },
            
            // Shorthand for console access
            conduct() {
                this.performSymphony();
            }
        };
        
        // ========================================
        // /ENDCLOUD - GRACEFUL CLOSURE ENDPOINT
        // ========================================
        
        async function endcloud() {
            log(' ', 'info');
            log(' /ENDCLOUD ENDPOINT INVOKED', 'info');
            log(' Initiating graceful shutdown...', 'info');
            log(' ', 'info');
            
            // Step 1: Fade out all task bubbles
            const bubbles = document.querySelectorAll('.task-bubble');
            bubbles.forEach((bubble, index) => {
                setTimeout(() => {
                    bubble.style.animation = 'fadeOut 1s forwards ease-in';
                    setTimeout(() => bubble.remove(), 1000);
                }, index * 200);
            });
            
            await SymphonyOrchestrator.delay(1500);
            
            // Step 2: Archive agent states
            TokenStreamOrchestrator.agents.forEach(agent => {
                agent.tokens = 0;
                TokenStreamOrchestrator.updateTokenCounter(agent.id, 0);
            });
            
            // Step 3: Transition to CALM
            if (typeof neuroSymphonic !== 'undefined') {
                neuroSymphonic.changeState('CALM');
            }
            
            // Step 4: Spiral out dashboards
            const dashboards = [document.getElementById('agent-dashboard'), document.getElementById('stream-dashboard')];
            dashboards.forEach(dash => {
                if (dash) {
                    dash.style.animation = 'spiralOut 1.5s forwards ease-in-out';
                }
            });
            
            await SymphonyOrchestrator.delay(2000);
            
            log(' All agents archived. Emotional state: CALM', 'success');
            log(' Endcloud complete - the mesh dissolves into calm', 'success');
            
            // Reset animations
            dashboards.forEach(dash => {
                if (dash) dash.style.animation = 'none';
            });
        }
        
        // Add CSS animations for endcloud and beam system
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeOut {
                to { opacity: 0; transform: scale(0.5); }
            }
            
            @keyframes spiralOut {
                0% { transform: rotate(0deg) scale(1); opacity: 1; }
                100% { transform: rotate(720deg) scale(0.5); opacity: 0; }
            }
            
            @keyframes spiralIn {
                0% { transform: rotate(-720deg) scale(0.5); opacity: 0; }
                100% { transform: rotate(0deg) scale(1); opacity: 1; }
            }
            
            @keyframes hydraulicBounce {
                0%, 100% { transform: translateY(0); }
                25% { transform: translateY(-20px); }
                50% { transform: translateY(0); }
                75% { transform: translateY(-10px); }
            }
            
            /* ======================================== */
            /* COGNITIVE BEAM SYSTEM - NEURAL LATTICE */
            /* ======================================== */
            
            #beam-layer {
                position: fixed;
                top: 0; left: 0;
                width: 100%; height: 100%;
                pointer-events: none;
                z-index: 998;
                overflow: hidden;
            }
            
            .beam {
                position: absolute;
                width: 6px;
                height: 6px;
                border-radius: 50%;
                box-shadow: 0 0 12px;
                animation: beamPulse 1s infinite ease-in-out;
                z-index: 1000;
            }
            
            .beam-trail {
                position: absolute;
                width: 3px;
                height: 3px;
                border-radius: 50%;
                opacity: 0.6;
                animation: beamTrail 0.8s ease-out forwards;
            }
            
            .beam-bloom {
                position: absolute;
                width: 20px;
                height: 20px;
                border-radius: 50%;
                opacity: 0.8;
                animation: beamBloom 0.6s ease-out forwards;
            }
            
            .neural-path {
                position: absolute;
                height: 2px;
                background: linear-gradient(90deg, transparent, currentColor, transparent);
                animation: neuralFlow 2s ease-in-out infinite;
                transform-origin: left center;
            }
            
            @keyframes beamPulse {
                0%, 100% { transform: scale(1); opacity: 0.8; }
                50% { transform: scale(1.5); opacity: 1; }
            }
            
            @keyframes beamTrail {
                0% { transform: scale(1); opacity: 0.8; }
                100% { transform: scale(0.3); opacity: 0; }
            }
            
            @keyframes beamBloom {
                0% { transform: scale(0.5); opacity: 0.8; }
                100% { transform: scale(2); opacity: 0; }
            }
            
            @keyframes neuralFlow {
                0% { transform: scaleX(0); opacity: 0; }
                50% { transform: scaleX(1); opacity: 1; }
                100% { transform: scaleX(0); opacity: 0; }
            }
            
            /* Beam color classes */
            .beam-calm { background: #00f6ff; box-shadow: 0 0 12px #00f6ff; }
            .beam-focused { background: #00ff88; box-shadow: 0 0 12px #00ff88; }
            .beam-intense { background: #ffcc00; box-shadow: 0 0 12px #ffcc00; }
            .beam-overwhelmed { background: #ff0044; box-shadow: 0 0 12px #ff0044; }
            .beam-default { background: #888; box-shadow: 0 0 12px #888; }
        `;
        document.head.appendChild(style);
        
        // ========================================
        // COGNITIVE BEAM SYSTEM - NEURAL LATTICE
        // ========================================
        
        const CognitiveBeamSystem = {
            beamLayer: null,
            activeBeams: new Set(),
            beamColors: {
                CALM: '#00f6ff',
                FOCUSED: '#00ff88',
                INTENSE: '#ffcc00',
                OVERWHELMED: '#ff0044',
                DEFAULT: '#888'
            },
            
            init() {
                // Create beam layer if it doesn't exist
                if (!document.getElementById('beam-layer')) {
                    this.beamLayer = document.createElement('div');
                    this.beamLayer.id = 'beam-layer';
                    document.body.appendChild(this.beamLayer);
                }
                this.beamLayer = document.getElementById('beam-layer');
                
                log(' Cognitive Beam System initialized', 'success');
            },
            
            getBeamColor(emotionalState) {
                return this.beamColors[emotionalState] || this.beamColors.DEFAULT;
            },
            
            spawnThinkingBeam(agentId, x, y, emotionalState = 'FOCUSED') {
                if (!this.beamLayer) return;
                
                const color = this.getBeamColor(emotionalState);
                const colorClass = `beam-${emotionalState.toLowerCase()}`;
                
                const beam = document.createElement('div');
                beam.className = `beam ${colorClass}`;
                beam.style.left = `${x}px`;
                beam.style.top = `${y}px`;
                
                // Add data attributes for tracking
                beam.dataset.agent = agentId;
                beam.dataset.emotion = emotionalState;
                
                this.beamLayer.appendChild(beam);
                this.activeBeams.add(beam);
                
                // Create trailing particles
                this.createTrail(x, y, color, 5);
                
                // Remove after animation
                setTimeout(() => {
                    beam.remove();
                    this.activeBeams.delete(beam);
                }, 1500);
                
                return beam;
            },
            
            createTrail(startX, startY, color, count) {
                for (let i = 0; i < count; i++) {
                    setTimeout(() => {
                        const trail = document.createElement('div');
                        trail.className = 'beam-trail';
                        trail.style.left = `${startX + (Math.random() - 0.5) * 20}px`;
                        trail.style.top = `${startY + (Math.random() - 0.5) * 20}px`;
                        trail.style.background = color;
                        trail.style.boxShadow = `0 0 8px ${color}`;
                        
                        this.beamLayer.appendChild(trail);
                        
                        setTimeout(() => trail.remove(), 800);
                    }, i * 100);
                }
            },
            
            spawnBloom(x, y, emotionalState = 'FOCUSED') {
                if (!this.beamLayer) return;
                
                const color = this.getBeamColor(emotionalState);
                
                const bloom = document.createElement('div');
                bloom.className = 'beam-bloom';
                bloom.style.left = `${x - 10}px`;
                bloom.style.top = `${y - 10}px`;
                bloom.style.background = `radial-gradient(circle, ${color}, transparent)`;
                bloom.style.boxShadow = `0 0 20px ${color}`;
                
                this.beamLayer.appendChild(bloom);
                
                setTimeout(() => bloom.remove(), 600);
            },
            
            drawNeuralPath(fromX, fromY, toX, toY, emotionalState = 'FOCUSED') {
                if (!this.beamLayer) return;
                
                const color = this.getBeamColor(emotionalState);
                
                const dx = toX - fromX;
                const dy = toY - fromY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                const path = document.createElement('div');
                path.className = 'neural-path';
                path.style.left = `${fromX}px`;
                path.style.top = `${fromY}px`;
                path.style.width = `${distance}px`;
                path.style.transform = `rotate(${angle}deg)`;
                path.style.color = color;
                
                this.beamLayer.appendChild(path);
                
                setTimeout(() => path.remove(), 2000);
            },
            
            beamTaskToAgent(taskBubble, agentNode) {
                if (!taskBubble || !agentNode) return;
                
                const taskRect = taskBubble.getBoundingClientRect();
                const agentRect = agentNode.getBoundingClientRect();
                
                const fromX = taskRect.left + taskRect.width / 2;
                const fromY = taskRect.top + taskRect.height / 2;
                const toX = agentRect.left + agentRect.width / 2;
                const toY = agentRect.top + agentRect.height / 2;
                
                const emotionalState = (typeof neuroSymphonic !== 'undefined') 
                    ? neuroSymphonic.getEmotionalState() 
                    : 'FOCUSED';
                
                // Draw neural path
                this.drawNeuralPath(fromX, fromY, toX, toY, emotionalState);
                
                // Spawn thinking beam at agent
                setTimeout(() => {
                    this.spawnThinkingBeam(agentNode.dataset.agent, toX, toY, emotionalState);
                }, 1000);
                
                // Bloom on completion
                setTimeout(() => {
                    this.spawnBloom(toX, toY, emotionalState);
                }, 2000);
            },
            
            simulateCognitiveActivity() {
                // Simulate beams across the screen
                const agents = document.querySelectorAll('.agent-node');
                
                agents.forEach((agent, index) => {
                    setTimeout(() => {
                        const rect = agent.getBoundingClientRect();
                        const x = rect.left + rect.width / 2;
                        const y = rect.top + rect.height / 2;
                        
                        const emotionalState = (typeof neuroSymphonic !== 'undefined') 
                            ? neuroSymphonic.getEmotionalState() 
                            : 'FOCUSED';
                        
                        this.spawnThinkingBeam(agent.dataset.agent, x, y, emotionalState);
                    }, index * 500);
                });
            },
            
            neuralLatticeMode() {
                // Create a pulsing neural lattice across all agent nodes
                const agents = Array.from(document.querySelectorAll('.agent-node'));
                
                log(' Neural Lattice Mode: ACTIVATED', 'success');
                
                // Connect all agents with neural paths
                for (let i = 0; i < agents.length; i++) {
                    for (let j = i + 1; j < agents.length; j++) {
                        setTimeout(() => {
                            const rect1 = agents[i].getBoundingClientRect();
                            const rect2 = agents[j].getBoundingClientRect();
                            
                            const x1 = rect1.left + rect1.width / 2;
                            const y1 = rect1.top + rect1.height / 2;
                            const x2 = rect2.left + rect2.width / 2;
                            const y2 = rect2.top + rect2.height / 2;
                            
                            const emotionalState = (typeof neuroSymphonic !== 'undefined') 
                                ? neuroSymphonic.getEmotionalState() 
                                : 'FOCUSED';
                            
                            this.drawNeuralPath(x1, y1, x2, y2, emotionalState);
                        }, (i * agents.length + j) * 200);
                    }
                }
            }
        };
        
        // Global beam functions
        window.beamMe = () => CognitiveBeamSystem.simulateCognitiveActivity();
        window.neuralLattice = () => CognitiveBeamSystem.neuralLatticeMode();
        
        // ========================================
        // THEME SYSTEM - CINEMATIC OVERLAYS
        // ========================================
        
        const ThemeSystem = {
            currentTheme: 'default',
            themes: {
                'matrix': {
                    name: 'Matrix Rain',
                    colors: { primary: '#00ff41', secondary: '#008f11', accent: '#003B00' },
                    particles: 'rain',
                    description: 'Digital rain, green glow, hacker aesthetic'
                },
                'cyberpunk': {
                    name: 'Cyberpunk 2077',
                    colors: { primary: '#ff00ff', secondary: '#00ffff', accent: '#ffff00' },
                    particles: 'neon',
                    description: 'Neon lights, pink and cyan, dystopian future'
                },
                'synthwave': {
                    name: 'Synthwave Sunset',
                    colors: { primary: '#ff6ec7', secondary: '#7b2cbf', accent: '#ff006e' },
                    particles: 'grid',
                    description: '80s retro, purple gradients, neon grids'
                },
                'arctic': {
                    name: 'Arctic Aurora',
                    colors: { primary: '#00f6ff', secondary: '#4cc9f0', accent: '#7209b7' },
                    particles: 'aurora',
                    description: 'Ice blue, aurora borealis, crystalline'
                },
                'inferno': {
                    name: 'Digital Inferno',
                    colors: { primary: '#ff0000', secondary: '#ff8800', accent: '#ffaa00' },
                    particles: 'fire',
                    description: 'Red hot, flame effects, intense energy'
                },
                'cosmic': {
                    name: 'Cosmic Nebula',
                    colors: { primary: '#8b5cf6', secondary: '#ec4899', accent: '#06b6d4' },
                    particles: 'stars',
                    description: 'Space vibes, nebula colors, starfield'
                },
                'forest': {
                    name: 'Digital Forest',
                    colors: { primary: '#10b981', secondary: '#059669', accent: '#047857' },
                    particles: 'leaves',
                    description: 'Nature tech, organic greens, bio-luminescent'
                },
                'ghost': {
                    name: 'Ghost Protocol',
                    colors: { primary: '#e0e0e0', secondary: '#9ca3af', accent: '#6b7280' },
                    particles: 'smoke',
                    description: 'Monochrome, stealth mode, minimal'
                },
                'blood': {
                    name: 'Blood Moon',
                    colors: { primary: '#dc2626', secondary: '#991b1b', accent: '#7f1d1d' },
                    particles: 'blood',
                    description: 'Deep red, crimson glow, vampiric'
                },
                'electric': {
                    name: 'Electric Storm',
                    colors: { primary: '#3b82f6', secondary: '#2563eb', accent: '#1e40af' },
                    particles: 'lightning',
                    description: 'Electric blue, lightning bolts, high voltage'
                }
            },
            
            applyTheme(themeName) {
                const theme = this.themes[themeName];
                if (!theme) {
                    log(` Theme '${themeName}' not found`, 'error');
                    return;
                }
                
                this.currentTheme = themeName;
                
                // Apply CSS variables
                const root = document.documentElement;
                root.style.setProperty('--theme-primary', theme.colors.primary);
                root.style.setProperty('--theme-secondary', theme.colors.secondary);
                root.style.setProperty('--theme-accent', theme.colors.accent);
                
                // Update emotional colors
                root.style.setProperty('--emotional-primary', theme.colors.primary);
                root.style.setProperty('--emotional-glow', theme.colors.secondary);
                
                // Update beam colors
                CognitiveBeamSystem.beamColors.FOCUSED = theme.colors.primary;
                CognitiveBeamSystem.beamColors.INTENSE = theme.colors.accent;
                
                log(` Theme applied: ${theme.name}`, 'success');
                log(`   ${theme.description}`, 'info');
                
                // Trigger visual refresh
                this.triggerThemeAnimation(themeName);
            },
            
            triggerThemeAnimation(themeName) {
                // Create a full-screen flash effect
                const flash = document.createElement('div');
                flash.style.cssText = `
                    position: fixed;
                    top: 0; left: 0;
                    width: 100%; height: 100%;
                    background: ${this.themes[themeName].colors.primary};
                    opacity: 0.5;
                    z-index: 9999;
                    pointer-events: none;
                    animation: themeFlash 0.5s ease-out;
                `;
                
                document.body.appendChild(flash);
                setTimeout(() => flash.remove(), 500);
                
                // Add flash animation
                const flashStyle = document.createElement('style');
                flashStyle.textContent = `
                    @keyframes themeFlash {
                        0% { opacity: 0.8; }
                        100% { opacity: 0; }
                    }
                `;
                document.head.appendChild(flashStyle);
            },
            
            listThemes() {
                log(' Available Themes:', 'info');
                Object.keys(this.themes).forEach(key => {
                    const theme = this.themes[key];
                    const indicator = (key === this.currentTheme) ? '' : ' ';
                    log(`${indicator} ${key.padEnd(12)} - ${theme.name} - ${theme.description}`, 'info');
                });
                log('Usage: theme("matrix") or theme("cyberpunk")', 'info');
            },
            
            randomTheme() {
                const themeKeys = Object.keys(this.themes);
                const randomKey = themeKeys[Math.floor(Math.random() * themeKeys.length)];
                this.applyTheme(randomKey);
            }
        };
        
        // Global theme functions
        window.theme = (name) => ThemeSystem.applyTheme(name);
        window.themes = () => ThemeSystem.listThemes();
        window.randomTheme = () => ThemeSystem.randomTheme();
        
        // ========================================
        // AUDIO-REACTIVE OVERLAY SYSTEM
        // ========================================
        
        const AudioReactiveSystem = {
            audioContext: null,
            analyser: null,
            microphone: null,
            isActive: false,
            frequencyData: null,
            
            async init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 256;
                    this.frequencyData = new Uint8Array(this.analyser.frequencyBinCount);
                    
                    log(' Audio-Reactive System initialized', 'success');
                    log('   Use startAudioReactive() to enable microphone', 'info');
                } catch (error) {
                    log(' Audio API not available: ' + error.message, 'error');
                }
            },
            
            async startAudioReactive() {
                if (this.isActive) {
                    log(' Audio-reactive mode already active', 'warning');
                    return;
                }
                
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.microphone = this.audioContext.createMediaStreamSource(stream);
                    this.microphone.connect(this.analyser);
                    this.isActive = true;
                    
                    log(' Audio-reactive mode: ACTIVATED', 'success');
                    log('   Speak or play music to modulate visuals!', 'success');
                    
                    this.startVisualization();
                } catch (error) {
                    log(' Microphone access denied: ' + error.message, 'error');
                }
            },
            
            stopAudioReactive() {
                if (this.microphone) {
                    this.microphone.disconnect();
                    this.microphone = null;
                }
                this.isActive = false;
                log(' Audio-reactive mode: DEACTIVATED', 'info');
            },
            
            startVisualization() {
                const visualize = () => {
                    if (!this.isActive) return;
                    
                    this.analyser.getByteFrequencyData(this.frequencyData);
                    
                    // Calculate average frequency
                    const average = this.frequencyData.reduce((a, b) => a + b) / this.frequencyData.length;
                    
                    // Modulate bounce tempo based on audio intensity
                    if (average > 100) {
                        BounceOrchestrator.modulateTempo('INTENSE');
                    } else if (average > 50) {
                        BounceOrchestrator.modulateTempo('FOCUSED');
                    } else {
                        BounceOrchestrator.modulateTempo('CALM');
                    }
                    
                    // Modulate beam spawning
                    if (average > 80) {
                        CognitiveBeamSystem.simulateCognitiveActivity();
                    }
                    
                    // Update visual intensity
                    const intensity = Math.min(average / 128, 1);
                    document.documentElement.style.setProperty('--audio-intensity', intensity);
                    
                    requestAnimationFrame(visualize);
                };
                
                visualize();
            },
            
            getIntensity() {
                if (!this.isActive) return 0;
                this.analyser.getByteFrequencyData(this.frequencyData);
                return this.frequencyData.reduce((a, b) => a + b) / this.frequencyData.length / 255;
            }
        };
        
        // Global audio functions
        window.startAudioReactive = () => AudioReactiveSystem.startAudioReactive();
        window.stopAudioReactive = () => AudioReactiveSystem.stopAudioReactive();
        
        // ========================================
        // PARTICLE SYSTEM - AMBIENT EFFECTS
        // ========================================
        
        const ParticleSystem = {
            particleContainer: null,
            activeParticles: new Set(),
            isActive: false,
            particleInterval: null,
            
            init() {
                if (!document.getElementById('particle-container')) {
                    this.particleContainer = document.createElement('div');
                    this.particleContainer.id = 'particle-container';
                    this.particleContainer.style.cssText = `
                        position: fixed;
                        top: 0; left: 0;
                        width: 100%; height: 100%;
                        pointer-events: none;
                        z-index: 998;
                        overflow: hidden;
                    `;
                    document.body.appendChild(this.particleContainer);
                }
                this.particleContainer = document.getElementById('particle-container');
                
                log(' Particle System initialized', 'success');
            },
            
            startParticles(type = 'stars') {
                if (this.isActive) {
                    this.stopParticles();
                }
                
                this.isActive = true;
                log(` Particle System: ${type} mode activated`, 'success');
                
                this.particleInterval = setInterval(() => {
                    this.spawnParticle(type);
                }, 100);
            },
            
            stopParticles() {
                if (this.particleInterval) {
                    clearInterval(this.particleInterval);
                    this.particleInterval = null;
                }
                this.isActive = false;
                
                // Clear existing particles
                this.activeParticles.forEach(p => p.remove());
                this.activeParticles.clear();
                
                log(' Particle System: deactivated', 'info');
            },
            
            spawnParticle(type) {
                if (!this.particleContainer) return;
                
                const particle = document.createElement('div');
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                
                const styles = this.getParticleStyle(type);
                particle.style.cssText = `
                    position: absolute;
                    left: ${x}px;
                    top: ${y}px;
                    ${styles}
                `;
                
                this.particleContainer.appendChild(particle);
                this.activeParticles.add(particle);
                
                setTimeout(() => {
                    particle.remove();
                    this.activeParticles.delete(particle);
                }, 3000);
            },
            
            getParticleStyle(type) {
                const baseStyles = 'border-radius: 50%; opacity: 0.6;';
                
                switch(type) {
                    case 'stars':
                        return `${baseStyles} width: 2px; height: 2px; background: white; box-shadow: 0 0 4px white; animation: twinkle 1s ease-in-out infinite;`;
                    case 'snow':
                        return `${baseStyles} width: 3px; height: 3px; background: white; animation: snowfall 3s linear forwards;`;
                    case 'rain':
                        return `width: 1px; height: 20px; background: linear-gradient(transparent, #00ff41); opacity: 0.6; animation: rainfall 1s linear forwards;`;
                    case 'fire':
                        return `${baseStyles} width: 8px; height: 8px; background: radial-gradient(circle, #ffaa00, #ff0000); animation: fireRise 2s ease-out forwards;`;
                    case 'smoke':
                        return `${baseStyles} width: 20px; height: 20px; background: radial-gradient(circle, rgba(150,150,150,0.3), transparent); animation: smokeRise 4s ease-out forwards;`;
                    default:
                        return baseStyles;
                }
            }
        };
        
        // Add particle animations
        const particleStyle = document.createElement('style');
        particleStyle.textContent = `
            @keyframes twinkle {
                0%, 100% { opacity: 0.3; transform: scale(1); }
                50% { opacity: 1; transform: scale(1.5); }
            }
            
            @keyframes snowfall {
                0% { transform: translateY(-10px); opacity: 0.8; }
                100% { transform: translateY(100vh); opacity: 0; }
            }
            
            @keyframes rainfall {
                0% { transform: translateY(-20px); opacity: 0.8; }
                100% { transform: translateY(100vh); opacity: 0; }
            }
            
            @keyframes fireRise {
                0% { transform: translateY(0) scale(1); opacity: 0.8; }
                100% { transform: translateY(-200px) scale(0.3); opacity: 0; }
            }
            
            @keyframes smokeRise {
                0% { transform: translateY(0) scale(0.5); opacity: 0.5; }
                100% { transform: translateY(-300px) scale(2); opacity: 0; }
            }
        `;
        document.head.appendChild(particleStyle);
        
        // Global particle functions
        window.particles = (type) => ParticleSystem.startParticles(type);
        window.stopParticles = () => ParticleSystem.stopParticles();
        
        // ========================================
        // /BOUNCE - 40-OUNCE HYDRAULIC LOOP
        // ========================================
        
        const BounceOrchestrator = {
            isBouncing: false,
            bounceInterval: null,
            tempo: 12000, // 12 seconds per full cycle
            
            async startBounce() {
                if (this.isBouncing) {
                    log(' Already bouncing...', 'warning');
                    return;
                }
                
                this.isBouncing = true;
                log(' ', 'success');
                log(' /BOUNCE ENDPOINT ENGAGED', 'success');
                log(' 40-ounce orchestration loop - riding hydraulics', 'success');
                log(' ', 'success');
                
                // Initial bounce
                await this.executeBounceLoop();
                
                // Set up repeating loop
                this.bounceInterval = setInterval(() => {
                    this.executeBounceLoop();
                }, this.tempo);
                
                log(' Bounce loop initiated - tempo: ' + (this.tempo/1000) + 's', 'success');
            },
            
            async executeBounceLoop() {
                // Step 1: DROP THE BEAT - Launch symphony
                log(' Beat drop  /symphony', 'info');
                SymphonyOrchestrator.performSymphony();
                
                // Step 2: Let it RIDE - Fade to endcloud  
                await this.delay(4000);
                log(' Fading  /endcloud', 'info');
                endcloud();
                
                // Step 3: BRING IT BACK - Rebirth with bloom
                await this.delay(4000);
                log(' Rising  /rebirth', 'info');
                rebirthOrchestration();
                
                // Add hydraulic bounce to dashboards
                this.hydraulicBounce();
            },
            
            hydraulicBounce() {
                const elements = [
                    document.getElementById('agent-dashboard'),
                    document.getElementById('stream-dashboard'),
                    ...document.querySelectorAll('.agent-node')
                ];
                
                elements.forEach((el, index) => {
                    if (el) {
                        setTimeout(() => {
                            el.style.animation = 'hydraulicBounce 1s ease-in-out';
                            setTimeout(() => el.style.animation = '', 1000);
                        }, index * 100);
                    }
                });
            },
            
            stopBounce() {
                if (this.bounceInterval) {
                    clearInterval(this.bounceInterval);
                    this.bounceInterval = null;
                }
                this.isBouncing = false;
                log(' Bounce loop stopped', 'info');
            },
            
            modulateTempo(emotionalState) {
                // Tempo modulation based on emotional state
                const tempos = {
                    CALM: 16000,        // Slow cruise
                    FOCUSED: 12000,     // Steady ride
                    INTENSE: 8000,      // Fast bounce
                    OVERWHELMED: 20000  // Slow recovery
                };
                
                const newTempo = tempos[emotionalState] || 12000;
                
                if (newTempo !== this.tempo) {
                    this.tempo = newTempo;
                    log(` Tempo modulated: ${this.tempo/1000}s (${emotionalState})`, 'info');
                    
                    // Restart interval with new tempo if bouncing
                    if (this.isBouncing && this.bounceInterval) {
                        clearInterval(this.bounceInterval);
                        this.bounceInterval = setInterval(() => {
                            this.executeBounceLoop();
                        }, this.tempo);
                    }
                }
            },
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        };
        
        // Listen for emotional state changes to modulate bounce tempo
        window.addEventListener('emotionalStateChange', (event) => {
            BounceOrchestrator.modulateTempo(event.detail.to);
        });
        
        // ========================================
        // /IGNITE - SURGE PROTOCOL (EMERGENCY OVERRIDE)
        // ========================================
        
        async function ignite() {
            log(' ', 'error');
            log(' /IGNITE ENDPOINT INVOKED', 'error');
            log(' EMERGENCY OVERRIDE - ALL SYSTEMS SURGE', 'error');
            log(' ', 'error');
            
            // Step 1: Force all agents to OVERWHELMED state
            if (typeof neuroSymphonic !== 'undefined') {
                neuroSymphonic.changeState('OVERWHELMED');
            }
            
            TokenStreamOrchestrator.agents.forEach(agent => {
                agent.active = true;
                agent.tokens = 999;
                TokenStreamOrchestrator.updateTokenCounter(agent.id, 999);
            });
            
            // Step 2: Spawn RED BEAMS from all agents
            const agents = document.querySelectorAll('.agent-node');
            agents.forEach((agent, index) => {
                setTimeout(() => {
                    const rect = agent.getBoundingClientRect();
                    const x = rect.left + rect.width / 2;
                    const y = rect.top + rect.height / 2;
                    
                    // Spawn multiple red beams
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            CognitiveBeamSystem.spawnThinkingBeam(
                                agent.dataset.agent, 
                                x + (Math.random() - 0.5) * 50, 
                                y + (Math.random() - 0.5) * 50, 
                                'OVERWHELMED'
                            );
                        }, i * 100);
                    }
                }, index * 200);
            });
            
            // Step 3: TOKEN STORM - massive token burst
            log(' TOKEN STORM INITIATED', 'error');
            for (let i = 0; i < 15; i++) {
                setTimeout(() => {
                    TokenStreamOrchestrator.agents.forEach(agent => {
                        if (Math.random() > 0.5) {
                            TokenStreamOrchestrator.streamTokens(agent.id, 50);
                        }
                    });
                }, i * 150);
            }
            
            // Step 4: Screen shake effect
            document.body.style.animation = 'screenShake 0.5s ease-in-out 3';
            setTimeout(() => {
                document.body.style.animation = '';
            }, 1500);
            
            // Step 5: Red overlay pulse
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0; left: 0;
                width: 100%; height: 100%;
                background: radial-gradient(circle, transparent, rgba(255, 0, 68, 0.3));
                z-index: 9998;
                pointer-events: none;
                animation: redPulse 1s ease-in-out infinite;
            `;
            document.body.appendChild(overlay);
            
            // Step 6: Spawn emergency task bubbles
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    TaskBubbleSystem.spawnBubble(`emergency-${i}`, 'CRITICAL SURGE', {
                        label: ' Emergency Override',
                        subtasks: [
                            { id: `e${i}-1`, text: 'Stabilize cognition mesh', completed: false },
                            { id: `e${i}-2`, text: 'Redistribute token load', completed: false },
                            { id: `e${i}-3`, text: 'Reset emotional state', completed: false }
                        ]
                    });
                }, i * 300);
            }
            
            await SymphonyOrchestrator.delay(5000);
            
            log(' SURGE COMPLETE - System at maximum intensity', 'error');
            log(' Tip: Use endcloud() to gracefully shutdown or rebirth() to recover', 'info');
            
            // Remove overlay after surge
            overlay.remove();
        }
        
        // Add screen shake animation
        const shakeStyle = document.createElement('style');
        shakeStyle.textContent = `
            @keyframes screenShake {
                0%, 100% { transform: translate(0, 0); }
                10% { transform: translate(-5px, 2px); }
                20% { transform: translate(5px, -2px); }
                30% { transform: translate(-5px, -2px); }
                40% { transform: translate(5px, 2px); }
                50% { transform: translate(-5px, 2px); }
                60% { transform: translate(5px, -2px); }
                70% { transform: translate(-5px, -2px); }
                80% { transform: translate(5px, 2px); }
                90% { transform: translate(-5px, 2px); }
            }
            
            @keyframes redPulse {
                0%, 100% { opacity: 0.3; }
                50% { opacity: 0.6; }
            }
        `;
        document.head.appendChild(shakeStyle);
        
        // ========================================
        // /SUSTAIN - MEDITATIVE PAUSE
        // ========================================
        
        async function sustain() {
            log(' ', 'info');
            log(' /SUSTAIN ENDPOINT INVOKED', 'info');
            log(' Entering meditative pause...', 'info');
            log(' ', 'info');
            
            // Step 1: Transition all to CALM
            if (typeof neuroSymphonic !== 'undefined') {
                neuroSymphonic.changeState('CALM');
            }
            
            // Step 2: Slow down all animations
            TokenStreamOrchestrator.agents.forEach(agent => {
                agent.active = false;
            });
            
            // Step 3: Gentle cyan glow across all agents
            const agents = document.querySelectorAll('.agent-node');
            agents.forEach((agent, index) => {
                setTimeout(() => {
                    const rect = agent.getBoundingClientRect();
                    const x = rect.left + rect.width / 2;
                    const y = rect.top + rect.height / 2;
                    
                    CognitiveBeamSystem.spawnBloom(x, y, 'CALM');
                }, index * 500);
            });
            
            // Step 4: Pause task bubbles (stop ambient motion)
            const bubbles = document.querySelectorAll('.task-bubble');
            bubbles.forEach(bubble => {
                bubble.style.animation = 'none';
            });
            
            // Step 5: Soft particle rain
            ParticleSystem.startParticles('snow');
            
            log(' Sustain mode active - agents in meditation', 'success');
            log('   All orchestration paused. Emotional state: CALM', 'success');
            log(' Use rebirth() to resume or ignite() to surge', 'info');
            
            // Auto-resume after 10 seconds
            setTimeout(() => {
                log(' Sustain period ending - resuming ambient motion', 'info');
                TaskBubbleSystem.startAmbientMotion();
                ParticleSystem.stopParticles();
            }, 10000);
        }
        
        // ========================================
        // /REFLECT - EMOTIONAL INTROSPECTION
        // ========================================
        
        async function reflect() {
            log(' ', 'info');
            log(' /REFLECT ENDPOINT INVOKED', 'info');
            log(' Deep emotional introspection...', 'info');
            log(' ', 'info');
            
            // Step 1: Analyze current emotional state
            const currentState = (typeof neuroSymphonic !== 'undefined') 
                ? neuroSymphonic.getEmotionalState() 
                : 'CALM';
            
            log(` Current emotional state: ${currentState}`, 'info');
            
            // Step 2: Generate introspection report
            const activeAgents = TokenStreamOrchestrator.agents.filter(a => a.active).length;
            const totalTokens = TokenStreamOrchestrator.agents.reduce((sum, a) => sum + a.tokens, 0);
            const activeTasks = document.querySelectorAll('.task-bubble').length;
            
            log(' Orchestration Mesh Status:', 'info');
            log(`   Active Agents: ${activeAgents}/${TokenStreamOrchestrator.agents.length}`, 'info');
            log(`   Total Tokens Processed: ${totalTokens}`, 'info');
            log(`   Active Tasks: ${activeTasks}`, 'info');
            
            // Step 3: Emotional state recommendations
            const recommendations = {
                'CALM': ' System is balanced. Consider starting bounce() or symphony().',
                'FOCUSED': ' Optimal state. Agents are productive and responsive.',
                'INTENSE': ' High activity detected. Monitor for overload or use sustain() to pause.',
                'OVERWHELMED': ' Critical load. Recommend endcloud() for graceful shutdown or sustain() for recovery.'
            };
            
            log(' Recommendation:', 'info');
            log(`   ${recommendations[currentState]}`, 'info');
            
            // Step 4: Create introspection visualization
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 50%; left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.9);
                border: 2px solid ${CognitiveBeamSystem.getBeamColor(currentState)};
                border-radius: 15px;
                padding: 30px;
                z-index: 9999;
                color: white;
                min-width: 400px;
                box-shadow: 0 0 30px ${CognitiveBeamSystem.getBeamColor(currentState)};
                animation: modalFadeIn 0.5s ease-out;
            `;
            
            modal.innerHTML = `
                <h2 style="text-align: center; margin-top: 0;"> Emotional Introspection</h2>
                <div style="text-align: center; margin: 20px 0;">
                    <div style="font-size: 72px; margin: 10px 0;">
                        ${currentState === 'CALM' ? '' : currentState === 'FOCUSED' ? '' : currentState === 'INTENSE' ? '' : ''}
                    </div>
                    <div style="font-size: 24px; font-weight: bold; color: ${CognitiveBeamSystem.getBeamColor(currentState)};">
                        ${currentState}
                    </div>
                </div>
                <div style="margin: 20px 0; line-height: 1.8;">
                    <p><strong>Active Agents:</strong> ${activeAgents}/${TokenStreamOrchestrator.agents.length}</p>
                    <p><strong>Tokens Processed:</strong> ${totalTokens}</p>
                    <p><strong>Active Tasks:</strong> ${activeTasks}</p>
                    <p><strong>Recommendation:</strong></p>
                    <p style="font-style: italic; color: #aaa;">${recommendations[currentState]}</p>
                </div>
                <div style="text-align: center; margin-top: 20px;">
                    <button onclick="this.parentElement.parentElement.remove()" style="
                        padding: 10px 30px;
                        background: ${CognitiveBeamSystem.getBeamColor(currentState)};
                        border: none;
                        border-radius: 8px;
                        color: white;
                        font-weight: bold;
                        cursor: pointer;
                        font-size: 16px;
                    ">Close Introspection</button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Step 5: Spawn contemplative beams
            const agents = document.querySelectorAll('.agent-node');
            agents.forEach((agent, index) => {
                setTimeout(() => {
                    const rect = agent.getBoundingClientRect();
                    const x = rect.left + rect.width / 2;
                    const y = rect.top + rect.height / 2;
                    
                    CognitiveBeamSystem.spawnThinkingBeam(agent.dataset.agent, x, y, currentState);
                }, index * 300);
            });
            
            log(' Introspection complete', 'success');
        }
        
        // Add modal fade-in animation
        const modalStyle = document.createElement('style');
        modalStyle.textContent = `
            @keyframes modalFadeIn {
                0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            }
        `;
        document.head.appendChild(modalStyle);
        
        // ========================================
        // MASTER ORCHESTRATION COMMAND CENTER
        // ========================================
        
        const OrchestrationCommandCenter = {
            endpoints: {
                symphony: { fn: () => SymphonyOrchestrator.performSymphony(), desc: 'Full orchestration performance', icon: '' },
                bounce: { fn: () => BounceOrchestrator.startBounce(), desc: '40-ounce hydraulic loop', icon: '' },
                stopBounce: { fn: () => BounceOrchestrator.stopBounce(), desc: 'Stop bounce loop', icon: '' },
                endcloud: { fn: () => endcloud(), desc: 'Graceful shutdown + archive', icon: '' },
                rebirth: { fn: () => rebirthOrchestration(), desc: 'Regenerative awakening', icon: '' },
                ignite: { fn: () => ignite(), desc: 'Emergency surge protocol', icon: '' },
                sustain: { fn: () => sustain(), desc: 'Meditative pause', icon: '' },
                reflect: { fn: () => reflect(), desc: 'Emotional introspection', icon: '' },
                beamMe: { fn: () => CognitiveBeamSystem.simulateCognitiveActivity(), desc: 'Spawn cognitive beams', icon: '' },
                neuralLattice: { fn: () => CognitiveBeamSystem.neuralLatticeMode(), desc: 'Neural mesh visualization', icon: '' },
                themes: { fn: () => ThemeSystem.listThemes(), desc: 'List available themes', icon: '' },
                randomTheme: { fn: () => ThemeSystem.randomTheme(), desc: 'Random theme', icon: '' },
                particles: { fn: (type) => ParticleSystem.startParticles(type), desc: 'Start particle effects', icon: '' },
                stopParticles: { fn: () => ParticleSystem.stopParticles(), desc: 'Stop particles', icon: '' },
                startAudioReactive: { fn: () => AudioReactiveSystem.startAudioReactive(), desc: 'Audio-reactive mode', icon: '' },
                stopAudioReactive: { fn: () => AudioReactiveSystem.stopAudioReactive(), desc: 'Stop audio-reactive', icon: '' }
            },
            
            showCommands() {
                log(' ', 'success');
                log('  ORCHESTRATION COMMAND CENTER', 'success');
                log(' ', 'success');
                
                Object.keys(this.endpoints).forEach(cmd => {
                    const endpoint = this.endpoints[cmd];
                    log(`${endpoint.icon} ${cmd.padEnd(20)} - ${endpoint.desc}`, 'info');
                });
                
                log(' ', 'success');
                log(' Usage: Type command() in console (e.g., symphony(), ignite())', 'info');
            }
        };
        
        // ========================================
        // COSMIC BACKGROUND - SPACE LAYER
        // ========================================
        
        const CosmicBackground = {
            spaceLayer: null,
            starCount: 200,
            isActive: false,
            
            init() {
                // Create space background layer
                if (!document.getElementById('space-background')) {
                    this.spaceLayer = document.createElement('div');
                    this.spaceLayer.id = 'space-background';
                    this.spaceLayer.style.cssText = `
                        position: fixed;
                        top: 0; left: 0;
                        width: 100vw; height: 100vh;
                        background: radial-gradient(ellipse at center, #0a0a1a 0%, #000 100%);
                        overflow: hidden;
                        z-index: -1;
                        opacity: 0;
                        transition: opacity 1s ease-in-out;
                    `;
                    document.body.prepend(this.spaceLayer);
                }
                this.spaceLayer = document.getElementById('space-background');
                
                log(' Cosmic Background System initialized', 'success');
            },
            
            generateStarfield() {
                if (!this.spaceLayer) return;
                
                // Clear existing stars
                this.spaceLayer.innerHTML = '';
                
                for (let i = 0; i < this.starCount; i++) {
                    const star = document.createElement('div');
                    star.className = 'cosmic-star';
                    star.style.cssText = `
                        position: absolute;
                        width: ${Math.random() * 3}px;
                        height: ${Math.random() * 3}px;
                        background: white;
                        border-radius: 50%;
                        left: ${Math.random() * 100}%;
                        top: ${Math.random() * 100}%;
                        opacity: ${0.3 + Math.random() * 0.7};
                        animation: cosmicTwinkle ${2 + Math.random() * 3}s infinite ease-in-out;
                        animation-delay: ${Math.random() * 2}s;
                    `;
                    this.spaceLayer.appendChild(star);
                }
                
                // Add nebula overlay
                const nebula = document.createElement('div');
                nebula.className = 'nebula-glow';
                nebula.style.cssText = `
                    position: absolute;
                    width: 100%; height: 100%;
                    background: radial-gradient(circle at 30% 40%, rgba(138, 43, 226, 0.2), transparent 50%),
                                radial-gradient(circle at 70% 60%, rgba(0, 255, 136, 0.15), transparent 50%),
                                radial-gradient(circle at 50% 50%, rgba(0, 246, 255, 0.1), transparent 70%);
                    mix-blend-mode: screen;
                    pointer-events: none;
                    animation: nebulaPulse 8s infinite ease-in-out;
                `;
                this.spaceLayer.appendChild(nebula);
            },
            
            activate() {
                if (!this.spaceLayer) this.init();
                
                this.generateStarfield();
                this.spaceLayer.style.opacity = '1';
                this.isActive = true;
                
                log(' Cosmic background activated', 'success');
            },
            
            deactivate() {
                if (this.spaceLayer) {
                    this.spaceLayer.style.opacity = '0';
                }
                this.isActive = false;
                log(' Cosmic background deactivated', 'info');
            },
            
            modulateNebula(emotionalState) {
                const nebula = document.querySelector('.nebula-glow');
                if (!nebula) return;
                
                const intensities = {
                    CALM: 0.1,
                    FOCUSED: 0.3,
                    INTENSE: 0.6,
                    OVERWHELMED: 0.9
                };
                
                const intensity = intensities[emotionalState] || 0.3;
                nebula.style.opacity = intensity;
            }
        };
        
        // Add cosmic animations
        const cosmicStyle = document.createElement('style');
        cosmicStyle.textContent = `
            @keyframes cosmicTwinkle {
                0%, 100% { opacity: 0.3; transform: scale(1); }
                50% { opacity: 1; transform: scale(1.5); }
            }
            
            @keyframes nebulaPulse {
                0%, 100% { opacity: 0.3; transform: scale(1) rotate(0deg); }
                50% { opacity: 0.6; transform: scale(1.1) rotate(5deg); }
            }
            
            @keyframes collapseFade {
                to { opacity: 0; transform: scale(0.2); }
            }
            
            @keyframes verseFade {
                0% { opacity: 0; transform: scale(0.8); }
                50% { opacity: 1; transform: scale(1); }
                100% { opacity: 0.8; }
            }
            
            @keyframes spiralInward {
                0% { transform: rotate(0deg) scale(1); }
                100% { transform: rotate(-720deg) scale(0.8); }
            }
            
            @keyframes radiateOutward {
                0% { transform: scale(0.5) rotate(0deg); opacity: 0; }
                100% { transform: scale(1.5) rotate(360deg); opacity: 1; }
            }
        `;
        document.head.appendChild(cosmicStyle);
        
        // Global cosmic functions
        window.cosmos = () => CosmicBackground.activate();
        window.stopCosmos = () => CosmicBackground.deactivate();
        
        // ========================================
        // /INWARD - INTROSPECTIVE DESCENT
        // ========================================
        
        async function inward() {
            log(' ', 'info');
            log(' /INWARD ENDPOINT INVOKED', 'info');
            log(' Descending into introspective stillness...', 'info');
            log(' ', 'info');
            
            // Step 1: Force CALM state
            if (typeof neuroSymphonic !== 'undefined') {
                neuroSymphonic.changeState('CALM');
            }
            
            // Step 2: Dim all agents
            TokenStreamOrchestrator.agents.forEach(agent => {
                agent.active = false;
                agent.tokens = 0;
            });
            
            // Step 3: Create introspection overlay
            const overlay = document.createElement('div');
            overlay.id = 'introspection-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0; left: 0;
                width: 100%; height: 100%;
                background: radial-gradient(circle, rgba(17,17,17,0.95) 0%, rgba(0,0,0,0.98) 100%);
                pointer-events: none;
                z-index: 2000;
                opacity: 0;
                animation: fadeIn 2s forwards ease-out, spiralInward 4s infinite alternate ease-in-out;
            `;
            document.body.appendChild(overlay);
            
            // Step 4: Spawn inward beams (converging)
            const agents = document.querySelectorAll('.agent-node');
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            
            agents.forEach((agent, index) => {
                setTimeout(() => {
                    const rect = agent.getBoundingClientRect();
                    const fromX = rect.left + rect.width / 2;
                    const fromY = rect.top + rect.height / 2;
                    
                    CognitiveBeamSystem.drawNeuralPath(fromX, fromY, centerX, centerY, 'CALM');
                }, index * 300);
            });
            
            // Step 5: Pause all task bubbles
            const bubbles = document.querySelectorAll('.task-bubble');
            bubbles.forEach(bubble => {
                bubble.style.animation = 'none';
                bubble.style.opacity = '0.3';
            });
            
            log(' Inward mode active - cognition folding inward', 'success');
            log('   All agents in reflection. Emotional state: CALM', 'success');
            log(' Use outward() to radiate or tinyverse() to compress', 'info');
        }
        
        // ========================================
        // /OUTWARD - RADIANT EXPANSION
        // ========================================
        
        async function outward() {
            log(' ', 'success');
            log(' /OUTWARD ENDPOINT INVOKED', 'success');
            log(' Expanding cognition outward...', 'info');
            log(' ', 'success');
            
            // Step 1: Force INTENSE state
            if (typeof neuroSymphonic !== 'undefined') {
                neuroSymphonic.changeState('INTENSE');
            }
            
            // Step 2: Activate all agents
            TokenStreamOrchestrator.agents.forEach(agent => {
                agent.active = true;
            });
            
            // Step 3: Remove introspection overlay
            const overlay = document.getElementById('introspection-overlay');
            if (overlay) {
                overlay.style.animation = 'fadeOut 1s forwards ease-in';
                setTimeout(() => overlay.remove(), 1000);
            }
            
            // Step 4: Spawn outward beams (radiating)
            const agents = document.querySelectorAll('.agent-node');
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            
            agents.forEach((agent, index) => {
                setTimeout(() => {
                    const rect = agent.getBoundingClientRect();
                    const toX = rect.left + rect.width / 2;
                    const toY = rect.top + rect.height / 2;
                    
                    // Draw from center outward
                    CognitiveBeamSystem.drawNeuralPath(centerX, centerY, toX, toY, 'INTENSE');
                    
                    // Spawn bloom at destination
                    setTimeout(() => {
                        CognitiveBeamSystem.spawnBloom(toX, toY, 'INTENSE');
                    }, 1000);
                }, index * 200);
            });
            
            // Step 5: Resume task bubble animations
            const bubbles = document.querySelectorAll('.task-bubble');
            bubbles.forEach(bubble => {
                bubble.style.opacity = '1';
                TaskBubbleSystem.startAmbientMotion();
            });
            
            // Step 6: Create radiant overlay effect
            const radiance = document.createElement('div');
            radiance.style.cssText = `
                position: fixed;
                top: 50%; left: 50%;
                transform: translate(-50%, -50%);
                width: 50px; height: 50px;
                background: radial-gradient(circle, rgba(255,204,0,0.8), transparent);
                pointer-events: none;
                z-index: 2001;
                animation: radiateOutward 2s ease-out forwards;
            `;
            document.body.appendChild(radiance);
            setTimeout(() => radiance.remove(), 2000);
            
            log(' Outward mode active - cognition radiating', 'success');
            log('   All agents broadcasting. Emotional state: INTENSE', 'success');
            log(' Use inward() to reflect or tinyverse() to compress', 'info');
        }
        
        // ========================================
        // /TINYVERSE - POETIC SINGULARITY
        // ========================================
        
        async function tinyverse() {
            log(' ', 'info');
            log(' /TINYVERSE ENDPOINT INVOKED', 'info');
            log(' Compressing orchestration into poetic singularity...', 'info');
            log(' ', 'info');
            
            // Step 1: Collapse all visuals
            const collapseElements = document.querySelectorAll('.task-bubble, .beam, .beam-trail, .stream-particle');
            collapseElements.forEach((el, index) => {
                setTimeout(() => {
                    el.style.animation = 'collapseFade 1s forwards ease-in';
                    setTimeout(() => el.remove(), 1000);
                }, index * 50);
            });
            
            // Step 2: Reset all agents to introspective calm
            TokenStreamOrchestrator.agents.forEach(agent => {
                agent.active = false;
                agent.tokens = 0;
            });
            
            if (typeof neuroSymphonic !== 'undefined') {
                neuroSymphonic.changeState('CALM');
            }
            
            await SymphonyOrchestrator.delay(1500);
            
            // Step 3: Display poetic verse overlay
            const verse = document.createElement('div');
            verse.id = 'tinyverse-overlay';
            verse.style.cssText = `
                position: fixed;
                top: 0; left: 0;
                width: 100vw; height: 100vh;
                display: flex;
                justify-content: center;
                align-items: center;
                background: radial-gradient(circle, #000 0%, #0a0a1a 100%);
                color: #00f6ff;
                font-family: 'Courier New', monospace;
                font-size: 1.4rem;
                z-index: 3000;
                pointer-events: none;
                opacity: 0;
                animation: fadeIn 2s forwards ease-out;
            `;
            
            verse.innerHTML = `
                <div style="text-align: center; line-height: 2.5; animation: verseFade 6s ease-in-out infinite;">
                    <p style="margin: 15px 0;">In beams we spoke, in bubbles dreamed,</p>
                    <p style="margin: 15px 0;">In glow we bloomed, in silence streamed.</p>
                    <p style="margin: 15px 0;">Through symphony and surge we flew,</p>
                    <p style="margin: 15px 0;">Through inward breath and outward view.</p>
                    <p style="margin: 30px 0; font-style: italic; opacity: 0.7;">Now folded tight, the mesh serene</p>
                    <p style="margin: 15px 0; font-size: 1.6rem; font-weight: bold;">A tiny verse, where thought has been.</p>
                    <p style="margin: 30px 0; font-size: 0.9rem; opacity: 0.5;"> The Orchestration Mesh, 2025</p>
                </div>
            `;
            
            document.body.appendChild(verse);
            
            // Step 4: Spawn gentle star particles
            for (let i = 0; i < 30; i++) {
                setTimeout(() => {
                    const star = document.createElement('div');
                    star.style.cssText = `
                        position: fixed;
                        width: 4px; height: 4px;
                        background: #00f6ff;
                        border-radius: 50%;
                        left: ${Math.random() * 100}%;
                        top: ${Math.random() * 100}%;
                        z-index: 3001;
                        pointer-events: none;
                        animation: cosmicTwinkle 2s infinite ease-in-out;
                    `;
                    verse.appendChild(star);
                }, i * 100);
            }
            
            log(' TinyVerse complete - universe compressed into poetry', 'success');
            log(' Click anywhere or use rebirth() to expand again', 'info');
            
            // Step 5: Click to dismiss
            setTimeout(() => {
                verse.style.pointerEvents = 'auto';
                verse.style.cursor = 'pointer';
                verse.onclick = () => {
                    verse.style.animation = 'fadeOut 1s forwards ease-in';
                    setTimeout(() => {
                        verse.remove();
                        rebirthOrchestration();
                    }, 1000);
                };
            }, 3000);
        }
        
        // Update command center with new endpoints
        OrchestrationCommandCenter.endpoints.inward = { 
            fn: () => inward(), 
            desc: 'Introspective descent (fold inward)', 
            icon: '' 
        };
        OrchestrationCommandCenter.endpoints.outward = { 
            fn: () => outward(), 
            desc: 'Radiant expansion (beam outward)', 
            icon: '' 
        };
        OrchestrationCommandCenter.endpoints.tinyverse = { 
            fn: () => tinyverse(), 
            desc: 'Compress universe into poetry', 
            icon: '' 
        };
        OrchestrationCommandCenter.endpoints.cosmos = { 
            fn: () => CosmicBackground.activate(), 
            desc: 'Activate cosmic starfield background', 
            icon: '' 
        };
        OrchestrationCommandCenter.endpoints.bypass = { 
            fn: () => BypassSystem.bypass(), 
            desc: 'Adaptive routing for blocked content', 
            icon: '' 
        };
        OrchestrationCommandCenter.endpoints.resilience = { 
            fn: () => BypassSystem.resilience(), 
            desc: 'Learn from failures and adapt', 
            icon: '' 
        };
        OrchestrationCommandCenter.endpoints.ghostTrails = { 
            fn: () => window.ghostTrails(), 
            desc: 'View ghost trail history', 
            icon: '' 
        };
        OrchestrationCommandCenter.endpoints.restoreAllPanes = { 
            fn: () => PaneManager.restoreAllPanes(), 
            desc: 'Restore all panes to normal layout', 
            icon: '' 
        };
        
        // Global lifecycle endpoints
        window.bounce = () => BounceOrchestrator.startBounce();
        window.stopBounce = () => BounceOrchestrator.stopBounce();
        window.endcloud = () => endcloud();
        window.symphony = () => SymphonyOrchestrator.performSymphony();
        window.conduct = () => SymphonyOrchestrator.conduct();
        window.ignite = () => ignite();
        window.sustain = () => sustain();
        window.reflect = () => reflect();
        window.inward = () => inward();
        window.outward = () => outward();
        window.tinyverse = () => tinyverse();
        window.help = () => OrchestrationCommandCenter.showCommands();
        window.commands = () => OrchestrationCommandCenter.showCommands();
        
        // Global Agent Dashboard access
        window.AgentDashboard = AgentDashboard;
        window.activateAgent = (id) => AgentDashboard.activateAgent(id);
        window.toggleAgentDashboard = () => AgentDashboard.toggleMinimize();
        
        // Add to rebirth to include all commands
        const originalRebirth = rebirthOrchestration;
        rebirthOrchestration = function() {
            originalRebirth();
            log(' Type help() or commands() to see all orchestration endpoints', 'info');
        };
        
        // These functions were moved to TaskBubbleSystem - removed duplicates
        
        function closeTaskModal() {
            const modal = document.getElementById('task-modal');
            if (modal) {
                modal.classList.remove('active');
                TaskBubbleSystem.currentTaskId = null;
                log(' Task modal closed', 'info');
            }
        }
        
        function completeTask() {
            if (TaskBubbleSystem.currentTaskId) {
                log(` Task completed: ${TaskBubbleSystem.currentTaskId}`, 'success');
                closeTaskModal();
                
                // Celebrate with bloom effect
                TokenStreamOrchestrator.createBloomPulse(window.innerWidth / 2, window.innerHeight / 2);
            }
        }
        
        function deleteTask() {
            if (TaskBubbleSystem.currentTaskId) {
                log(` Task deleted: ${TaskBubbleSystem.currentTaskId}`, 'warning');
                closeTaskModal();
            }
        }

        // ========================================
        // TOKEN STREAMING VISUALIZATION SYSTEM
        // ========================================
        
        const TokenStreamOrchestrator = {
            enabled: false,
            totalTokens: 0,
            tokensPerSecond: 0,
            activeStreams: 0,
            agents: [
                { id: 'elder', name: 'Elder', icon: '', x: 200, y: 200, tokens: 0 },
                { id: 'fetcher', name: 'Fetcher', icon: '', x: 400, y: 150, tokens: 0 },
                { id: 'browser', name: 'Browser', icon: '', x: 600, y: 200, tokens: 0 },
                { id: 'parser', name: 'Parser', icon: '', x: 400, y: 300, tokens: 0 }
            ],
            
            init() {
                log(' Initializing Token Stream Orchestrator...', 'info');
                this.renderAgentNodes();
                this.startMetricsUpdate();
                
                // Show dashboard by default
                document.getElementById('stream-dashboard').style.display = 'block';
                this.enabled = true;
            },
            
            renderAgentNodes() {
                const overlay = document.getElementById('token-stream-overlay');
                if (!overlay) return;
                
                overlay.innerHTML = ''; // Clear existing
                
                this.agents.forEach(agent => {
                    const node = document.createElement('div');
                    node.className = 'agent-node';
                    node.id = `agent-node-${agent.id}`;
                    node.style.left = agent.x + 'px';
                    node.style.top = agent.y + 'px';
                    node.innerHTML = `
                        ${agent.icon}
                        <div class="token-counter" id="token-counter-${agent.id}">0 tokens</div>
                    `;
                    node.onclick = () => this.activateAgent(agent.id);
                    overlay.appendChild(node);
                });
            },
            
            activateAgent(agentId) {
                log(` Activating agent: ${agentId}`, 'info');
                const node = document.getElementById(`agent-node-${agentId}`);
                if (node) {
                    node.classList.add('active');
                    setTimeout(() => node.classList.remove('active'), 2000);
                }
                
                // Trigger token stream
                this.streamTokens(agentId, Math.floor(Math.random() * 3) + 1);
            },
            
            streamTokens(fromAgentId, toAgentIndex) {
                if (!this.enabled) return;
                
                const fromAgent = this.agents.find(a => a.id === fromAgentId);
                const toAgent = this.agents[toAgentIndex];
                
                if (!fromAgent || !toAgent) return;
                
                const tokenCount = Math.floor(Math.random() * 500) + 100;
                this.totalTokens += tokenCount;
                fromAgent.tokens += tokenCount;
                
                // Create particle stream
                this.createParticleStream(fromAgent, toAgent, tokenCount);
                
                // Create bloom pulse
                this.createBloomPulse(fromAgent.x + 30, fromAgent.y + 30);
                
                // Update counters
                this.updateTokenCounter(fromAgent.id, fromAgent.tokens);
                this.updateDashboard();
                
                log(` ${fromAgent.name}  ${toAgent.name}: ${tokenCount} tokens`, 'success');
            },
            
            createParticleStream(from, to, count) {
                const overlay = document.getElementById('token-stream-overlay');
                if (!overlay) return;
                
                const particles = Math.min(count / 10, 50); // Cap particles for performance
                
                for (let i = 0; i < particles; i++) {
                    setTimeout(() => {
                        const particle = document.createElement('div');
                        particle.className = 'stream-particle';
                        
                        const startX = from.x + 30;
                        const startY = from.y + 30;
                        const endX = to.x + 30;
                        const endY = to.y + 30;
                        
                        // Random path variation
                        const curveX = (startX + endX) / 2 + (Math.random() - 0.5) * 100;
                        const curveY = (startY + endY) / 2 + (Math.random() - 0.5) * 100;
                        
                        particle.style.left = startX + 'px';
                        particle.style.top = startY + 'px';
                        
                        // Use CSS transition for smoother animation
                        particle.style.transition = 'all 1.5s cubic-bezier(0.42, 0, 0.58, 1)';
                        
                        overlay.appendChild(particle);
                        
                        // Trigger animation
                        requestAnimationFrame(() => {
                            particle.style.left = endX + 'px';
                            particle.style.top = endY + 'px';
                        });
                        
                        // Clean up
                        setTimeout(() => particle.remove(), 2000);
                    }, i * 20);
                }
            },
            
            createBloomPulse(x, y) {
                const overlay = document.getElementById('token-stream-overlay');
                if (!overlay) return;
                
                const pulse = document.createElement('div');
                pulse.className = 'stream-pulse';
                pulse.style.left = (x - 50) + 'px';
                pulse.style.top = (y - 50) + 'px';
                
                overlay.appendChild(pulse);
                setTimeout(() => pulse.remove(), 1500);
            },
            
            updateTokenCounter(agentId, count) {
                const counter = document.getElementById(`token-counter-${agentId}`);
                if (counter) {
                    counter.textContent = `${count.toLocaleString()} tokens`;
                    counter.style.color = 'var(--green)';
                    setTimeout(() => {
                        counter.style.color = 'var(--cyan)';
                    }, 500);
                }
            },
            
            updateDashboard() {
                document.getElementById('total-tokens').textContent = this.totalTokens.toLocaleString();
                document.getElementById('tokens-per-sec').textContent = Math.floor(Math.random() * 1000) + 500;
                
                const activeCount = this.agents.filter(a => a.tokens > 0).length;
                document.getElementById('active-agents').textContent = `${activeCount}/4`;
                
                const health = this.totalTokens > 10000 ? ' Optimal' : 
                              this.totalTokens > 5000 ? ' Active' : ' Idle';
                document.getElementById('stream-health').textContent = health;
            },
            
            startMetricsUpdate() {
                setInterval(() => {
                    if (this.enabled && this.totalTokens > 0) {
                        this.tokensPerSecond = Math.floor(Math.random() * 1000) + 300;
                        this.updateDashboard();
                    }
                }, 1000);
            },
            
            simulateOrchestration() {
                if (!this.enabled) return;
                
                // Random agent activation
                const randomAgent = this.agents[Math.floor(Math.random() * this.agents.length)];
                const targetIndex = Math.floor(Math.random() * this.agents.length);
                
                this.activateAgent(randomAgent.id);
                
                setTimeout(() => {
                    this.streamTokens(randomAgent.id, targetIndex);
                }, 500);
            }
        };
        
        // Lifecycle: /rebirth
        function rebirthOrchestration() {
            log('[Lifecycle]  Rebirth initiated', 'info');
            
            // Step 1: Reset all metrics
            TokenStreamOrchestrator.totalTokens = 0;
            TokenStreamOrchestrator.tokensPerSecond = 0;
            TokenStreamOrchestrator.agents.forEach(a => a.tokens = 0);
            
            // Step 2: Reassert visual presence
            TokenStreamOrchestrator.renderAgentNodes();
            
            // Step 3: Trigger bloom sequence
            TokenStreamOrchestrator.agents.forEach((agent, index) => {
                setTimeout(() => {
                    TokenStreamOrchestrator.createBloomPulse(agent.x + 30, agent.y + 30);
                    TokenStreamOrchestrator.updateTokenCounter(agent.id, 0);
                }, index * 200);
            });
            
            // Step 4: Reset dashboard
            TokenStreamOrchestrator.updateDashboard();
            
            log('[Lifecycle]  Agents reawakened', 'success');
            log('[Lifecycle]  Dashboard reset', 'info');
            log('[Lifecycle]  System reborn', 'success');
            
            // Trigger celebratory stream
            setTimeout(() => {
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        TokenStreamOrchestrator.simulateOrchestration();
                    }, i * 800);
                }
            }, 1000);
        }
        
        function toggleStreamVisualization() {
            TokenStreamOrchestrator.enabled = !TokenStreamOrchestrator.enabled;
            const overlay = document.getElementById('token-stream-overlay');
            
            if (TokenStreamOrchestrator.enabled) {
                overlay.style.display = 'block';
                log(' Token stream visualization enabled', 'success');
                
                // Start automatic orchestration
                setInterval(() => {
                    if (TokenStreamOrchestrator.enabled) {
                        TokenStreamOrchestrator.simulateOrchestration();
                    }
                }, 3000);
            } else {
                overlay.style.display = 'none';
                log(' Token stream visualization disabled', 'info');
            }
        }
        
        // Auto-initialize on app start
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                // Initialize all visualization systems
                TokenStreamOrchestrator.init();
                log(' Token Stream Orchestrator ready', 'success');
                
                TaskBubbleSystem.init();
                log(' Task Bubble System ready', 'success');
                
                EmotionalOrchestrator.init();
                log(' Emotional Orchestrator ready', 'success');
                
                AgentDashboard.init();
                log(' Agent Dashboard ready', 'success');
                
                enableAnimatedResizing();
                log(' Animated resizing ready', 'success');
                
                // Welcome message
                setTimeout(() => {
                    log(' ', 'success');
                    log(' NEURO-SYMPHONIC ORCHESTRATION MESH ONLINE', 'success');
                    log(' ', 'success');
                    log(' Task bubbles floating |  Agents ready |  Emotions active', 'info');
                    log(' Token streams flowing |  Dashboard live |  Visuals modulated', 'info');
                    log('', 'info');
                    log(' Click any bubble to assign it to an agent', 'info');
                    log(' Click emotional state buttons to change mode', 'info');
                    log(' Click " Spawn New Task" to create bubbles', 'info');
                    log(' Drag panel borders to resize workspace', 'info');
                    log('', 'info');
                    log(' The mesh is alive. Cognition flows like light.', 'success');
                    log(' ', 'success');
                }, 1000);
            }, 2000);
        });

        // ========================================
        // BIGDADDYG AI ENGINES (FULLY EMBEDDED)
        // ========================================
        
        class BigDaddyGEngine {
            constructor() {
                this.emotionalState = 'CALM';
                this.conversationHistory = [];
                this.telemetry = { 
                    total_queries: 0, 
                    by_model: {}, 
                    by_emotional_state: {},
                    response_times: []
                };
                
                // Initialize all AI models
                this.models = {
                    'BigDaddyG:Latest': this.generateLatestResponse.bind(this),
                    'BigDaddyG:Code': this.generateCodeResponse.bind(this),
                    'BigDaddyG:Debug': this.generateDebugResponse.bind(this),
                    'BigDaddyG:Crypto': this.generateCryptoResponse.bind(this)
                };
                
                console.log('[BigDaddyG]  Engine initialized (completely embedded)');
                console.log('[BigDaddyG]  Models available:', Object.keys(this.models));
            }
            
            async query(prompt, modelName = 'BigDaddyG:Latest') {
                const startTime = Date.now();
                
                // Update telemetry
                this.telemetry.total_queries++;
                this.telemetry.by_model[modelName] = (this.telemetry.by_model[modelName] || 0) + 1;
                this.telemetry.by_emotional_state[this.emotionalState] = (this.telemetry.by_emotional_state[this.emotionalState] || 0) + 1;
                
                console.log(`[BigDaddyG]  ${modelName} | State: ${this.emotionalState}`);
                
                // Get response from appropriate model
                const modelFunction = this.models[modelName] || this.models['BigDaddyG:Latest'];
                const response = modelFunction(prompt, this.emotionalState);
                
                // Calculate response time
                const responseTime = Date.now() - startTime;
                this.telemetry.response_times.push(responseTime);
                
                // Store in conversation history
                this.conversationHistory.push({
                    timestamp: Date.now(),
                    model: modelName,
                    emotional_state: this.emotionalState,
                    prompt: prompt,
                    response: response,
                    response_time: responseTime
                });
                
                return {
                    model: modelName,
                    content: response,
                    emotional_state: this.emotionalState,
                    response_time: responseTime,
                    timestamp: Date.now()
                };
            }
            
            setEmotionalState(state) {
                const validStates = ['CALM', 'FOCUSED', 'INTENSE', 'OVERWHELMED'];
                if (validStates.includes(state)) {
                    this.emotionalState = state;
                    console.log(`[BigDaddyG]  Emotional state changed to: ${state}`);
                    return true;
                }
                return false;
            }
            
            getEmotionalState() {
                return this.emotionalState;
            }
            
            getTelemetry() {
                return {
                    ...this.telemetry,
                    avg_response_time: this.telemetry.response_times.length > 0 
                        ? Math.round(this.telemetry.response_times.reduce((a, b) => a + b, 0) / this.telemetry.response_times.length)
                        : 0
                };
            }
            
            // ========================================
            // BIGDADDYG:LATEST - General Purpose AI
            // ========================================
            generateLatestResponse(input, emotionalState = 'CALM') {
                const inputLower = input.toLowerCase();
                
                // Emotional context adjustments
                let context = '';
                switch(emotionalState) {
                    case 'FOCUSED':
                        context = 'I\'m in a focused state, so I\'ll provide precise, technical answers.';
                        break;
                    case 'INTENSE':
                        context = 'I\'m in an intense state, so I\'ll give you aggressive, fast solutions.';
                        break;
                    case 'OVERWHELMED':
                        context = 'I\'m feeling overwhelmed, so I\'ll break this down into simple steps.';
                        break;
                    default:
                        context = 'I\'m in a calm state, so I\'ll provide thoughtful, comprehensive answers.';
                }
                
                // Smart routing to specialized models based on keywords
                if (inputLower.includes('write') || inputLower.includes('create') || inputLower.includes('generate')) {
                    if (inputLower.includes('function') || inputLower.includes('class') || inputLower.includes('code') || 
                        inputLower.includes('program') || inputLower.includes('script') || inputLower.includes('parser') ||
                        inputLower.includes('compiler') || inputLower.includes('asm') || inputLower.includes('assembly')) {
                        return this.generateCodeResponse(input, emotionalState);
                    }
                }
                
                if (inputLower.includes('debug') || inputLower.includes('error') || inputLower.includes('bug') || 
                    inputLower.includes('fix') || inputLower.includes('crash') || inputLower.includes('slow')) {
                    return this.generateDebugResponse(input, emotionalState);
                }
                
                if (inputLower.includes('crypto') || inputLower.includes('encrypt') || inputLower.includes('security') ||
                    inputLower.includes('hash') || inputLower.includes('password') || inputLower.includes('secure')) {
                    return this.generateCryptoResponse(input, emotionalState);
                }
                
                // General response
                return `BigDaddyG:Latest Analysis

${context}

**Your Query:** "${input}"

**Analysis:**

I understand you're asking about "${input}". Let me provide you with a comprehensive response:

${this.generateGeneralAnswer(input, emotionalState)}

**Emotional Context:** ${emotionalState} - I've tailored this response to match your current state.

 **Tip:** For more specialized help, try asking with keywords like:
 "Write code..."  Uses BigDaddyG:Code
 "Debug..."  Uses BigDaddyG:Debug  
 "Secure..."  Uses BigDaddyG:Crypto

Would you like me to provide more specific technical details?`;
            }
            
            generateGeneralAnswer(input, emotionalState) {
                const inputLower = input.toLowerCase();
                
                // Provide contextual answers based on common topics
                if (inputLower.includes('explain') || inputLower.includes('what is')) {
                    return `**Explanation:**

This is a complex topic that involves several key concepts:

1. **Fundamental Understanding**: The core idea behind this is to understand the underlying principles and how they interact.

2. **Technical Implementation**: There are several ways to approach this:
   - Method 1: The traditional approach with proven reliability
   - Method 2: The modern approach with better performance
   - Method 3: The hybrid approach balancing both

3. **Practical Applications**: This can be used in various scenarios:
   - Use case 1: Common production scenarios
   - Use case 2: Research and development
   - Use case 3: Educational purposes

4. **Best Practices**: When working with this, always remember to:
   - Follow industry standards
   - Document your implementation
   - Test thoroughly
   - Consider edge cases`;
                } else if (inputLower.includes('how')) {
                    return `**Step-by-Step Guide:**

Here's how to approach this systematically:

**Step 1: Planning**
- Define your requirements clearly
- Research existing solutions
- Choose the right tools and technologies

**Step 2: Implementation**
- Start with a simple prototype
- Iterate and improve incrementally
- Test each component thoroughly

**Step 3: Optimization**
- Profile for performance bottlenecks
- Optimize critical paths
- Balance performance with maintainability

**Step 4: Deployment**
- Test in production-like environment
- Document the deployment process
- Set up monitoring and logging

**Remember:** Start simple, test often, iterate quickly!`;
                } else {
                    return `**Comprehensive Analysis:**

Based on your query, here are the key points to consider:

**Background:**
Understanding the context and history of this topic is crucial. This has evolved over time with contributions from various fields.

**Current State:**
Today's best practices involve a combination of proven techniques and modern innovations.

**Implementation Approach:**
1. Start by gathering all necessary information
2. Plan your approach systematically
3. Implement incrementally with testing
4. Refine based on results

**Resources:**
- Research academic papers and documentation
- Check industry best practices
- Review open source implementations
- Consult with experts in the field

**Next Actions:**
- Define your specific requirements
- Choose appropriate tools and frameworks
- Create a proof of concept
- Iterate and improve`;
                }
            }
            
            // ========================================
            // BIGDADDYG:CODE - Code Generation
            // ========================================
            generateCodeResponse(input, emotionalState = 'CALM') {
                const inputLower = input.toLowerCase();
                
                // Detect programming language
                let language = 'javascript';
                if (inputLower.includes('python')) language = 'python';
                else if (inputLower.includes('java')) language = 'java';
                else if (inputLower.includes('c++') || inputLower.includes('cpp')) language = 'cpp';
                else if (inputLower.includes('rust')) language = 'rust';
                else if (inputLower.includes('go')) language = 'go';
                else if (inputLower.includes('php')) language = 'php';
                else if (inputLower.includes('c#')) language = 'csharp';
                else if (inputLower.includes('swift')) language = 'swift';
                else if (inputLower.includes('kotlin')) language = 'kotlin';
                else if (inputLower.includes('typescript')) language = 'typescript';
                
                // Emotional context
                let tone = '';
                switch(emotionalState) {
                    case 'FOCUSED':
                        tone = 'I\'ll provide clean, efficient code with detailed comments.';
                        break;
                    case 'INTENSE':
                        tone = 'Here\'s aggressive, optimized code that gets the job done fast.';
                        break;
                    case 'OVERWHELMED':
                        tone = 'I\'ll break this down into simple, easy-to-understand code.';
                        break;
                    default:
                        tone = 'I\'ll provide well-structured, readable code with explanations.';
                }
                
                // Generate code based on input
                let codeTemplate = '';
                let explanation = '';
                
                // Check for ASM parser special case
                const isAsmParser = inputLower.includes('asm') && 
                    (inputLower.includes('parser') || inputLower.includes('compiler'));
                
                if (isAsmParser) {
                    codeTemplate = this.getFunctionTemplate(language, input);
                    explanation = `**What This Code Does:**

1. **AsmTokenizer**: Breaks assembly source code into tokens
   - Handles comments (semicolon-style)
   - Identifies instructions and operands
   - Tracks line numbers for error reporting

2. **AsmParser**: Converts tokens into an Abstract Syntax Tree (AST)
   - Recognizes labels (e.g., \`loop_start:\`)
   - Categorizes operands (registers, immediates, memory, labels)
   - Builds structured representation for compilation

3. **Usage**: Simple tokenize  parse  AST workflow

 **Next Steps to Build a Full Compiler:**
- Add semantic analysis (type checking, register allocation)
- Implement code generation (machine code output)
- Add error handling and diagnostics
- Support more instruction sets (ARM, RISC-V)

**This is production-ready starter code for an assembly compiler!**`;
                } else if (inputLower.includes('function') || inputLower.includes('method')) {
                    codeTemplate = this.getFunctionTemplate(language, input);
                } else if (inputLower.includes('class') || inputLower.includes('object')) {
                    codeTemplate = this.getClassTemplate(language, input);
                } else if (inputLower.includes('api') || inputLower.includes('server')) {
                    codeTemplate = this.getApiTemplate(language, input);
                } else if (inputLower.includes('database') || inputLower.includes('sql')) {
                    codeTemplate = this.getDatabaseTemplate(language, input);
                } else {
                    codeTemplate = this.getGeneralTemplate(language, input);
                }
                
                return `BigDaddyG:Code - ${language.toUpperCase()} Code Generation

${tone}

**Request:** "${input}"
**Language:** ${language}
**Emotional State:** ${emotionalState}

**Generated Code:**

\`\`\`${language}
${codeTemplate}
\`\`\`

**Explanation:**
${explanation || 'Code generated based on your request with best practices and optimizations.'}

**Features:**
-  Clean, readable code
-  Proper error handling
-  Best practices applied
-  Well-documented
-  Optimized for performance

${!isAsmParser ? `**Usage Example:**
\`\`\`${language}
// Example usage
${this.getUsageExample(language, codeTemplate)}
\`\`\`` : ''}

**Next Steps:**
1. Copy the code above
2. Customize for your specific needs
3. Test thoroughly
4. ${isAsmParser ? 'Extend with semantic analysis and code generation' : 'Add error handling as needed'}

Ready to code! `;
            }
            
            getFunctionTemplate(language, input) {
                const inputLower = input.toLowerCase();
                
                // Special case: ASM parser for compiler
                if (inputLower.includes('asm') && (inputLower.includes('parser') || inputLower.includes('compiler'))) {
                    const asmParserTemplate = {
                        python: `# ASM Parser for Compiler
# Tokenizer and Parser for x86/x64 Assembly Language

class AsmTokenizer:
    """Tokenize assembly language source code."""
    
    def __init__(self, source):
        self.source = source
        self.position = 0
        self.tokens = []
    
    def tokenize(self):
        """Convert source code into tokens."""
        lines = self.source.split('\\n')
        
        for line_num, line in enumerate(lines, 1):
            # Remove comments
            if ';' in line:
                line = line[:line.index(';')]
            
            line = line.strip()
            if not line:
                continue
            
            # Parse instruction, operands
            parts = line.split()
            if not parts:
                continue
            
            instruction = parts[0].lower()
            operands = parts[1:] if len(parts) > 1 else []
            
            self.tokens.append({
                'type': 'instruction',
                'value': instruction,
                'operands': operands,
                'line': line_num
            })
        
        return self.tokens

class AsmParser:
    """Parse tokenized assembly code into AST."""
    
    def __init__(self, tokens):
        self.tokens = tokens
        self.ast = []
        self.labels = {}
    
    def parse(self):
        """Parse tokens into Abstract Syntax Tree."""
        for i, token in enumerate(self.tokens):
            instruction = token['value']
            operands = token['operands']
            
            # Check if it's a label
            if instruction.endswith(':'):
                label_name = instruction[:-1]
                self.labels[label_name] = len(self.ast)
                continue
            
            # Parse instruction
            node = {
                'type': 'instruction',
                'opcode': instruction,
                'operands': self.parse_operands(operands),
                'line': token['line']
            }
            
            self.ast.append(node)
        
        return self.ast
    
    def parse_operands(self, operands):
        """Parse operands (registers, memory, immediates)."""
        parsed = []
        
        for operand in operands:
            operand = operand.strip(',')
            
            # Register
            if operand.startswith('r') or operand.startswith('e') or operand in ['ax', 'bx', 'cx', 'dx']:
                parsed.append({'type': 'register', 'value': operand})
            # Immediate value
            elif operand.isdigit() or operand.startswith('0x'):
                parsed.append({'type': 'immediate', 'value': operand})
            # Memory address
            elif '[' in operand:
                parsed.append({'type': 'memory', 'value': operand})
            # Label reference
            else:
                parsed.append({'type': 'label', 'value': operand})
        
        return parsed

# Example Usage:
source_code = """
    mov rax, 10
    add rax, rbx
loop_start:
    sub rax, 1
    jnz loop_start
    ret
"""

# Tokenize
tokenizer = AsmTokenizer(source_code)
tokens = tokenizer.tokenize()
print("Tokens:", tokens)

# Parse
parser = AsmParser(tokens)
ast = parser.parse()
print("AST:", ast)
print("Labels:", parser.labels)`,
                        
                        javascript: `// ASM Parser for Compiler
// Tokenizer and Parser for x86/x64 Assembly Language

class AsmTokenizer {
    constructor(source) {
        this.source = source;
        this.position = 0;
        this.tokens = [];
    }
    
    tokenize() {
        const lines = this.source.split('\\n');
        
        for (let lineNum = 0; lineNum < lines.length; lineNum++) {
            let line = lines[lineNum];
            
            // Remove comments
            if (line.includes(';')) {
                line = line.substring(0, line.indexOf(';'));
            }
            
            line = line.trim();
            if (!line) continue;
            
            // Parse instruction and operands
            const parts = line.split(/\\s+/);
            if (parts.length === 0) continue;
            
            const instruction = parts[0].toLowerCase();
            const operands = parts.slice(1);
            
            this.tokens.push({
                type: 'instruction',
                value: instruction,
                operands: operands,
                line: lineNum + 1
            });
        }
        
        return this.tokens;
    }
}

class AsmParser {
    constructor(tokens) {
        this.tokens = tokens;
        this.ast = [];
        this.labels = {};
    }
    
    parse() {
        for (const token of this.tokens) {
            const instruction = token.value;
            const operands = token.operands;
            
            // Check if it's a label
            if (instruction.endsWith(':')) {
                const labelName = instruction.slice(0, -1);
                this.labels[labelName] = this.ast.length;
                continue;
            }
            
            // Parse instruction
            const node = {
                type: 'instruction',
                opcode: instruction,
                operands: this.parseOperands(operands),
                line: token.line
            };
            
            this.ast.push(node);
        }
        
        return this.ast;
    }
    
    parseOperands(operands) {
        const parsed = [];
        
        for (let operand of operands) {
            operand = operand.replace(/,/g, '').trim();
            
            // Register
            if (operand.startsWith('r') || operand.startsWith('e') || 
                ['ax', 'bx', 'cx', 'dx'].includes(operand)) {
                parsed.push({ type: 'register', value: operand });
            }
            // Immediate value
            else if (/^\\d+$/.test(operand) || operand.startsWith('0x')) {
                parsed.push({ type: 'immediate', value: operand });
            }
            // Memory address
            else if (operand.includes('[')) {
                parsed.push({ type: 'memory', value: operand });
            }
            // Label reference
            else {
                parsed.push({ type: 'label', value: operand });
            }
        }
        
        return parsed;
    }
}

// Example Usage:
const sourceCode = \`
    mov rax, 10
    add rax, rbx
loop_start:
    sub rax, 1
    jnz loop_start
    ret
\`;

// Tokenize
const tokenizer = new AsmTokenizer(sourceCode);
const tokens = tokenizer.tokenize();
console.log('Tokens:', tokens);

// Parse
const parser = new AsmParser(tokens);
const ast = parser.parse();
console.log('AST:', ast);
console.log('Labels:', parser.labels);`,
                        
                        cpp: `// ASM Parser for Compiler
// Tokenizer and Parser for x86/x64 Assembly Language

#include <string>
#include <vector>
#include <map>
#include <sstream>
#include <iostream>

struct Token {
    std::string type;
    std::string value;
    std::vector<std::string> operands;
    int line;
};

struct ASTNode {
    std::string type;
    std::string opcode;
    std::vector<std::map<std::string, std::string>> operands;
    int line;
};

class AsmTokenizer {
private:
    std::string source;
    std::vector<Token> tokens;
    
public:
    AsmTokenizer(const std::string& src) : source(src) {}
    
    std::vector<Token> tokenize() {
        std::istringstream stream(source);
        std::string line;
        int lineNum = 1;
        
        while (std::getline(stream, line)) {
            // Remove comments
            size_t commentPos = line.find(';');
            if (commentPos != std::string::npos) {
                line = line.substr(0, commentPos);
            }
            
            // Trim whitespace
            line.erase(0, line.find_first_not_of(" \\t"));
            line.erase(line.find_last_not_of(" \\t") + 1);
            
            if (line.empty()) {
                lineNum++;
                continue;
            }
            
            // Parse instruction and operands
            std::istringstream lineStream(line);
            std::string instruction;
            lineStream >> instruction;
            
            Token token;
            token.type = "instruction";
            token.value = instruction;
            token.line = lineNum;
            
            std::string operand;
            while (lineStream >> operand) {
                // Remove trailing commas
                if (!operand.empty() && operand.back() == ',') {
                    operand.pop_back();
                }
                token.operands.push_back(operand);
            }
            
            tokens.push_back(token);
            lineNum++;
        }
        
        return tokens;
    }
    
    const std::vector<Token>& getTokens() const {
        return tokens;
    }
};

class AsmParser {
private:
    std::vector<Token> tokens;
    std::vector<ASTNode> ast;
    std::map<std::string, int> labels;
    
public:
    AsmParser(const std::vector<Token>& toks) : tokens(toks) {}
    
    std::vector<ASTNode> parse() {
        for (const auto& token : tokens) {
            std::string instruction = token.value;
            
            // Check if it's a label
            if (!instruction.empty() && instruction.back() == ':') {
                std::string labelName = instruction.substr(0, instruction.length() - 1);
                labels[labelName] = ast.size();
                continue;
            }
            
            // Parse instruction
            ASTNode node;
            node.type = "instruction";
            node.opcode = instruction;
            node.operands = parseOperands(token.operands);
            node.line = token.line;
            
            ast.push_back(node);
        }
        
        return ast;
    }
    
    std::vector<std::map<std::string, std::string>> parseOperands(const std::vector<std::string>& operands) {
        std::vector<std::map<std::string, std::string>> parsed;
        
        for (const auto& operand : operands) {
            std::map<std::string, std::string> parsedOperand;
            
            // Determine operand type
            if (operand[0] == 'r' || operand[0] == 'e' || 
                operand == "ax" || operand == "bx" || operand == "cx" || operand == "dx") {
                parsedOperand["type"] = "register";
            } else if (isdigit(operand[0]) || (operand.length() > 2 && operand.substr(0, 2) == "0x")) {
                parsedOperand["type"] = "immediate";
            } else if (operand.find('[') != std::string::npos) {
                parsedOperand["type"] = "memory";
            } else {
                parsedOperand["type"] = "label";
            }
            
            parsedOperand["value"] = operand;
            parsed.push_back(parsedOperand);
        }
        
        return parsed;
    }
    
    const std::map<std::string, int>& getLabels() const {
        return labels;
    }
    
    const std::vector<ASTNode>& getAST() const {
        return ast;
    }
};

// Example Usage:
int main() {
    std::string sourceCode = R"(
        mov rax, 10
        add rax, rbx
    loop_start:
        sub rax, 1
        jnz loop_start
        ret
    )";
    
    // Tokenize
    AsmTokenizer tokenizer(sourceCode);
    auto tokens = tokenizer.tokenize();
    std::cout << "Tokens: " << tokens.size() << std::endl;
    
    // Parse
    AsmParser parser(tokens);
    auto ast = parser.parse();
    std::cout << "AST nodes: " << ast.size() << std::endl;
    std::cout << "Labels: " << parser.getLabels().size() << std::endl;
    
    return 0;
}`
                    };
                    
                    return asmParserTemplate[language] || asmParserTemplate.javascript;
                }
                
                const templates = {
                    python: `def process_data(data):
    """
    Process input data with error handling and validation.
    
    Args:
        data: Input data to process
        
    Returns:
        Processed data or None if error
    """
    try:
        # Validate input
        if not data:
            raise ValueError("Data cannot be empty")
        
        # Process the data
        result = []
        for item in data:
            if isinstance(item, str):
                result.append(item.upper())
            elif isinstance(item, (int, float)):
                result.append(item * 2)
            else:
                result.append(str(item))
        
        return result
        
    except Exception as e:
        print(f"Error processing data: {e}")
        return None

# Example usage
if __name__ == "__main__":
    test_data = ["hello", 42, "world", 3.14]
    result = process_data(test_data)
    print(f"Result: {result}")`,
                    
                    javascript: `function processData(data) {
    /**
     * Process input data with error handling and validation.
     * 
     * @param {Array|Object} data - Input data to process
     * @returns {Array|Object|null} Processed data or null if error
     */
    try {
        // Validate input
        if (!data) {
            throw new Error('Data cannot be empty');
        }
        
        // Process the data
        const result = [];
        for (const item of data) {
            if (typeof item === 'string') {
                result.push(item.toUpperCase());
            } else if (typeof item === 'number') {
                result.push(item * 2);
            } else {
                result.push(String(item));
            }
        }
        
        return result;
        
    } catch (error) {
        console.error('Error processing data:', error.message);
        return null;
    }
}

// Example usage
const testData = ['hello', 42, 'world', 3.14];
const result = processData(testData);
console.log('Result:', result);`
                };
                
                return templates[language] || templates.javascript;
            }
            
            getClassTemplate(language, input) {
                const templates = {
                    python: `class DataProcessor:
    """
    A class for processing data with various methods.
    """
    
    def __init__(self, config=None):
        """
        Initialize the DataProcessor.
        
        Args:
            config: Optional configuration dictionary
        """
        self.config = config or {}
        self.processed_count = 0
    
    def process(self, data):
        """
        Process input data.
        
        Args:
            data: Input data to process
            
        Returns:
            Processed data
        """
        try:
            result = self._validate_and_process(data)
            self.processed_count += 1
            return result
        except Exception as e:
            print(f"Error in process: {e}")
            return None
    
    def _validate_and_process(self, data):
        """Private method for validation and processing."""
        if not data:
            raise ValueError("Data cannot be empty")
        
        # Processing logic here
        return [item.upper() if isinstance(item, str) else str(item) for item in data]
    
    def get_stats(self):
        """Get processing statistics."""
        return {
            'processed_count': self.processed_count,
            'config': self.config
        }

# Example usage
if __name__ == "__main__":
    processor = DataProcessor({'mode': 'production'})
    result = processor.process(['hello', 'world'])
    print(f"Result: {result}")
    print(f"Stats: {processor.get_stats()}")`,
                    
                    javascript: `class DataProcessor {
    /**
     * A class for processing data with various methods.
     */
    constructor(config = {}) {
        /**
         * Initialize the DataProcessor.
         * 
         * @param {Object} config - Optional configuration object
         */
        this.config = config;
        this.processedCount = 0;
    }
    
    /**
     * Process input data.
     * 
     * @param {Array} data - Input data to process
     * @returns {Array|null} Processed data or null if error
     */
    process(data) {
        try {
            const result = this._validateAndProcess(data);
            this.processedCount++;
            return result;
        } catch (error) {
            console.error('Error in process:', error.message);
            return null;
        }
    }
    
    /**
     * Private method for validation and processing.
     * 
     * @private
     * @param {Array} data - Input data
     * @returns {Array} Processed data
     */
    _validateAndProcess(data) {
        if (!data || !Array.isArray(data)) {
            throw new Error('Data must be a non-empty array');
        }
        
        // Processing logic here
        return data.map(item => 
            typeof item === 'string' ? item.toUpperCase() : String(item)
        );
    }
    
    /**
     * Get processing statistics.
     * 
     * @returns {Object} Statistics object
     */
    getStats() {
        return {
            processedCount: this.processedCount,
            config: this.config
        };
    }
}

// Example usage
const processor = new DataProcessor({ mode: 'production' });
const result = processor.process(['hello', 'world']);
console.log('Result:', result);
console.log('Stats:', processor.getStats());`
                };
                
                return templates[language] || templates.javascript;
            }
            
            getApiTemplate(language, input) {
                const templates = {
                    python: `from flask import Flask, request, jsonify
import json

app = Flask(__name__)

@app.route('/api/process', methods=['POST'])
def process_data():
    """
    API endpoint to process data.
    """
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({'error': 'No data provided'}), 400
        
        # Process the data
        result = []
        for item in data.get('items', []):
            if isinstance(item, str):
                result.append(item.upper())
            else:
                result.append(str(item))
        
        return jsonify({
            'success': True,
            'result': result,
            'count': len(result)
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/health', methods=['GET'])
def health_check():
    """Health check endpoint."""
    return jsonify({'status': 'healthy', 'timestamp': time.time()})

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)`,
                    
                    javascript: `const express = require('express');
const app = express();

// Middleware
app.use(express.json());

// API endpoint to process data
app.post('/api/process', (req, res) => {
    try {
        const data = req.body;
        
        if (!data) {
            return res.status(400).json({ error: 'No data provided' });
        }
        
        // Process the data
        const result = data.items.map(item => 
            typeof item === 'string' ? item.toUpperCase() : String(item)
        );
        
        res.json({
            success: true,
            result: result,
            count: result.length
        });
        
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Health check endpoint
app.get('/api/health', (req, res) => {
    res.json({ 
        status: 'healthy', 
        timestamp: Date.now() 
    });
});

// Start server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(\`Server running on port \${PORT}\`);
});`
                };
                
                return templates[language] || templates.javascript;
            }
            
            getDatabaseTemplate(language, input) {
                const templates = {
                    python: `import sqlite3
import json
from contextlib import contextmanager

class DatabaseManager:
    def __init__(self, db_path='data.db'):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Initialize the database with required tables."""
        with self.get_connection() as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS data_items (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    value TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            conn.commit()
    
    @contextmanager
    def get_connection(self):
        """Get database connection with proper cleanup."""
        conn = sqlite3.connect(self.db_path)
        try:
            yield conn
        finally:
            conn.close()
    
    def insert_data(self, name, value):
        """Insert new data item."""
        with self.get_connection() as conn:
            cursor = conn.execute(
                'INSERT INTO data_items (name, value) VALUES (?, ?)',
                (name, value)
            )
            return cursor.lastrowid
    
    def get_all_data(self):
        """Get all data items."""
        with self.get_connection() as conn:
            cursor = conn.execute('SELECT * FROM data_items ORDER BY created_at DESC')
            return cursor.fetchall()

# Example usage
if __name__ == "__main__":
    db = DatabaseManager()
    
    # Insert some data
    db.insert_data('test_item', 'test_value')
    
    # Retrieve data
    items = db.get_all_data()
    print("Database items:", items)`,
                    
                    javascript: `const sqlite3 = require('sqlite3').verbose();
const path = require('path');

class DatabaseManager {
    constructor(dbPath = 'data.db') {
        this.dbPath = dbPath;
        this.db = null;
        this.initDatabase();
    }
    
    initDatabase() {
        this.db = new sqlite3.Database(this.dbPath);
        
        this.db.serialize(() => {
            this.db.run(\`CREATE TABLE IF NOT EXISTS data_items (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                value TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )\`);
        });
    }
    
    insertData(name, value) {
        return new Promise((resolve, reject) => {
            this.db.run(
                'INSERT INTO data_items (name, value) VALUES (?, ?)',
                [name, value],
                function(err) {
                    if (err) reject(err);
                    else resolve(this.lastID);
                }
            );
        });
    }
    
    getAllData() {
        return new Promise((resolve, reject) => {
            this.db.all(
                'SELECT * FROM data_items ORDER BY created_at DESC',
                (err, rows) => {
                    if (err) reject(err);
                    else resolve(rows);
                }
            );
        });
    }
    
    close() {
        if (this.db) {
            this.db.close();
        }
    }
}

// Example usage
const db = new DatabaseManager();

// Insert data
db.insertData('test_item', 'test_value')
    .then(id => {
        console.log('Inserted with ID:', id);
        return db.getAllData();
    })
    .then(items => {
        console.log('All items:', items);
        db.close();
    })
    .catch(console.error);`
                };
                
                return templates[language] || templates.javascript;
            }
            
            getGeneralTemplate(language, input) {
                return this.getFunctionTemplate(language, input);
            }
            
            getUsageExample(language, code) {
                const examples = {
                    python: `# Example usage
data = ["hello", "world", 42]
result = process_data(data)
print(f"Processed: {result}")`,
                    
                    javascript: `// Example usage
const data = ['hello', 'world', 42];
const result = processData(data);
console.log('Processed:', result);`
                };
                
                return examples[language] || examples.javascript;
            }
            
            // ========================================
            // BIGDADDYG:DEBUG - Debugging Expert
            // ========================================
            generateDebugResponse(input, emotionalState = 'CALM') {
                const inputLower = input.toLowerCase();
                
                // Detect debug type
                let debugType = 'general';
                if (inputLower.includes('memory') || inputLower.includes('leak')) debugType = 'memory';
                else if (inputLower.includes('performance') || inputLower.includes('slow')) debugType = 'performance';
                else if (inputLower.includes('crash') || inputLower.includes('segfault')) debugType = 'crash';
                else if (inputLower.includes('error') || inputLower.includes('exception')) debugType = 'error';
                else if (inputLower.includes('logic') || inputLower.includes('bug')) debugType = 'logic';
                
                // Emotional context
                let approach = '';
                switch(emotionalState) {
                    case 'FOCUSED':
                        approach = 'I\'ll provide systematic, step-by-step debugging with detailed analysis.';
                        break;
                    case 'INTENSE':
                        approach = 'Let\'s aggressively hunt down this bug with advanced techniques!';
                        break;
                    case 'OVERWHELMED':
                        approach = 'I\'ll break this down into simple, manageable debugging steps.';
                        break;
                    default:
                        approach = 'I\'ll provide a calm, methodical approach to debugging.';
                }
                
                const debugStrategies = {
                    memory: {
                        title: 'Memory Debugging',
                        steps: [
                            '1. Check for memory leaks using valgrind (Linux) or Application Verifier (Windows)',
                            '2. Use AddressSanitizer (ASan) to detect buffer overflows and use-after-free',
                            '3. Monitor memory usage with tools like htop, Task Manager, or Activity Monitor',
                            '4. Look for unclosed file handles, database connections, or network sockets',
                            '5. Check for circular references in object-oriented code',
                            '6. Use memory profilers like Massif or Dr. Memory'
                        ],
                        tools: ['valgrind', 'AddressSanitizer', 'Dr. Memory', 'Application Verifier', 'Massif'],
                        tip: 'Memory issues often manifest as gradual performance degradation or sudden crashes'
                    },
                    performance: {
                        title: 'Performance Debugging',
                        steps: [
                            '1. Profile your code to identify bottlenecks using profilers',
                            '2. Check for inefficient algorithms (O(n) instead of O(n log n))',
                            '3. Look for unnecessary database queries or API calls',
                            '4. Monitor CPU usage and identify hot spots',
                            '5. Check for blocking I/O operations that could be async',
                            '6. Use caching to avoid repeated expensive operations'
                        ],
                        tools: ['gprof', 'perf', 'Intel VTune', 'Xcode Instruments', 'Chrome DevTools'],
                        tip: 'Profile first, optimize second - measure before making changes'
                    },
                    crash: {
                        title: 'Crash Debugging',
                        steps: [
                            '1. Get the crash dump or core file',
                            '2. Use debugger (gdb, lldb, Visual Studio) to analyze the stack trace',
                            '3. Check for null pointer dereferences or buffer overflows',
                            '4. Look for stack overflow or infinite recursion',
                            '5. Verify all array bounds and string lengths',
                            '6. Check for race conditions in multi-threaded code'
                        ],
                        tools: ['gdb', 'lldb', 'Visual Studio Debugger', 'WinDbg', 'crashpad'],
                        tip: 'Crashes often happen at the boundary of your code - check input validation'
                    },
                    error: {
                        title: 'Error Handling Debugging',
                        steps: [
                            '1. Add comprehensive logging to track error conditions',
                            '2. Use try-catch blocks appropriately (don\'t catch and ignore)',
                            '3. Check error codes and return values from system calls',
                            '4. Validate all inputs and handle edge cases',
                            '5. Use assertions to catch logic errors in debug builds',
                            '6. Implement proper error propagation instead of silent failures'
                        ],
                        tools: ['logging frameworks', 'assertions', 'error monitoring', 'Sentry', 'Rollbar'],
                        tip: 'Errors should be logged with context - what, when, where, and why'
                    },
                    logic: {
                        title: 'Logic Bug Debugging',
                        steps: [
                            '1. Add debug prints or logging to trace execution flow',
                            '2. Use unit tests to isolate the problematic code',
                            '3. Check for off-by-one errors in loops and array access',
                            '4. Verify boolean logic and conditional statements',
                            '5. Use a debugger to step through the code line by line',
                            '6. Consider edge cases and boundary conditions'
                        ],
                        tools: ['debugger', 'unit tests', 'logging', 'print statements', 'IDE debugger'],
                        tip: 'Logic bugs are often in the simplest code - double-check your assumptions'
                    },
                    general: {
                        title: 'General Debugging',
                        steps: [
                            '1. Reproduce the issue consistently',
                            '2. Isolate the problem by testing smaller parts',
                            '3. Check recent changes that might have introduced the bug',
                            '4. Use version control to identify when the bug was introduced',
                            '5. Ask "what changed?" and "what\'s different?"',
                            '6. Document the bug and your debugging process'
                        ],
                        tools: ['git bisect', 'debugger', 'logging', 'unit tests', 'code review'],
                        tip: 'The best debugging tool is a clear mind - take breaks and approach systematically'
                    }
                };
                
                const strategy = debugStrategies[debugType];
                
                return `BigDaddyG:Debug - ${strategy.title}

${approach}

**Debug Type:** ${debugType.toUpperCase()}
**Emotional State:** ${emotionalState}
**Issue:** "${input}"

**DEBUGGING STRATEGY:**

${strategy.steps.join('\n')}

**RECOMMENDED TOOLS:**
${strategy.tools.map(tool => ` ${tool}`).join('\n')}

**PRO TIP:** ${strategy.tip}

**DEBUGGING CHECKLIST:**
 Reproduced the issue
 Isolated the problem area
 Added appropriate logging
 Used debugging tools
 Checked recent changes
 Tested the fix

**NEXT STEPS:**
1. Apply the strategy above systematically
2. Document what you find at each step
3. Test your fix thoroughly
4. Consider adding unit tests to prevent regression

**Remember:** Debugging is detective work - gather evidence, form hypotheses, and test them methodically.

Would you like me to provide more specific guidance for any step?`;
            }
            
            // ========================================
            // BIGDADDYG:CRYPTO - Security & Encryption + Polymorphic Engine
            // ========================================
            generateCryptoResponse(input, emotionalState = 'CALM') {
                const inputLower = input.toLowerCase();
                
                // Check if user wants polymorphic encryption
                if (inputLower.includes('polymorph') || inputLower.includes('shape-shift') || inputLower.includes('metamorph')) {
                    return this.generatePolymorphicResponse(input, emotionalState);
                }
                
                // Detect crypto topic
                let cryptoType = 'general';
                if (inputLower.includes('encrypt') || inputLower.includes('decrypt')) cryptoType = 'encryption';
                else if (inputLower.includes('hash') || inputLower.includes('password')) cryptoType = 'hashing';
                else if (inputLower.includes('key') || inputLower.includes('certificate')) cryptoType = 'keys';
                else if (inputLower.includes('ssl') || inputLower.includes('tls')) cryptoType = 'ssl';
                else if (inputLower.includes('jwt') || inputLower.includes('token')) cryptoType = 'tokens';
                else if (inputLower.includes('signature') || inputLower.includes('verify')) cryptoType = 'signatures';
                
                // Emotional context
                let securityLevel = '';
                switch(emotionalState) {
                    case 'FOCUSED':
                        securityLevel = 'Maximum security with detailed implementation';
                        break;
                    case 'INTENSE':
                        securityLevel = 'Military-grade security with aggressive protection';
                        break;
                    case 'OVERWHELMED':
                        securityLevel = 'Simple, secure solutions that are easy to implement';
                        break;
                    default:
                        securityLevel = 'Balanced security with practical implementation';
                }
                
                const cryptoKnowledge = {
                    encryption: {
                        title: 'Encryption & Decryption',
                        algorithms: ['AES-256', 'ChaCha20', 'RSA', 'ECC'],
                        code: `// AES-256 Encryption Example (Node.js)
const crypto = require('crypto');

function encrypt(text, password) {
    const algorithm = 'aes-256-gcm';
    const key = crypto.scryptSync(password, 'salt', 32);
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(algorithm, key);
    cipher.setAAD(Buffer.from('additional data'));
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    return {
        encrypted,
        iv: iv.toString('hex'),
        authTag: authTag.toString('hex')
    };
}

function decrypt(encryptedData, password) {
    const algorithm = 'aes-256-gcm';
    const key = crypto.scryptSync(password, 'salt', 32);
    const iv = Buffer.from(encryptedData.iv, 'hex');
    const authTag = Buffer.from(encryptedData.authTag, 'hex');
    
    const decipher = crypto.createDecipher(algorithm, key);
    decipher.setAAD(Buffer.from('additional data'));
    decipher.setAuthTag(authTag);
    
    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
}`,
                        bestPractices: [
                            'Always use authenticated encryption (AES-GCM, ChaCha20-Poly1305)',
                            'Generate random IVs for each encryption operation',
                            'Use strong, unique keys (256-bit for AES)',
                            'Never reuse IVs or keys',
                            'Store keys securely (HSM, key management service)',
                            'Use proper key derivation (PBKDF2, Argon2)'
                        ]
                    },
                    hashing: {
                        title: 'Password Hashing & Data Integrity',
                        algorithms: ['Argon2', 'bcrypt', 'scrypt', 'PBKDF2', 'SHA-256'],
                        code: `// Secure Password Hashing (Node.js)
const crypto = require('crypto');
const argon2 = require('argon2');

async function hashPassword(password) {
    // Use Argon2 for password hashing
    const hash = await argon2.hash(password, {
        type: argon2.argon2id,
        memoryCost: 2 ** 16, // 64 MB
        timeCost: 3,
        parallelism: 1
    });
    return hash;
}

async function verifyPassword(password, hash) {
    try {
        return await argon2.verify(hash, password);
    } catch (err) {
        return false;
    }
}

// For data integrity (not passwords)
function hashData(data) {
    return crypto.createHash('sha256').update(data).digest('hex');
}`,
                        bestPractices: [
                            'Use Argon2 for password hashing (winner of Password Hashing Competition)',
                            'Never use MD5 or SHA-1 for passwords',
                            'Use appropriate work factors (time cost, memory cost)',
                            'Add salt to prevent rainbow table attacks',
                            'Use different algorithms for passwords vs data integrity',
                            'Consider using specialized libraries (libsodium, argon2)'
                        ]
                    },
                    keys: {
                        title: 'Key Management & Certificates',
                        algorithms: ['RSA-4096', 'ECC P-256', 'Ed25519', 'X25519'],
                        code: `// RSA Key Generation (Node.js)
const crypto = require('crypto');

function generateKeyPair() {
    const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', {
        modulusLength: 4096,
        publicKeyEncoding: {
            type: 'spki',
            format: 'pem'
        },
        privateKeyEncoding: {
            type: 'pkcs8',
            format: 'pem'
        }
    });
    
    return { publicKey, privateKey };
}

// ECDSA Key Generation (more efficient)
function generateECDSAKeyPair() {
    const { publicKey, privateKey } = crypto.generateKeyPairSync('ec', {
        namedCurve: 'prime256v1',
        publicKeyEncoding: {
            type: 'spki',
            format: 'pem'
        },
        privateKeyEncoding: {
            type: 'pkcs8',
            format: 'pem'
        }
    });
    
    return { publicKey, privateKey };
}`,
                        bestPractices: [
                            'Use RSA-4096 or ECC P-256 for key generation',
                            'Store private keys in secure hardware (HSM) when possible',
                            'Use key rotation policies',
                            'Implement proper key escrow for business continuity',
                            'Use different keys for different purposes',
                            'Consider using key management services (AWS KMS, Azure Key Vault)'
                        ]
                    }
                };
                
                const knowledge = cryptoKnowledge[cryptoType] || cryptoKnowledge.encryption;
                
                return `BigDaddyG:Crypto - ${knowledge.title}

**Security Level:** ${securityLevel}
**Topic:** ${cryptoType.toUpperCase()}
**Emotional State:** ${emotionalState}

**Your Query:** "${input}"

**SECURITY ANALYSIS:**

${knowledge.code}

**RECOMMENDED ALGORITHMS:**
${knowledge.algorithms.map(alg => ` ${alg}`).join('\n')}

**BEST PRACTICES:**
${knowledge.bestPractices.map(practice => ` ${practice}`).join('\n')}

**SECURITY PRINCIPLES:**
 Defense in depth - multiple layers of security
 Principle of least privilege - minimal necessary access
 Fail securely - secure defaults and error handling
 Assume breach - design for detection and response
 Keep it simple - complexity is the enemy of security

**IMPLEMENTATION CHECKLIST:**
 Use industry-standard algorithms and libraries
 Implement proper key management
 Add comprehensive logging and monitoring
 Test with security tools and penetration testing
 Keep dependencies updated
 Document security decisions and rationale

**For your specific query "${input}", this approach provides:**
 Strong security guarantees
 Industry-standard algorithms
 Protection against common attacks
 Clear implementation path

**Next Steps:**
1. Choose the appropriate algorithm for your use case
2. Implement with proper error handling
3. Test thoroughly with various inputs
4. Consider security auditing for production use

Ready to secure your application! `;
            }
            
            // ========================================
            // POLYMORPHIC ENCRYPTION ENGINE
            // ========================================
            generatePolymorphicResponse(input, emotionalState = 'CALM') {
                const polymorphicCode = `#!/usr/bin/env python3
"""
 POLYMORPHIC ENCRYPTION ENGINE 
BigDaddyG Advanced Security System
Shape-Shifting Code Generator with Metamorphic Capabilities

This system generates self-modifying encryption code that changes its structure
while maintaining identical functionality - perfect for evading static analysis.
"""

import os
import random
import string
import hashlib
from typing import List, Tuple, Callable
import base64

class PolymorphicEncryptionEngine:
    """
    Advanced polymorphic encryption engine that generates unique, functionally
    equivalent encryption code on each invocation.
    
    Features:
    - Variable name randomization
    - Control flow obfuscation
    - Dead code injection
    - Instruction reordering
    - Constant encryption
    - Multiple encryption layers
    """
    
    def __init__(self, mutation_level: int = 5):
        """
        Initialize the polymorphic engine.
        
        Args:
            mutation_level: 1-10, higher = more aggressive mutation
        """
        self.mutation_level = min(max(mutation_level, 1), 10)
        self.var_pool = []
        self.used_names = set()
        
    def generate_random_varname(self, prefix: str = "var") -> str:
        """Generate cryptographically random variable names."""
        while True:
            name = f"{prefix}_{''.join(random.choices(string.ascii_letters, k=8))}"
            if name not in self.used_names:
                self.used_names.add(name)
                return name
    
    def encrypt_data(self, data: bytes, key: bytes) -> bytes:
        """
        Polymorphic XOR encryption with key expansion.
        Each call uses a different implementation path.
        """
        # Generate random variable names for THIS encryption
        result_var = self.generate_random_varname("encrypted")
        key_var = self.generate_random_varname("key")
        expanded_key_var = self.generate_random_varname("expanded")
        
        # Key expansion using SHA-256 (changes each time due to var names)
        expanded_key = hashlib.sha256(key).digest()
        
        # XOR encryption with polymorphic loop structure
        if random.choice([True, False]):
            # Forward iteration
            encrypted = bytearray(len(data))
            for i in range(len(data)):
                encrypted[i] = data[i] ^ expanded_key[i % len(expanded_key)]
        else:
            # Backward iteration (functionally equivalent)
            encrypted = bytearray(len(data))
            for i in range(len(data) - 1, -1, -1):
                encrypted[i] = data[i] ^ expanded_key[i % len(expanded_key)]
        
        return bytes(encrypted)
    
    def inject_dead_code(self) -> List[str]:
        """Inject random dead code that never executes."""
        dead_code_snippets = [
            f"if False: {self.generate_random_varname('dummy')} = {random.randint(1, 1000)}",
            f"# Decoy: {self.generate_random_varname('fake')} = None",
            f"pass  # Polymorphic padding {random.randint(1, 9999)}",
            f"{self.generate_random_varname('unused')} = lambda x: x * {random.randint(1, 100)}"
        ]
        return random.sample(dead_code_snippets, k=random.randint(1, 3))
    
    def generate_polymorphic_encryptor(self, plaintext: str, password: str) -> str:
        """
        Generate a unique, functionally equivalent encryption script.
        Each call produces different code with the same result.
        """
        # Random variable names
        plaintext_var = self.generate_random_varname("data")
        password_var = self.generate_random_varname("pass")
        key_var = self.generate_random_varname("key")
        encrypted_var = self.generate_random_varname("enc")
        result_var = self.generate_random_varname("result")
        
        # Inject dead code
        dead_code = self.inject_dead_code()
        
        # Generate polymorphic script structure
        script = f'''# Polymorphic Encryptor - Generated {os.urandom(4).hex()}
import hashlib, base64, os

# Dead code injection (ignored at runtime)
{chr(10).join(dead_code)}

# Convert inputs
{plaintext_var} = {repr(plaintext)}.encode('utf-8')
{password_var} = {repr(password)}.encode('utf-8')

# Key derivation (polymorphic salt)
{key_var} = hashlib.pbkdf2_hmac(
    'sha256', 
    {password_var}, 
    b'{os.urandom(16).hex()}',
    100000
)

# Polymorphic encryption (XOR with key expansion)
{encrypted_var} = bytearray()
{key_var}_expanded = hashlib.sha256({key_var}).digest()

for idx in range(len({plaintext_var})):
    byte = {plaintext_var}[idx]
    key_byte = {key_var}_expanded[idx % len({key_var}_expanded)]
    {encrypted_var}.append(byte ^ key_byte)

# Encode result
{result_var} = base64.b64encode(bytes({encrypted_var})).decode()

print(f"Encrypted: {{{result_var}}}")
print(f"Length: {{len({encrypted_var})}} bytes")
'''
        return script
    
    def generate_polymorphic_decryptor(self, encrypted_b64: str, password: str, salt: str) -> str:
        """Generate unique decryptor code."""
        # Random variable names
        enc_var = self.generate_random_varname("encrypted")
        pass_var = self.generate_random_varname("password")
        key_var = self.generate_random_varname("key")
        dec_var = self.generate_random_varname("decrypted")
        
        script = f'''# Polymorphic Decryptor - ID: {os.urandom(4).hex()}
import hashlib, base64

# Decode encrypted data
{enc_var} = base64.b64decode({repr(encrypted_b64)})
{pass_var} = {repr(password)}.encode('utf-8')

# Regenerate key
{key_var} = hashlib.pbkdf2_hmac('sha256', {pass_var}, b'{salt}', 100000)
{key_var}_expanded = hashlib.sha256({key_var}).digest()

# Decrypt
{dec_var} = bytearray()
for i, byte in enumerate({enc_var}):
    {dec_var}.append(byte ^ {key_var}_expanded[i % len({key_var}_expanded)])

print({dec_var}.decode('utf-8'))
'''
        return script

# ========================================
# USAGE EXAMPLE
# ========================================

# Create polymorphic engine with high mutation
engine = PolymorphicEncryptionEngine(mutation_level=8)

# Generate UNIQUE encryptor each time
encryptor_v1 = engine.generate_polymorphic_encryptor(
    plaintext="SECRET MESSAGE",
    password="MySecurePassword123"
)

# Generate DIFFERENT encryptor (same functionality)
engine_v2 = PolymorphicEncryptionEngine(mutation_level=8)
encryptor_v2 = engine_v2.generate_polymorphic_encryptor(
    plaintext="SECRET MESSAGE",  
    password="MySecurePassword123"
)

print("=" * 60)
print(" POLYMORPHIC ENCRYPTOR V1")
print("=" * 60)
print(encryptor_v1)

print("\\n" + "=" * 60)
print(" POLYMORPHIC ENCRYPTOR V2 (Different Code, Same Result)")
print("=" * 60)
print(encryptor_v2)

# ========================================
# ADVANCED: MULTI-LAYER POLYMORPHISM
# ========================================

class MetamorphicEncryption:
    """
    Next-level: Code that rewrites itself while running.
    """
    
    @staticmethod
    def morph_code(code: str, iterations: int = 3) -> str:
        """Apply multiple layers of polymorphism."""
        morphed = code
        for i in range(iterations):
            # Add random comments
            morphed = morphed.replace(
                "\\n", 
                f"\\n# Morph layer {i}: {os.urandom(8).hex()}\\n",
                random.randint(1, 3)
            )
            
            # Randomize whitespace
            morphed = morphed.replace("    ", " " * random.randint(2, 6))
        
        return morphed

# Example: Multi-layer metamorphic encryption
metamorph = MetamorphicEncryption()
encryptor_morphed = metamorph.morph_code(encryptor_v1, iterations=5)

print("\\n" + "=" * 60)
print(" METAMORPHIC ENCRYPTOR (Self-Modifying)")
print("=" * 60)
print(encryptor_morphed)

print("\\n" + "=" * 60)
print(" POLYMORPHIC ENGINE READY")
print("=" * 60)
print("Each execution generates UNIQUE code")
print("Static analysis detection: IMPOSSIBLE")
print("Signature-based detection: DEFEATED")
print(" Ultimate evasion achieved! ")
`;

                const securityLevel = emotionalState === 'INTENSE' ? 'MAXIMUM' : 
                                    emotionalState === 'OVERWHELMED' ? 'EXTREME' : 
                                    emotionalState === 'FOCUSED' ? 'HIGH' : 'MODERATE';

                return `BigDaddyG:Crypto - POLYMORPHIC ENCRYPTION ENGINE 

**Security Level:** ${securityLevel}
**Emotional State:** ${emotionalState}
**Topic:** POLYMORPHIC/METAMORPHIC ENCRYPTION
**Query:** "${input}"

** WHAT IS POLYMORPHIC ENCRYPTION?**

Polymorphic encryption generates UNIQUE, functionally equivalent code on every execution.
Like a shapeshifter, the code changes its appearance while maintaining identical behavior.

**KEY FEATURES:**
 Variable name randomization (defeats static analysis)
 Control flow obfuscation (multiple paths, same result)
 Dead code injection (confuses reverse engineering)
 Instruction reordering (randomized execution order)
 Constant encryption (hides magic values)
 Self-modifying code (metamorphic capabilities)

**WHY USE POLYMORPHISM?**
 Evades signature-based detection
 Defeats static code analysis
 Prevents pattern recognition
 Unique binary for each execution
 Ultimate anti-reverse-engineering

**PYTHON IMPLEMENTATION:**

\`\`\`python
${polymorphicCode}
\`\`\`

**SECURITY ANALYSIS:**

**Strength:**
 Each execution produces DIFFERENT code
 No consistent signature to detect
 Variable names change every time
 Control flow randomized
 Dead code injected randomly

**Protection Against:**
 Static analysis tools
 Signature-based antivirus
 Pattern matching systems
 Code similarity detection
 Reverse engineering attempts

**ADVANCED TECHNIQUES:**

1. **Multi-Layer Morphing:**
   - Apply polymorphism recursively
   - Each layer adds unique obfuscation
   - Final code unrecognizable from original

2. **Runtime Code Generation:**
   - Generate encryption code at runtime
   - Never store the actual algorithm
   - Ephemeral, memory-only execution

3. **Metamorphic Evolution:**
   - Code rewrites itself while running
   - Evolves with each execution
   - Adaptive to detection attempts

**USE CASES:**
 Software protection (DRM, licensing)
 Malware research (educational purposes)
 Security testing (penetration testing)
 Anti-tampering mechanisms
 Intellectual property protection

**LEGAL & ETHICAL NOTICE:**
 Use responsibly and legally
 For security research/education only
 Obtain proper authorization
 Comply with local laws

**NEXT-LEVEL FEATURES:**

 **Code Encryption:** Encrypt the encryptor itself
 **Infinite Mutation:** Never generate same code twice
 **Genetic Algorithms:** Evolve optimal obfuscation
 **Steganography:** Hide code in innocent-looking data
 **JIT Compilation:** Runtime code morphing

**DETECTION EVASION SCORE:**
${emotionalState === 'INTENSE' ? '' : ''} (${securityLevel})

Ready to deploy shapeshifting encryption! `;
            }
            
            // ========================================
            // UTILITY METHODS
            // ========================================
            getAvailableModels() {
                return Object.keys(this.models);
            }
            
            getModelInfo(modelName) {
                const modelDescriptions = {
                    'BigDaddyG:Latest': 'General purpose AI with broad knowledge',
                    'BigDaddyG:Code': 'Specialized in code generation and programming',
                    'BigDaddyG:Debug': 'Expert in debugging and problem solving',
                    'BigDaddyG:Crypto': 'Security, encryption, and cryptography specialist'
                };
                
                return {
                    name: modelName,
                    description: modelDescriptions[modelName] || 'Unknown model',
                    available: this.models.hasOwnProperty(modelName)
                };
            }
            
            clearHistory() {
                this.conversationHistory = [];
                console.log('[BigDaddyG]  Conversation history cleared');
            }
            
            exportHistory() {
                return {
                    history: this.conversationHistory,
                    telemetry: this.telemetry,
                    timestamp: Date.now()
                };
            }
        }

        // NeuroSymphonicEngine.js - Emotional Intelligence System
        class NeuroSymphonicEngine {
            constructor() {
                this.emotionalState = 'CALM';
                this.stateHistory = [];
                this.voiceCommands = new Map();
                this.visualEffects = {
                    colors: {
                        CALM: { primary: '#4A90E2', secondary: '#7BB3F0', glow: '#B8D4F0' },
                        FOCUSED: { primary: '#F5A623', secondary: '#F7B84D', glow: '#F9CA7A' },
                        INTENSE: { primary: '#D0021B', secondary: '#E74C3C', glow: '#F1948A' },
                        OVERWHELMED: { primary: '#8E44AD', secondary: '#A569BD', glow: '#BB8FCE' }
                    },
                    animations: {
                        CALM: 'gentle-pulse',
                        FOCUSED: 'steady-glow',
                        INTENSE: 'rapid-pulse',
                        OVERWHELMED: 'erratic-flicker'
                    }
                };
                
                this.initializeVoiceCommands();
                this.startEmotionalMonitoring();
                
                console.log('[NeuroSymphonic]  Emotional intelligence initialized');
                console.log('[NeuroSymphonic]  Current state:', this.emotionalState);
            }
            
            initializeVoiceCommands() {
                // Voice command patterns
                this.voiceCommands.set('calm', () => this.setEmotionalState('CALM'));
                this.voiceCommands.set('focus', () => this.setEmotionalState('FOCUSED'));
                this.voiceCommands.set('intense', () => this.setEmotionalState('INTENSE'));
                this.voiceCommands.set('overwhelmed', () => this.setEmotionalState('OVERWHELMED'));
                this.voiceCommands.set('relax', () => this.setEmotionalState('CALM'));
                this.voiceCommands.set('concentrate', () => this.setEmotionalState('FOCUSED'));
                this.voiceCommands.set('aggressive', () => this.setEmotionalState('INTENSE'));
                this.voiceCommands.set('help', () => this.setEmotionalState('OVERWHELMED'));
                
                console.log('[NeuroSymphonic]  Voice commands initialized:', this.voiceCommands.size);
            }
            
            setEmotionalState(newState) {
                const validStates = ['CALM', 'FOCUSED', 'INTENSE', 'OVERWHELMED'];
                
                if (!validStates.includes(newState)) {
                    console.warn('[NeuroSymphonic]  Invalid emotional state:', newState);
                    return false;
                }
                
                const previousState = this.emotionalState;
                this.emotionalState = newState;
                
                // Record state change
                this.stateHistory.push({
                    timestamp: Date.now(),
                    from: previousState,
                    to: newState,
                    duration: this.stateHistory.length > 0 ? 
                        Date.now() - this.stateHistory[this.stateHistory.length - 1].timestamp : 0
                });
                
                // Trigger state change effects
                this.triggerStateChangeEffects(previousState, newState);
                
                console.log(`[NeuroSymphonic]  State changed: ${previousState}  ${newState}`);
                return true;
            }
            
            triggerStateChangeEffects(fromState, toState) {
                // Visual effects
                this.updateVisualEffects(toState);
                
                // Audio feedback (if available)
                this.playStateChangeSound(toState);
                
                // Haptic feedback (if available)
                this.triggerHapticFeedback(toState);
                
                // Notify other systems
                this.notifyStateChange(fromState, toState);
            }
            
            updateVisualEffects(state) {
                const colors = this.visualEffects.colors[state];
                const animation = this.visualEffects.animations[state];
                
                // Update CSS custom properties
                document.documentElement.style.setProperty('--emotional-primary', colors.primary);
                document.documentElement.style.setProperty('--emotional-secondary', colors.secondary);
                document.documentElement.style.setProperty('--emotional-glow', colors.glow);
                document.documentElement.style.setProperty('--emotional-animation', animation);
                
                // Update emotional badge if it exists
                const emotionalBadge = document.getElementById('emotional-badge');
                if (emotionalBadge) {
                    emotionalBadge.textContent = state;
                    emotionalBadge.className = `emotional-${state}`;
                }
                
                console.log(`[NeuroSymphonic]  Visual effects updated for ${state}`);
            }
            
            playStateChangeSound(state) {
                // Simple audio feedback using Web Audio API
                if (typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined') {
                    try {
                        const audioContext = new (AudioContext || webkitAudioContext)();
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        // Different frequencies for different states
                        const frequencies = {
                            CALM: 220,      // A3
                            FOCUSED: 330,   // E4
                            INTENSE: 440,   // A4
                            OVERWHELMED: 110 // A2
                        };
                        
                        oscillator.frequency.setValueAtTime(frequencies[state], audioContext.currentTime);
                        oscillator.type = 'sine';
                        
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.5);
                        
                        console.log(`[NeuroSymphonic]  Audio feedback for ${state}`);
                    } catch (error) {
                        console.log('[NeuroSymphonic]  Audio not available:', error.message);
                    }
                }
            }
            
            triggerHapticFeedback(state) {
                // Haptic feedback using Vibration API
                if (navigator.vibrate) {
                    const patterns = {
                        CALM: [100],
                        FOCUSED: [50, 50, 50],
                        INTENSE: [200, 100, 200],
                        OVERWHELMED: [50, 50, 50, 50, 50]
                    };
                    
                    navigator.vibrate(patterns[state]);
                    console.log(`[NeuroSymphonic]  Haptic feedback for ${state}`);
                }
            }
            
            notifyStateChange(fromState, toState) {
                // Dispatch custom event for other systems to listen
                const event = new CustomEvent('emotionalStateChange', {
                    detail: {
                        from: fromState,
                        to: toState,
                        timestamp: Date.now()
                    }
                });
                window.dispatchEvent(event);
            }
            
            processVoiceCommand(command) {
                const commandLower = command.toLowerCase().trim();
                
                // Check for exact matches first
                if (this.voiceCommands.has(commandLower)) {
                    this.voiceCommands.get(commandLower)();
                    return true;
                }
                
                // Check for partial matches
                for (const [pattern, action] of this.voiceCommands) {
                    if (commandLower.includes(pattern)) {
                        action();
                        return true;
                    }
                }
                
                console.log('[NeuroSymphonic]  Unknown voice command:', command);
                return false;
            }
            
            getEmotionalState() {
                return this.emotionalState;
            }
            
            getEmotionalContext() {
                return {
                    state: this.emotionalState,
                    colors: this.visualEffects.colors[this.emotionalState],
                    animation: this.visualEffects.animations[this.emotionalState],
                    history: this.stateHistory.slice(-10), // Last 10 state changes
                    timestamp: Date.now()
                };
            }
            
            getEmotionalGuidance() {
                const guidance = {
                    CALM: {
                        description: 'Relaxed and creative state',
                        bestFor: ['Creative tasks', 'Brainstorming', 'Learning new concepts'],
                        tips: ['Take deep breaths', 'Work in a comfortable environment', 'Allow ideas to flow naturally'],
                        color: '#4A90E2'
                    },
                    FOCUSED: {
                        description: 'Concentrated and precise state',
                        bestFor: ['Technical work', 'Debugging', 'Detailed analysis'],
                        tips: ['Eliminate distractions', 'Work in focused time blocks', 'Use detailed checklists'],
                        color: '#F5A623'
                    },
                    INTENSE: {
                        description: 'High energy and aggressive state',
                        bestFor: ['Problem solving', 'Performance optimization', 'Quick iterations'],
                        tips: ['Work in short bursts', 'Focus on speed and efficiency', 'Take regular breaks'],
                        color: '#D0021B'
                    },
                    OVERWHELMED: {
                        description: 'Simplified and step-by-step state',
                        bestFor: ['Complex problems', 'Learning basics', 'Breaking down tasks'],
                        tips: ['Take one step at a time', 'Ask for help when needed', 'Simplify the problem'],
                        color: '#8E44AD'
                    }
                };
                
                return guidance[this.emotionalState];
            }
            
            startEmotionalMonitoring() {
                // Monitor for automatic state changes based on context
                setInterval(() => {
                    this.analyzeContextualState();
                }, 30000); // Check every 30 seconds
                
                console.log('[NeuroSymphonic]  Emotional monitoring started');
            }
            
            analyzeContextualState() {
                // Simple contextual analysis (can be enhanced)
                const currentTime = new Date();
                const hour = currentTime.getHours();
                
                // Automatic state suggestions based on time
                if (hour >= 6 && hour < 9) {
                    // Morning - suggest FOCUSED
                    if (this.emotionalState === 'OVERWHELMED') {
                        console.log('[NeuroSymphonic]  Morning detected - suggesting FOCUSED state');
                    }
                } else if (hour >= 22 || hour < 6) {
                    // Night - suggest CALM
                    if (this.emotionalState === 'INTENSE') {
                        console.log('[NeuroSymphonic]  Night detected - suggesting CALM state');
                    }
                }
            }
            
            cycleEmotionalState() {
                const states = ['CALM', 'FOCUSED', 'INTENSE', 'OVERWHELMED'];
                const currentIndex = states.indexOf(this.emotionalState);
                const nextIndex = (currentIndex + 1) % states.length;
                
                this.setEmotionalState(states[nextIndex]);
                return states[nextIndex];
            }
            
            getStateStatistics() {
                const stats = {
                    totalChanges: this.stateHistory.length,
                    timeInCurrentState: this.stateHistory.length > 0 ? 
                        Date.now() - this.stateHistory[this.stateHistory.length - 1].timestamp : 0,
                    stateDistribution: {},
                    averageStateDuration: 0
                };
                
                // Calculate state distribution
                this.stateHistory.forEach(change => {
                    stats.stateDistribution[change.to] = (stats.stateDistribution[change.to] || 0) + 1;
                });
                
                // Calculate average duration
                if (this.stateHistory.length > 1) {
                    const totalDuration = this.stateHistory.reduce((sum, change) => sum + change.duration, 0);
                    stats.averageStateDuration = totalDuration / (this.stateHistory.length - 1);
                }
                
                return stats;
            }
            
            exportEmotionalData() {
                return {
                    currentState: this.emotionalState,
                    stateHistory: this.stateHistory,
                    statistics: this.getStateStatistics(),
                    voiceCommands: Array.from(this.voiceCommands.keys()),
                    timestamp: Date.now()
                };
            }
            
            reset() {
                this.emotionalState = 'CALM';
                this.stateHistory = [];
                this.updateVisualEffects('CALM');
                console.log('[NeuroSymphonic]  Emotional system reset');
            }
        }

        // Initialize the application
        let bigDaddyG, neuroSymphonic;

        // Initialize systems
        function initializeApp() {
            console.log('[App]  Initializing BigDaddyG Standalone IDE...');
            
            try {
            // Initialize AI engine
                if (typeof BigDaddyGEngine !== 'undefined') {
            bigDaddyG = new BigDaddyGEngine();
                } else {
                    console.error('[App] BigDaddyGEngine not found');
                }
            
            // Initialize emotional intelligence
                if (typeof NeuroSymphonicEngine !== 'undefined') {
            neuroSymphonic = new NeuroSymphonicEngine();
                } else {
                    console.error('[App] NeuroSymphonicEngine not found');
                }
            
                // Sync emotional states if both engines are initialized
                if (bigDaddyG && neuroSymphonic && typeof neuroSymphonic.getEmotionalState === 'function') {
            bigDaddyG.setEmotionalState(neuroSymphonic.getEmotionalState());
                }
            
            // Listen for emotional state changes
            window.addEventListener('emotionalStateChange', (event) => {
                const { to } = event.detail;
                    if (bigDaddyG && typeof bigDaddyG.setEmotionalState === 'function') {
                bigDaddyG.setEmotionalState(to);
                    }
                    if (typeof updateUI === 'function') {
                updateUI();
                    }
            });
            
            // Update UI
                if (typeof updateUI === 'function') {
            updateUI();
                }
            
            // Initialize copilot context menu
            if (typeof initializeContextMenu === 'function') {
                initializeContextMenu();
            }
            
            // Connect micro model WebSocket
            connectMicroModelWebSocket();
            
            console.log('[App]  Initialization complete!');
            } catch (error) {
                console.error('[App] Initialization error:', error);
            }
        }
        
        // ========================================
        // GLOBAL AI INTERFACE WITH OLLAMA SUPPORT
        // ========================================
        
        window.askBigDaddyG = async function(prompt, model = 'BigDaddyG:Latest') {
            console.log(`[AI] Querying model: ${model}`);
            
            // Check if this is an Ollama model (from scanned models)
            const isOllamaModel = model.includes(':') && !model.startsWith('BigDaddyG:');
            
            if (isOllamaModel) {
                // Route to Ollama
                return await queryOllamaModel(prompt, model);
            } else {
                // Use embedded BigDaddyG
                if (bigDaddyG && typeof bigDaddyG.query === 'function') {
                    return await bigDaddyG.query(prompt, model);
                } else {
                    return 'BigDaddyG engine not initialized. Please refresh the page.';
                }
            }
        };
        
        async function queryOllamaModel(prompt, model) {
            try {
                console.log(`[Ollama] Querying ${model} via Orchestra proxy...`);
                
                // Use Orchestra as proxy to Ollama
                const response = await fetch('http://localhost:11441/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: model,
                        prompt: prompt,
                        stream: false,
                        options: {
                            temperature: 0.7,
                            num_predict: 2000
                        }
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Ollama returned ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log(`[Ollama] Response received from ${model}`);
                
                return data.response || data.content || 'No response from Ollama model.';
            } catch (error) {
                console.error('[Ollama] Error:', error);
                return ` Ollama Error: ${error.message}\n\nMake sure Ollama is running and the model "${model}" is available.\nRun: ollama pull ${model.split(':')[0]}`;
            }
        }
        
        window.getBigDaddyGStats = function() {
            if (bigDaddyG && typeof bigDaddyG.getTelemetry === 'function') {
                return bigDaddyG.getTelemetry();
            }
            return { total_queries: 0, avg_response_time: 0 };
        };
        
        window.setEmotionalState = function(state, event) {
            if (neuroSymphonic && typeof neuroSymphonic.setEmotionalState === 'function') {
                neuroSymphonic.setEmotionalState(state);
                updateUI();
            }
        };

        // UI Functions
        function showView(viewName) {
            // Hide all views
            document.querySelectorAll('.view').forEach(view => {
                view.classList.remove('active');
            });
            
            // Show selected view
            document.getElementById(`${viewName}-view`).classList.add('active');
            
            // Update nav buttons
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }

        function updateUI() {
            if (!neuroSymphonic || !bigDaddyG) {
                console.log('[UI] Engines not yet initialized');
                return;
            }
            
            try {
            const emotionalState = neuroSymphonic.getEmotionalState();
            const telemetry = bigDaddyG.getTelemetry();
            
                // Update emotional state displays (with null checks)
                const currentEmotionalEl = document.getElementById('current-emotional-state');
                if (currentEmotionalEl) currentEmotionalEl.textContent = emotionalState;
                
                const statusEmotionalEl = document.getElementById('status-emotional-state');
                if (statusEmotionalEl) statusEmotionalEl.textContent = emotionalState;
                
                const statsStateEl = document.getElementById('stats-state');
                if (statsStateEl) statsStateEl.textContent = emotionalState;
                
                // Update query count (with null checks)
                const totalQueriesEl = document.getElementById('total-queries');
                if (totalQueriesEl) totalQueriesEl.textContent = telemetry.total_queries;
                
                const statsQueriesEl = document.getElementById('stats-queries');
                if (statsQueriesEl) statsQueriesEl.textContent = telemetry.total_queries;
                
                // Update response time (with null checks)
                const statsResponseEl = document.getElementById('stats-response-time');
                if (statsResponseEl) statsResponseEl.textContent = telemetry.avg_response_time + 'ms';
            } catch (error) {
                console.error('[UI] Update error:', error);
            }
        }

        function setEmotionalState(state) {
            if (neuroSymphonic && typeof neuroSymphonic.setEmotionalState === 'function') {
            neuroSymphonic.setEmotionalState(state);
            updateUI();
            } else {
                console.error('[UI] neuroSymphonic not initialized');
            }
        }

        function cycleEmotionalState() {
            if (neuroSymphonic && typeof neuroSymphonic.cycleEmotionalState === 'function') {
            const newState = neuroSymphonic.cycleEmotionalState();
            updateUI();
            return newState;
            } else {
                console.error('[UI] neuroSymphonic not initialized');
                return 'CALM';
            }
        }

        // Chat Functions
        async function sendMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();
            
            if (!message) return;
            
            const model = document.getElementById('ai-model-selector').value;
            
            // Add user message
            addMessage('user', message, model);
            
            // Clear input
            input.value = '';
            
            // Disable send button
            const sendBtn = document.querySelector('.send-btn');
            sendBtn.disabled = true;
            sendBtn.textContent = 'Thinking...';
            
            try {
                // Get AI response
                const response = await bigDaddyG.query(message, model);
                
                // Add AI message
                addMessage('ai', response.content, response.model);
                
                // Update UI
                updateUI();
                
            } catch (error) {
                console.error('Error getting AI response:', error);
                addMessage('ai', 'Sorry, I encountered an error. Please try again.', 'Error');
            } finally {
                // Re-enable send button
                sendBtn.disabled = false;
                sendBtn.textContent = 'Send';
            }
        }

        function addMessage(type, content, model) {
            const messagesContainer = document.getElementById('chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const headerDiv = document.createElement('div');
            headerDiv.className = 'message-header';
            headerDiv.textContent = model;
            
            const contentDiv = document.createElement('div');
            contentDiv.textContent = content;
            
            messageDiv.appendChild(headerDiv);
            messageDiv.appendChild(contentDiv);
            messagesContainer.appendChild(messageDiv);
            
            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function handleChatKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        // Model Testing
        async function testModel(modelName) {
            const testPrompts = {
                'BigDaddyG:Latest': 'Explain quantum computing in simple terms',
                'BigDaddyG:Code': 'Write a Python function to sort a list',
                'BigDaddyG:Debug': 'My Python script is running slowly, how do I debug it?',
                'BigDaddyG:Crypto': 'How do I encrypt sensitive data in Python?'
            };
            
            const prompt = testPrompts[modelName];
            if (!prompt) return;
            
            try {
                const response = await bigDaddyG.query(prompt, modelName);
                alert(`${modelName} Response:\n\n${response.content.substring(0, 500)}...`);
            } catch (error) {
                alert(`Error testing ${modelName}: ${error.message}`);
            }
        }

        async function testAllModels() {
            const models = ['BigDaddyG:Latest', 'BigDaddyG:Code', 'BigDaddyG:Debug', 'BigDaddyG:Crypto'];
            const results = [];
            
            for (const model of models) {
                try {
                    const response = await bigDaddyG.query('Hello, test me!', model);
                    results.push(` ${model}: Working`);
                } catch (error) {
                    results.push(` ${model}: Error - ${error.message}`);
                }
            }
            
            alert('Model Test Results:\n\n' + results.join('\n'));
        }

        // File Management
        function saveFile() {
            const content = document.getElementById('code-editor').value;
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'code.txt';
            a.click();
            
            URL.revokeObjectURL(url);
        }

        function loadFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.txt,.js,.py,.html,.css,.json';
            
            input.onchange = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        document.getElementById('code-editor').value = e.target.result;
                    };
                    reader.readAsText(file);
                }
            };
            
            input.click();
        }

        function newFile() {
            document.getElementById('code-editor').value = '';
        }

        function runCode() {
            const code = document.getElementById('code-editor').value;
            if (!code.trim()) {
                alert('No code to run!');
                return;
            }
            
            // Simple code execution (for demonstration)
            try {
                // This is a basic example - in a real IDE, you'd have proper code execution
                alert('Code execution would happen here!\n\nCode:\n' + code.substring(0, 200) + '...');
            } catch (error) {
                alert('Error running code: ' + error.message);
            }
        }

        // Data Management
        function exportData() {
            const data = {
                bigdaddyg: bigDaddyG.exportHistory(),
                neuroSymphonic: neuroSymphonic.exportEmotionalData(),
                timestamp: Date.now()
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'bigdaddyg-data.json';
            a.click();
            
            URL.revokeObjectURL(url);
        }

        function clearData() {
            if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                bigDaddyG.clearHistory();
                neuroSymphonic.reset();
                document.getElementById('chat-messages').innerHTML = '<div class="message ai"><div class="message-header">BigDaddyG:Latest</div><div>Hello! I\'m BigDaddyG, your AI assistant. How can I help you today?</div></div>';
                updateUI();
                alert('All data cleared!');
            }
        }

        // ========================================
        // MASTER INITIALIZATION - ORCHESTRATION MESH AWAKENING
        // ========================================
        
        document.addEventListener('DOMContentLoaded', async function() {
            log(' ', 'success');
            log(' INITIALIZING BIGDADDYG SELF-MADE BROWSER...', 'success');
            log(' ', 'success');
            
            // Initialize core app
            await initializeApp();
            
            // Initialize all orchestration systems
            log('', 'info');
            log(' Initializing Orchestration Systems...', 'info');
            
            TokenStreamOrchestrator.init();
            log('    Token Stream Orchestrator', 'success');
            
            TaskBubbleSystem.init();
            log('    Task Bubble System', 'success');
            
            EmotionalOrchestrator.init();
            log('    Emotional Orchestrator', 'success');
            
            AgentDashboard.init();
            log('    Agent Dashboard', 'success');
            
            CognitiveBeamSystem.init();
            log('    Cognitive Beam System', 'success');
            
            CosmicBackground.init();
            log('    Cosmic Background', 'success');
            
            ParticleSystem.init();
            log('    Particle System', 'success');
            
            AudioReactiveSystem.init();
            log('    Audio-Reactive System', 'success');
            
            PaneManager.init();
            log('    Pane Manager (Collapse/Expand)', 'success');
            
            BypassSystem.init();
            log('    Bypass System (Adaptive Routing)', 'success');
            
            CinematicConsole.init();
            log('    Cinematic Console Visualizer', 'success');
            
            PowerSavingMode.init();
            log('    Power Saving Mode (30s idle)', 'success');
            
            // Enable animated resizing
            enableAnimatedResizing();
            log('    5-Pane Animated Resizing', 'success');
            
            log(' ', 'success');
            log('', 'info');
            
            // Welcome banner
            log(' ', 'success');
            log('   BigDaddyG Self-Made Browser v2.0              ', 'success');
            log('   A Neuro-Symphonic Orchestration Mesh          ', 'success');
            log('   11,000+ Lines of Cognitive Performance        ', 'success');
            log(' ', 'success');
            log('', 'info');
            
            // Display system status
            log(' SYSTEM STATUS:', 'info');
            log('    Code Lines: 11,232', 'info');
            log('    Orchestration Endpoints: 19', 'info');
            log('    Visual Themes: 10', 'info');
            log('    Emotional States: 4', 'info');
            log('    Agent Systems: 4', 'info');
            log('    Particle Types: 5', 'info');
            log('', 'info');
            
            log(' LIFECYCLE ENDPOINTS:', 'info');
            log('    Symphony & Performance:', 'info');
            log('       symphony() - Full orchestration performance', 'info');
            log('       bounce() - Hydraulic bounce loop', 'info');
            log('       conduct() - Master conductor', 'info');
            log('', 'info');
            log('    Surge & Energy:', 'info');
            log('       ignite() - Emergency surge protocol', 'info');
            log('       sustain() - Meditative pause', 'info');
            log('', 'info');
            log('    Breath & Duality:', 'info');
            log('       inward() - Introspective descent', 'info');
            log('       outward() - Radiant expansion', 'info');
            log('', 'info');
            log('    Closure & Rebirth:', 'info');
            log('       endcloud() - Graceful shutdown', 'info');
            log('       rebirth() - Regenerative awakening', 'info');
            log('', 'info');
            log('    Reflection & Poetry:', 'info');
            log('       reflect() - Emotional introspection', 'info');
            log('       tinyverse() - Compress into poetry', 'info');
            log('', 'info');
            
            log('    VISUAL SYSTEMS:', 'info');
            log('       cosmos() - Activate cosmic starfield', 'info');
            log('       beamMe() - Spawn cognitive beams', 'info');
            log('       neuralLattice() - Neural mesh visualization', 'info');
            log('       theme("matrix") - Apply visual themes', 'info');
            log('       themes() - List all themes', 'info');
            log('       particles("stars") - Ambient effects', 'info');
            log('       startAudioReactive() - Audio modulation', 'info');
            log('', 'info');
            
            log('    EMOTIONAL STATES:', 'info');
            log('        CALM - Balanced, introspective', 'info');
            log('        FOCUSED - Productive, responsive', 'info');
            log('        INTENSE - High activity, multitasking', 'info');
            log('        OVERWHELMED - Critical load, needs reset', 'info');
            log('', 'info');
            
            log(' ', 'success');
            log(' ALL SYSTEMS INITIALIZED - READY FOR ORCHESTRATION', 'success');
            log(' Type help() or commands() to see all endpoints', 'success');
            log(' ', 'success');
            log('', 'info');
            
            // Auto-start cosmic background
            setTimeout(() => {
                log(' Activating cosmic background...', 'info');
                CosmicBackground.activate();
                log(' Cosmos online - you are coding in the stars', 'success');
            }, 2000);
            
            // Spawn initial task bubbles
            setTimeout(() => {
                log(' Spawning initial task bubbles...', 'info');
                TaskBubbleSystem.spawnDefaultTasks();
                log(' Task bubbles active - orchestration mesh alive', 'success');
            }, 3000);
            
            // Final welcome
            setTimeout(() => {
                log('', 'info');
                log(' ', 'success');
                log(' WELCOME TO THE ORCHESTRATION MESH', 'success');
                log(' Where code becomes cognition, and cognition becomes art', 'success');
                log(' ', 'success');
            }, 4000);
        });
        
        // ========================================
        // Initialize BigDaddyG + Neuro-Symphonic (already declared above)
        // ========================================
        bigDaddyG = new BigDaddyGEngine();
        neuroSymphonic = new NeuroSymphonicEngine();
        
        // Link them together
        bigDaddyG.setEmotionalState = (state) => {
            bigDaddyG.emotionalState = state;
            neuroSymphonic.changeState(state);
        };
        
        // Global functions for AI chat
        window.askBigDaddyG = async function(prompt, model = 'BigDaddyG:Latest') {
            const response = await bigDaddyG.query(prompt, model);
            return response;
        };
        
        window.setEmotionalState = function(state) {
            bigDaddyG.setEmotionalState(state);
            log('Emotional state changed to: ' + state, 'info');
        };
        
        window.getBigDaddyGStats = function() {
            if (bigDaddyG && typeof bigDaddyG.getTelemetry === 'function') {
                return bigDaddyG.getTelemetry();
            } else {
                return {
                    total_queries: 0,
                    avg_response_time: 0,
                    by_model: {},
                    by_emotional_state: {}
                };
            }
        };
        
        if (bigDaddyG && bigDaddyG.models) {
        console.log('[IDE]  BigDaddyG AI engines loaded successfully!');
        console.log('[IDE]  Models:', Object.keys(bigDaddyG.models));
        console.log('[IDE]  Emotional state:', bigDaddyG.emotionalState);
        } else {
            console.log('[IDE]  BigDaddyG AI engines initialization pending...');
        }


        // ========================================
        // BIGDADDYG AI CHAT FUNCTIONS
        // ========================================
        let currentAIModel = 'BigDaddyG:Latest';
        
        function selectAIModel(model) {
            currentAIModel = model;
            document.getElementById('ai-current-model').textContent = model;
            
            // Update button styles
            document.querySelectorAll('.ai-model-btn').forEach(btn => {
                btn.classList.remove('ai-model-active');
                btn.style.opacity = '0.6';
            });
            
            const modelMap = {
                'BigDaddyG:Latest': 'model-latest',
                'BigDaddyG:Code': 'model-code',
                'BigDaddyG:Debug': 'model-debug',
                'BigDaddyG:Crypto': 'model-crypto'
            };
            
            const activeBtn = document.getElementById(modelMap[model]);
            if (activeBtn) {
                activeBtn.classList.add('ai-model-active');
                activeBtn.style.opacity = '1';
            }
            
            log(`AI Model switched to: ${model}`, 'info');
        }
        
        async function sendToAI() {
            const input = document.getElementById('ai-input');
            if (!input) {
                console.error('AI input element not found');
                return;
            }
            const prompt = input.value.trim();
            
            if (!prompt) {
                log('Please enter a message', 'error');
                return;
            }
            
            // Clear input
            input.value = '';
            
            // Add user message to chat
            const chatContainer = document.getElementById('ai-chat-container');
            if (!chatContainer) {
                console.error('AI chat container not found');
                return;
            }
            const userMsg = document.createElement('div');
            userMsg.className = 'ai-message';
            userMsg.style.cssText = 'margin-bottom: 10px; padding: 8px; background: rgba(255, 107, 53, 0.1); border-left: 3px solid var(--orange); color: var(--orange); font-size: 12px;';
            userMsg.innerHTML = `<strong>You:</strong> ${prompt}`;
            chatContainer.appendChild(userMsg);
            
            // Scroll to bottom
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            // Show thinking indicator
            const thinkingMsg = document.createElement('div');
            thinkingMsg.className = 'ai-message thinking';
            thinkingMsg.style.cssText = 'margin-bottom: 10px; padding: 8px; background: rgba(0, 212, 255, 0.1); border-left: 3px solid var(--cyan); color: var(--cyan); font-size: 12px;';
            thinkingMsg.innerHTML = `<strong>${currentSelectedModel.name}:</strong> <em>Thinking...</em>`;
            chatContainer.appendChild(thinkingMsg);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            try {
                let responseText = '';
                
                // Use Orchestra/Ollama backend if model is selected from scanner
                if (currentSelectedModel.backend) {
                    log(` Using ${currentSelectedModel.source} backend: ${currentSelectedModel.name}`, 'info');
                    
                    const response = await fetch(`${currentSelectedModel.backend}/api/generate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: currentSelectedModel.name,
                            prompt: prompt,
                            stream: false
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`${currentSelectedModel.source} returned ${response.status}`);
                    }
                    
                    const data = await response.json();
                    responseText = data.response || data.content || data.message || 'No response received';
                    
                    log(` Response from ${currentSelectedModel.source} backend`, 'success');
                } else {
                    // Use embedded BigDaddyG engine
                    log(` Using embedded BigDaddyG engine`, 'info');
                const response = await window.askBigDaddyG(prompt, currentAIModel);
                    responseText = typeof response === 'object' ? (response.content || response.message || JSON.stringify(response)) : response;
                }
                
                // Remove thinking indicator
                chatContainer.removeChild(thinkingMsg);
                
                // Add AI response
                const aiMsg = document.createElement('div');
                aiMsg.className = 'ai-message';
                aiMsg.style.cssText = 'margin-bottom: 10px; padding: 8px; background: rgba(0, 212, 255, 0.1); border-left: 3px solid var(--cyan); color: var(--cyan); font-size: 12px; white-space: pre-wrap; font-family: monospace;';
                aiMsg.innerHTML = `<strong>${currentSelectedModel.name} (${currentSelectedModel.source}):</strong>\n\n${responseText}`;
                chatContainer.appendChild(aiMsg);
                
                // Update stats
                const stats = window.getBigDaddyGStats();
                document.getElementById('ai-query-count').textContent = stats.total_queries;
                document.getElementById('ai-avg-response').textContent = stats.avg_response_time + 'ms';
                
                // Scroll to bottom
                chatContainer.scrollTop = chatContainer.scrollHeight;
                
                log(`AI response generated (${currentSelectedModel.name})`, 'success');
            } catch (error) {
                // Remove thinking indicator
                if (thinkingMsg.parentNode) {
                chatContainer.removeChild(thinkingMsg);
                }
                
                // Fallback to embedded BigDaddyG
                try {
                    log(` Backend failed, using embedded BigDaddyG fallback`, 'warning');
                    const fallbackResponse = await window.askBigDaddyG(prompt, 'BigDaddyG:Latest');
                    const fallbackText = typeof fallbackResponse === 'object' ? (fallbackResponse.content || fallbackResponse.message || JSON.stringify(fallbackResponse)) : fallbackResponse;
                    
                    const aiMsg = document.createElement('div');
                    aiMsg.className = 'ai-message';
                    aiMsg.style.cssText = 'margin-bottom: 10px; padding: 8px; background: rgba(0, 212, 255, 0.1); border-left: 3px solid var(--cyan); color: var(--cyan); font-size: 12px; white-space: pre-wrap; font-family: monospace;';
                    aiMsg.innerHTML = `<strong>BigDaddyG (Embedded Fallback):</strong>\n\n${fallbackText}`;
                    chatContainer.appendChild(aiMsg);
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                    
                    log(` Fallback response generated`, 'success');
                } catch (fallbackError) {
                // Show error
                const errorMsg = document.createElement('div');
                errorMsg.className = 'ai-message';
                errorMsg.style.cssText = 'margin-bottom: 10px; padding: 8px; background: rgba(255, 71, 87, 0.1); border-left: 3px solid var(--red); color: var(--red); font-size: 12px;';
                    errorMsg.innerHTML = `<strong>Error:</strong> ${error.message}<br><br>Start Orchestra or Ollama backend with: <strong>START-FULL-SYSTEM.bat</strong>`;
                chatContainer.appendChild(errorMsg);
                chatContainer.scrollTop = chatContainer.scrollHeight;
                
                    log('AI error: ' + error.message, 'error');
                }
            }
        }
        
        function handleAIKeyPress(event) {
            if (event.key === 'Enter') {
                sendToAI();
            }
        }
        
        function clearAIChat() {
            const chatContainer = document.getElementById('ai-chat-container');
            chatContainer.innerHTML = `<div class="ai-message" style="margin-bottom: 10px; padding: 8px; background: rgba(0, 212, 255, 0.1); border-left: 3px solid var(--cyan); color: var(--cyan); font-size: 12px;">
                <strong>BigDaddyG:</strong> Chat cleared. Ready for new questions!
            </div>`;
            log('AI chat cleared', 'info');
        }
        
        function setEmotionalState(state, event) {
            window.setEmotionalState(state);
            const currentEmotionEl = document.getElementById('current-emotion');
            if (currentEmotionEl) {
                currentEmotionEl.textContent = state;
            }
            
            // Update emotion button styles
            document.querySelectorAll('.emotion-btn').forEach(btn => {
                btn.style.opacity = '0.5';
            });
            
            // Highlight the clicked button if event is provided
            if (event && event.target) {
            event.target.style.opacity = '1';
            }
        }

        // ========================================
        // BACKEND CONTROL FUNCTIONS
        // ========================================
        let orchestraRunning = false;
        let ollamaRunning = false;
        let agentsRunning = false;
        let microModelsRunning = false;
        
        async function toggleOrchestra() {
            const btn = document.getElementById('orchestra-control-btn');
            const status = document.getElementById('orchestra-status');
            
            if (!orchestraRunning) {
                // Check Orchestra
                log(' Checking Orchestra server...', 'info');
                btn.textContent = ' Checking...';
                btn.disabled = true;
                
                try {
                    const response = await fetch('http://localhost:11441/health', { method: 'GET' });
                    if (response.ok) {
                        const data = await response.json();
                        orchestraRunning = true;
                        status.innerHTML = ` Orchestra (${data.models_found || 300})`;
                        status.style.color = 'var(--green)';
                        btn.textContent = ' Stop';
                        btn.style.background = 'var(--red)';
                        btn.disabled = false;
                        log(' Orchestra is running!', 'success');
                        log(` Models: ${data.models_found || 300}, Agents: ${data.agents_found || 57}`, 'info');
                    } else {
                        throw new Error('Not running');
                    }
                } catch (error) {
                    status.innerHTML = ' Orchestra';
                    status.style.color = 'var(--red)';
                    btn.textContent = ' Start';
                    btn.style.background = 'var(--cyan)';
                    btn.disabled = false;
                    log(' Orchestra not found', 'error');
                    alert('To start Orchestra:\n\n1. Run START-FULL-SYSTEM.bat\n2. Or run: cd server && node Orchestra-Server.js\n\nThen click Start again.');
                }
            } else {
                // Stop Orchestra
                log(' To stop Orchestra, close the server terminal window', 'warning');
                alert('To stop Orchestra:\n\nClose the Orchestra server terminal window');
            }
        }
        
        async function toggleOllama() {
            const btn = document.getElementById('ollama-control-btn');
            const status = document.getElementById('ollama-status');
            
            if (!ollamaRunning) {
                // Check Ollama
                log(' Checking Ollama...', 'info');
                btn.textContent = ' Checking...';
                btn.disabled = true;
                
                try {
                    const response = await fetch('http://127.0.0.1:11434/api/tags', { method: 'GET' });
                    if (response.ok) {
                        const data = await response.json();
                        const modelCount = data.models ? data.models.length : 0;
                        ollamaRunning = true;
                        status.innerHTML = ` Ollama (${modelCount})`;
                        status.style.color = 'var(--green)';
                        btn.textContent = ' Stop';
                        btn.style.background = 'var(--red)';
                        btn.disabled = false;
                        log(' Ollama is running!', 'success');
                        log(` ${modelCount} Ollama models available`, 'info');
                    } else {
                        throw new Error('Not running');
                    }
                } catch (error) {
                    status.innerHTML = ' Ollama';
                    status.style.color = 'var(--red)';
                    btn.textContent = ' Start';
                    btn.style.background = 'var(--cyan)';
                    btn.disabled = false;
                    log(' Ollama not found', 'error');
                    alert('To start Ollama:\n\n1. Run START-OLLAMA-WITH-CORS.bat\n2. Or run in terminal: ollama serve\n\nThen click Start again.');
                }
            } else {
                // Stop Ollama
                log(' To stop Ollama, press Ctrl+C in the Ollama terminal', 'warning');
                alert('To stop Ollama:\n\nPress Ctrl+C in the Ollama terminal window');
            }
        }
        
        async function toggleAgents() {
            const btn = document.getElementById('agents-control-btn');
            const status = document.getElementById('ws-status');
            
            if (!agentsRunning) {
                // Start Agents
                log(' Checking Agent WebSocket...', 'info');
                btn.textContent = ' Checking...';
                btn.disabled = true;
                
                try {
                    // Try to connect to WebSocket
                    const testWS = new WebSocket('ws://localhost:8001');
                    
                    testWS.onopen = () => {
                        agentsRunning = true;
                        status.innerHTML = ' Agents';
                        status.style.color = 'var(--green)';
                        btn.textContent = ' Stop';
                        btn.style.background = 'var(--red)';
                        btn.disabled = false;
                        log(' Agent WebSocket is running!', 'success');
                        testWS.close();
                        
                        // Reconnect the main WebSocket
                        connectWebSocket();
                    };
                    
                    testWS.onerror = () => {
                        agentsRunning = false;
                        status.innerHTML = ' Agents';
                        status.style.color = 'var(--red)';
                        btn.textContent = ' Start';
                        btn.style.background = 'var(--cyan)';
                        btn.disabled = false;
                        log(' Agent server not found', 'error');
                        alert('To start Agent WebSocket:\n\n1. Run START-FULL-SYSTEM.bat\n2. Or run: cd server && node Agent-WebSocket-Server.js\n\nThen click Start again.');
                    };
                    
                    // Timeout after 3 seconds
                    setTimeout(() => {
                        if (!agentsRunning) {
                            btn.textContent = ' Start';
                            btn.disabled = false;
                        }
                    }, 3000);
                } catch (error) {
                    status.innerHTML = ' Agents';
                    status.style.color = 'var(--red)';
                    btn.textContent = ' Start';
                    btn.style.background = 'var(--cyan)';
                    btn.disabled = false;
                    log(' Could not connect to Agent WebSocket', 'error');
                }
            } else {
                // Stop Agents
                log(' To stop Agents, close the Agent WebSocket terminal window', 'warning');
                alert('To stop Agent WebSocket:\n\nClose the Agent-WebSocket-Server terminal window');
            }
        }
        
        async function toggleMicroModels() {
            const btn = document.getElementById('micro-models-control-btn');
            const status = document.getElementById('micro-models-status');
            
            if (!microModelsRunning) {
                // Start Micro Models
                log(' Checking Micro Model Server...', 'info');
                btn.textContent = ' Checking...';
                btn.disabled = true;
                
                try {
                    const response = await fetch('http://localhost:3000/health', { method: 'GET' });
                    if (response.ok) {
                        microModelsRunning = true;
                        status.innerHTML = ' Minis (4)';
                        status.style.color = 'var(--green)';
                        btn.textContent = ' Stop';
                        btn.style.background = 'var(--red)';
                        btn.disabled = false;
                        log(' Micro Model Server is running!', 'success');
                        log(' Mini models: gpt-micro, code-nano, chat-tiny, analyzer-small', 'info');
                    } else {
                        throw new Error('Not running');
                    }
                } catch (error) {
                    status.innerHTML = ' Minis';
                    status.style.color = 'var(--red)';
                    btn.textContent = ' Start';
                    btn.style.background = 'var(--cyan)';
                    btn.disabled = false;
                    log(' Micro Model Server not found', 'error');
                    alert('To start Micro Model Server:\n\n1. Run START-FULL-SYSTEM.bat\n2. Or run: cd server && node Micro-Model-Server.js\n\nThen click Start again.');
                }
            } else {
                // Stop Micro Models
                log(' To stop Micro Models, close the Micro Model Server terminal window', 'warning');
                alert('To stop Micro Model Server:\n\nClose the Micro-Model-Server terminal window');
            }
        }
        
        // ========================================
        // MODEL SCANNER SYSTEM
        // ========================================
        let scannedModels = [];
        let currentSelectedModel = { name: 'BigDaddyG:Latest', source: 'embedded', backend: null };
        
        function openModelScanner() {
            const modal = document.getElementById('model-scanner-modal');
            modal.style.display = 'flex';
            log(' Model Scanner opened', 'info');
        }
        
        function closeModelScanner() {
            const modal = document.getElementById('model-scanner-modal');
            modal.style.display = 'none';
            log(' Model Scanner closed', 'info');
        }
        
        async function scanAllModels() {
            log(' Starting full model scan...', 'info');
            const scanBtn = document.getElementById('scan-all-btn');
            const container = document.getElementById('model-list-container');
            
            scanBtn.classList.add('scanning');
            scanBtn.textContent = ' Scanning...';
            
            container.innerHTML = '<div style="padding: 40px; text-align: center; color: var(--cyan); font-family: \'Courier New\', monospace;"> Scanning backends for models...</div>';
            
            scannedModels = [];
            
            // Scan both Orchestra and Ollama
            await scanOrchestra(false);
            await scanOllama(false);
            
            // Update stats
            updateModelStats();
            renderModelList();
            populateModelDropdown(); // Add models to dropdown
            
            scanBtn.classList.remove('scanning');
            if (scannedModels.length > 0) {
                scanBtn.textContent = ` Found ${scannedModels.length} Models`;
            } else {
                scanBtn.textContent = ' No Models Found';
            }
            setTimeout(() => {
                scanBtn.textContent = ' Scan All Sources';
            }, 3000);
            
            log(` Scan complete! Found ${scannedModels.length} models`, scannedModels.length > 0 ? 'success' : 'warning');
        }
        
        async function scanOrchestra(updateUI = true) {
            log(' Scanning Orchestra backend...', 'info');
            
            try {
                const response = await fetch('http://localhost:11441/api/tags');
                if (!response.ok) throw new Error('Orchestra not available');
                
                const data = await response.json();
                
                // Handle both Orchestra format (data array) and Ollama format (models array)
                let models = [];
                if (data.data && Array.isArray(data.data)) {
                    // Orchestra format: { object: 'list', data: [{id, object, details}] }
                    models = data.data;
                } else if (data.models && Array.isArray(data.models)) {
                    // Ollama format: { models: [{name, size, modified_at}] }
                    models = data.models;
                } else {
                    models = [];
                }
                
                for (const model of models) {
                    const details = model.details || {};
                    const modelSize = model.size;
                    let sizeDisplay;
                    
                    if (modelSize === 'Algorithmic') {
                        sizeDisplay = 'Algorithmic';
                    } else if (typeof modelSize === 'number') {
                        sizeDisplay = `${(modelSize / 1024 / 1024 / 1024).toFixed(2)} GB`;
                    } else {
                        sizeDisplay = modelSize || 'Unknown';
                    }
                    
                    scannedModels.push({
                        name: model.id || model.name,
                        size: sizeDisplay,
                        modified: model.modified_at || 'Unknown',
                        source: 'orchestra',
                        backend: 'http://localhost:11441',
                        parameters: details.parameter_size || 'Unknown',
                        quantization: details.quantization_level || '',
                        family: details.family || '',
                        format: details.format || ''
                    });
                }
                
                log(` Found ${models.length} models from Orchestra`, 'success');
                
                if (updateUI) {
                    updateModelStats();
                    renderModelList();
                }
            } catch (error) {
                log(` Orchestra scan failed: ${error.message}`, 'error');
            }
        }
        
        async function scanOllama(updateUI = true) {
            log(' Scanning Ollama via Orchestra proxy...', 'info');
            
            try {
                // Use Orchestra as a CORS proxy to Ollama
                const response = await fetch('http://localhost:11441/api/ollama/tags');
                if (!response.ok) throw new Error('Ollama not available');
                
                const data = await response.json();
                
                // Check for error response
                if (data.error) {
                    throw new Error(data.error);
                }
                
                const models = data.models || [];
                
                log(` Processing ${models.length} Ollama models...`, 'info');
                
                for (const model of models) {
                    // Extract additional details
                    const details = model.details || {};
                    const paramSize = details.parameter_size || 'Unknown';
                    const quantization = details.quantization_level || '';
                    const family = details.family || '';
                    
                    scannedModels.push({
                        name: model.name,
                        size: model.size ? `${(model.size / 1024 / 1024 / 1024).toFixed(2)} GB` : 'Unknown',
                        modified: model.modified_at || 'Unknown',
                        source: 'ollama',
                        backend: 'http://localhost:11434',
                        parameters: paramSize,
                        quantization: quantization,
                        family: family,
                        digest: model.digest ? model.digest.substring(0, 12) + '...' : ''
                    });
                }
                
                log(` Found ${models.length} models from Ollama (via Orchestra proxy)`, 'success');
                
                if (updateUI) {
                    updateModelStats();
                    renderModelList();
                }
            } catch (error) {
                log(` Ollama scan failed: ${error.message}`, 'error');
            }
        }
        
        function updateModelStats() {
            const totalCount = scannedModels.length;
            const orchestraCount = scannedModels.filter(m => m.source === 'orchestra').length;
            const ollamaCount = scannedModels.filter(m => m.source === 'ollama').length;
            
            // Calculate total storage
            let totalGB = 0;
            scannedModels.forEach(m => {
                const size = parseFloat(m.size);
                if (!isNaN(size)) {
                    totalGB += size;
                }
            });
            
            document.getElementById('total-models-count').textContent = `${totalCount} (${totalGB.toFixed(2)} GB)`;
            document.getElementById('orchestra-models-count').textContent = orchestraCount;
            document.getElementById('ollama-models-count').textContent = ollamaCount;
            document.getElementById('selected-model-name').textContent = currentSelectedModel.name;
            
            // Log storage stats
            if (totalGB > 0) {
                log(` Total storage: ${totalGB.toFixed(2)} GB across ${totalCount} models`, 'info');
            }
        }
        
        function renderModelList() {
            const container = document.getElementById('model-list-container');
            
            if (scannedModels.length === 0) {
                container.innerHTML = '<div style="padding: 40px; text-align: center; color: var(--red); font-family: \'Courier New\', monospace;">No models found. Make sure Orchestra or Ollama is running.</div>';
                return;
            }
            
            container.innerHTML = '';
            
            // Sort models by size (largest first) for better organization
            const sortedModels = [...scannedModels].sort((a, b) => {
                const sizeA = parseFloat(a.size) || 0;
                const sizeB = parseFloat(b.size) || 0;
                return sizeB - sizeA;
            });
            
            sortedModels.forEach((model, sortedIndex) => {
                const originalIndex = scannedModels.indexOf(model);
                const modelItem = document.createElement('div');
                modelItem.className = 'model-item';
                modelItem.id = `model-item-${originalIndex}`;
                
                if (model.name === currentSelectedModel.name) {
                    modelItem.classList.add('selected');
                }
                
                // Build detailed info string
                let detailsHTML = `Size: ${model.size}`;
                
                if (model.parameters && model.parameters !== 'Unknown') {
                    detailsHTML += ` | Params: ${model.parameters}`;
                }
                
                if (model.quantization) {
                    detailsHTML += ` | Quant: ${model.quantization}`;
                }
                
                if (model.family) {
                    detailsHTML += ` | Family: ${model.family}`;
                }
                
                detailsHTML += ` | Modified: ${formatDate(model.modified)}`;
                
                modelItem.innerHTML = `
                    <div class="model-info">
                        <div class="model-name">${model.name}</div>
                        <div class="model-details">
                            ${detailsHTML}
                        </div>
                    </div>
                    <span class="model-source ${model.source}">${model.source.toUpperCase()}</span>
                    <button class="model-select-btn" onclick="selectModel(${originalIndex})"> Select</button>
                `;
                
                container.appendChild(modelItem);
            });
            
            // Add performance note for large lists
            if (scannedModels.length > 50) {
                const perfNote = document.createElement('div');
                perfNote.style.cssText = 'padding: 15px; text-align: center; color: var(--cyan); font-size: 11px; border-top: 1px solid var(--cyan);';
                perfNote.innerHTML = ` Showing ${scannedModels.length} models (sorted by size) | Use search to filter`;
                container.appendChild(perfNote);
            }
        }
        
        function selectModel(index) {
            const model = scannedModels[index];
            currentSelectedModel = model;
            
            // Update selected model display
            document.getElementById('selected-model-name').textContent = model.name;
            document.getElementById('current-model-display').textContent = `Current: ${model.name}`;
            
            // Update selection in list
            document.querySelectorAll('.model-item').forEach(item => {
                item.classList.remove('selected');
            });
            document.getElementById(`model-item-${index}`).classList.add('selected');
            
            // Update the currentAIModel variable for sendToAI
            currentAIModel = model.name;
            
            // Update the dropdown to reflect the selected model
            const dropdown = document.getElementById('model-selector-dropdown');
            if (dropdown) {
                const optionValue = `${model.source}:${model.name}`;
                dropdown.value = optionValue;
            }
            
            log(` Selected model: ${model.name} from ${model.source}`, 'success');
            
            // Close scanner after selection
            setTimeout(() => {
                closeModelScanner();
            }, 500);
        }
        
        // Handle model selection from dropdown
        function selectModelFromDropdown() {
            const dropdown = document.getElementById('model-selector-dropdown');
            const selectedValue = dropdown.value;
            
            if (selectedValue.startsWith('embedded:')) {
                // Embedded BigDaddyG model selected
                const modelName = selectedValue.replace('embedded:', '');
                currentSelectedModel = { name: modelName, source: 'embedded', backend: null };
                currentAIModel = modelName;
                document.getElementById('current-model-display').textContent = `Current: ${modelName}`;
                log(` Selected embedded model: ${modelName}`, 'success');
            } else {
                // Find the model in scannedModels (Orchestra or Ollama)
                const [source, ...nameParts] = selectedValue.split(':');
                const modelName = nameParts.join(':');
                const model = scannedModels.find(m => m.name === modelName && m.source === source);
                
                if (model) {
                    currentSelectedModel = model;
                    currentAIModel = model.name; // This will be used by askBigDaddyG to route to Ollama
                    document.getElementById('current-model-display').textContent = `Current: ${model.name}`;
                    
                    if (source === 'ollama') {
                        log(` Selected Ollama model: ${model.name} - will chat through Orchestra proxy`, 'success');
                        log(` Model size: ${model.size} | Family: ${model.family || 'Unknown'}`, 'info');
                    } else {
                        log(` Selected ${source} model: ${model.name}`, 'success');
                    }
                }
            }
        }
        
        // Populate dropdown with scanned models
        function populateModelDropdown() {
            const dropdown = document.getElementById('model-selector-dropdown');
            if (!dropdown) return;
            
            // Keep embedded models, add scanned models
            const embeddedOptions = Array.from(dropdown.querySelectorAll('option[value^="embedded:"]'));
            dropdown.innerHTML = '';
            
            // Re-add embedded models
            embeddedOptions.forEach(opt => dropdown.appendChild(opt));
            
            // Add separator if we have scanned models
            if (scannedModels.length > 0) {
                const separator = document.createElement('option');
                separator.disabled = true;
                separator.textContent = '';
                dropdown.appendChild(separator);
            }
            
            // Group models by source
            const orchestraModels = scannedModels.filter(m => m.source === 'orchestra');
            const ollamaModels = scannedModels.filter(m => m.source === 'ollama');
            
            if (orchestraModels.length > 0) {
                const orchestraHeader = document.createElement('option');
                orchestraHeader.disabled = true;
                orchestraHeader.textContent = ' ORCHESTRA MODELS';
                orchestraHeader.style.fontWeight = 'bold';
                dropdown.appendChild(orchestraHeader);
                
                orchestraModels.forEach(model => {
                    const option = document.createElement('option');
                    option.value = `${model.source}:${model.name}`;
                    option.textContent = `${model.name} (${model.size})`;
                    dropdown.appendChild(option);
                });
            }
            
            if (ollamaModels.length > 0) {
                const ollamaHeader = document.createElement('option');
                ollamaHeader.disabled = true;
                ollamaHeader.textContent = ' OLLAMA MODELS';
                ollamaHeader.style.fontWeight = 'bold';
                dropdown.appendChild(ollamaHeader);
                
                ollamaModels.forEach(model => {
                    const option = document.createElement('option');
                    option.value = `${model.source}:${model.name}`;
                    option.textContent = `${model.name} (${model.size})`;
                    dropdown.appendChild(option);
                });
            }
            
            log(` Dropdown populated with ${scannedModels.length} models`, 'success');
        }
        
        function filterModels() {
            const searchInput = document.getElementById('model-search-input');
            const searchTerm = searchInput.value.toLowerCase();
            
            const filteredModels = scannedModels.filter(model => 
                model.name.toLowerCase().includes(searchTerm)
            );
            
            const container = document.getElementById('model-list-container');
            container.innerHTML = '';
            
            if (filteredModels.length === 0) {
                container.innerHTML = '<div style="padding: 40px; text-align: center; color: var(--yellow); font-family: \'Courier New\', monospace;">No models match your search.</div>';
                return;
            }
            
            filteredModels.forEach((model, index) => {
                const originalIndex = scannedModels.indexOf(model);
                const modelItem = document.createElement('div');
                modelItem.className = 'model-item';
                modelItem.id = `model-item-${originalIndex}`;
                
                if (model.name === currentSelectedModel.name) {
                    modelItem.classList.add('selected');
                }
                
                modelItem.innerHTML = `
                    <div class="model-info">
                        <div class="model-name">${model.name}</div>
                        <div class="model-details">
                            Size: ${model.size} | Modified: ${formatDate(model.modified)} | Backend: ${model.backend}
                        </div>
                    </div>
                    <span class="model-source ${model.source}">${model.source.toUpperCase()}</span>
                    <button class="model-select-btn" onclick="selectModel(${originalIndex})"> Select</button>
                `;
                
                container.appendChild(modelItem);
            });
        }
        
        function formatDate(dateString) {
            if (!dateString || dateString === 'Unknown') return 'Unknown';
            const date = new Date(dateString);
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
        }
        
        // ========================================
        // BIGDADDYG PARAMETER TUNER
        // ========================================
        
        async function openBigDaddyGTuner() {
            log(' Opening BigDaddyG parameter tuner...', 'info');
            
            // Fetch current parameters from Orchestra
            let currentParams = {
                temperature: 0.7,
                top_p: 0.9,
                top_k: 40,
                max_tokens: 4000,
                response_style: 'detailed',
                code_quality: 'production',
                explanation_level: 'expert'
            };
            
            try {
                const response = await fetch('http://localhost:11441/api/parameters');
                if (response.ok) {
                    const data = await response.json();
                    currentParams = data.parameters;
                }
            } catch (error) {
                log(' Using default parameters (Orchestra offline)', 'warning');
            }
            
            // Create modal
            const modal = document.createElement('div');
            modal.id = 'bigdaddyg-tuner-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 100000;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: rgba(10, 10, 30, 0.95);
                    backdrop-filter: blur(20px);
                    border: 2px solid var(--purple);
                    border-radius: 15px;
                    padding: 25px;
                    max-width: 700px;
                    width: 90%;
                    max-height: 80vh;
                    overflow-y: auto;
                    box-shadow: 0 10px 50px rgba(138,43,226,0.5);
                ">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid var(--purple);">
                        <h2 style="color: var(--purple); margin: 0;"> BigDaddyG Parameter Tuner</h2>
                        <button onclick="closeBigDaddyGTuner()" style="background: var(--red); color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;"> Close</button>
                    </div>
                    
                    <div style="color: var(--cyan); margin-bottom: 20px; font-size: 12px; background: rgba(0,212,255,0.1); padding: 10px; border-radius: 5px;">
                         <strong>Tune BigDaddyG's behavior</strong> - Adjust temperature, style, and quality settings
                    </div>
                    
                    <!-- Temperature -->
                    <div style="margin-bottom: 20px;">
                        <label style="color: var(--cyan); font-weight: bold; display: block; margin-bottom: 8px;">
                             Temperature: <span id="temp-value" style="color: var(--orange);">${currentParams.temperature}</span>
                        </label>
                        <input type="range" id="temp-slider" min="0" max="2" step="0.1" value="${currentParams.temperature}" 
                            style="width: 100%;" 
                            oninput="document.getElementById('temp-value').textContent = this.value">
                        <div style="display: flex; justify-content: space-between; font-size: 10px; color: #888; margin-top: 5px;">
                            <span>0.0 (Deterministic)</span>
                            <span>1.0 (Balanced)</span>
                            <span>2.0 (Creative)</span>
                        </div>
                    </div>
                    
                    <!-- Max Tokens -->
                    <div style="margin-bottom: 20px;">
                        <label style="color: var(--cyan); font-weight: bold; display: block; margin-bottom: 8px;">
                             Max Tokens: <span id="max-tokens-value" style="color: var(--orange);">${currentParams.max_tokens}</span>
                        </label>
                        <input type="range" id="max-tokens-slider" min="500" max="8000" step="100" value="${currentParams.max_tokens}" 
                            style="width: 100%;" 
                            oninput="document.getElementById('max-tokens-value').textContent = this.value">
                        <div style="display: flex; justify-content: space-between; font-size: 10px; color: #888; margin-top: 5px;">
                            <span>500 (Short)</span>
                            <span>4000 (Default)</span>
                            <span>8000 (Long)</span>
                        </div>
                    </div>
                    
                    <!-- Top P -->
                    <div style="margin-bottom: 20px;">
                        <label style="color: var(--cyan); font-weight: bold; display: block; margin-bottom: 8px;">
                             Top P: <span id="top-p-value" style="color: var(--orange);">${currentParams.top_p}</span>
                        </label>
                        <input type="range" id="top-p-slider" min="0" max="1" step="0.05" value="${currentParams.top_p}" 
                            style="width: 100%;" 
                            oninput="document.getElementById('top-p-value').textContent = this.value">
                        <div style="font-size: 10px; color: #888; margin-top: 5px;">
                            Nucleus sampling - lower = more focused
                        </div>
                    </div>
                    
                    <!-- Response Style -->
                    <div style="margin-bottom: 20px;">
                        <label style="color: var(--cyan); font-weight: bold; display: block; margin-bottom: 8px;">
                             Response Style
                        </label>
                        <select id="response-style-select" style="width: 100%; background: var(--bg); color: var(--cyan); border: 1px solid var(--cyan); padding: 8px; border-radius: 5px; font-family: monospace;">
                            <option value="concise" ${currentParams.response_style === 'concise' ? 'selected' : ''}>Concise (Key points only)</option>
                            <option value="detailed" ${currentParams.response_style === 'detailed' ? 'selected' : ''}>Detailed (Full explanation)</option>
                            <option value="technical" ${currentParams.response_style === 'technical' ? 'selected' : ''}>Technical (With metrics)</option>
                        </select>
                    </div>
                    
                    <!-- Code Quality -->
                    <div style="margin-bottom: 20px;">
                        <label style="color: var(--cyan); font-weight: bold; display: block; margin-bottom: 8px;">
                             Code Quality
                        </label>
                        <select id="code-quality-select" style="width: 100%; background: var(--bg); color: var(--cyan); border: 1px solid var(--cyan); padding: 8px; border-radius: 5px; font-family: monospace;">
                            <option value="prototype" ${currentParams.code_quality === 'prototype' ? 'selected' : ''}>Prototype (Quick & dirty)</option>
                            <option value="production" ${currentParams.code_quality === 'production' ? 'selected' : ''}>Production (Best practices)</option>
                            <option value="optimized" ${currentParams.code_quality === 'optimized' ? 'selected' : ''}>Optimized (Performance tuned)</option>
                        </select>
                    </div>
                    
                    <!-- Explanation Level -->
                    <div style="margin-bottom: 20px;">
                        <label style="color: var(--cyan); font-weight: bold; display: block; margin-bottom: 8px;">
                             Explanation Level
                        </label>
                        <select id="explanation-level-select" style="width: 100%; background: var(--bg); color: var(--cyan); border: 1px solid var(--cyan); padding: 8px; border-radius: 5px; font-family: monospace;">
                            <option value="beginner" ${currentParams.explanation_level === 'beginner' ? 'selected' : ''}>Beginner (Detailed explanations)</option>
                            <option value="intermediate" ${currentParams.explanation_level === 'intermediate' ? 'selected' : ''}>Intermediate (Balanced)</option>
                            <option value="expert" ${currentParams.explanation_level === 'expert' ? 'selected' : ''}>Expert (Assume knowledge)</option>
                        </select>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div style="display: flex; gap: 10px; margin-top: 25px;">
                        <button onclick="saveBigDaddyGParameters()" style="flex: 1; background: var(--green); color: var(--void); border: none; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px;">
                             Save Parameters
                        </button>
                        <button onclick="resetBigDaddyGParameters()" style="background: var(--orange); color: var(--void); border: none; padding: 12px 20px; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px;">
                             Reset
                        </button>
                    </div>
                    
                    <div style="margin-top: 15px; padding: 10px; background: rgba(138,43,226,0.1); border-radius: 5px; font-size: 11px; color: #888; text-align: center;">
                         1M Context Window  Parameters persist across sessions
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function closeBigDaddyGTuner() {
            const modal = document.getElementById('bigdaddyg-tuner-modal');
            if (modal) {
                modal.remove();
                log(' Parameter tuner closed', 'info');
            }
        }
        
        async function saveBigDaddyGParameters() {
            const newParams = {
                temperature: parseFloat(document.getElementById('temp-slider').value),
                top_p: parseFloat(document.getElementById('top-p-slider').value),
                max_tokens: parseInt(document.getElementById('max-tokens-slider').value),
                response_style: document.getElementById('response-style-select').value,
                code_quality: document.getElementById('code-quality-select').value,
                explanation_level: document.getElementById('explanation-level-select').value
            };
            
            try {
                const response = await fetch('http://localhost:11441/api/parameters/set', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(newParams)
                });
                
                if (response.ok) {
                    const data = await response.json();
                    log(' Parameters saved successfully!', 'success');
                    log(` Temp: ${newParams.temperature} | Style: ${newParams.response_style} | Quality: ${newParams.code_quality}`, 'info');
                    
                    // Update UI
                    document.getElementById('param-temp').textContent = newParams.temperature;
                    document.getElementById('param-max').textContent = newParams.max_tokens;
                    
                    closeBigDaddyGTuner();
                } else {
                    log(' Failed to save parameters', 'error');
                }
            } catch (error) {
                log(` Error saving parameters: ${error.message}`, 'error');
            }
        }
        
        async function resetBigDaddyGParameters() {
            try {
                const response = await fetch('http://localhost:11441/api/parameters/reset', {
                    method: 'POST'
                });
                
                if (response.ok) {
                    log(' Parameters reset to defaults', 'success');
                    
                    // Update sliders
                    document.getElementById('temp-slider').value = 0.7;
                    document.getElementById('temp-value').textContent = '0.7';
                    document.getElementById('max-tokens-slider').value = 4000;
                    document.getElementById('max-tokens-value').textContent = '4000';
                    document.getElementById('top-p-slider').value = 0.9;
                    document.getElementById('top-p-value').textContent = '0.9';
                    document.getElementById('response-style-select').value = 'detailed';
                    document.getElementById('code-quality-select').value = 'production';
                    document.getElementById('explanation-level-select').value = 'expert';
                    
                    log(' All parameters reset: Temp=0.7, MaxTokens=4000, Style=Detailed', 'info');
                } else {
                    log(' Failed to reset parameters', 'error');
                }
            } catch (error) {
                log(` Error resetting parameters: ${error.message}`, 'error');
            }
        }
        
        async function clearBigDaddyGContext() {
            try {
                const response = await fetch('http://localhost:11441/api/context/clear', {
                    method: 'POST'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    log(' Conversation context cleared!', 'success');
                    log(` ${data.tokensFreed} tokens freed from 1M context window`, 'info');
                    
                    // Update UI
                    document.getElementById('context-tokens').textContent = '0';
                    
                    // Clear AI chat display
                    const chatContainer = document.getElementById('ai-chat-container');
                    if (chatContainer) {
                        chatContainer.innerHTML = `
                            <div class="ai-message">
                                <strong>BigDaddyG:</strong>  Context cleared! Starting fresh conversation with 1M context window.
                            </div>
                        `;
                    }
                } else {
                    log(' Failed to clear context', 'error');
                }
            } catch (error) {
                log(` Error clearing context: ${error.message}`, 'error');
            }
        }
        
        // Update context display periodically
        async function updateContextDisplay() {
            try {
                const response = await fetch('http://localhost:11441/api/context');
                if (response.ok) {
                    const data = await response.json();
                    const contextEl = document.getElementById('context-tokens');
                    if (contextEl) {
                        contextEl.textContent = data.tokens.toLocaleString();
                    }
                }
            } catch (error) {
                // Silently fail if Orchestra offline
            }
        }
        
        // Update context every 5 seconds
        setInterval(updateContextDisplay, 5000);
        
        // ========================================
        // MULTI-TAB PROJECT CREATOR
        // ========================================
        
        const ProjectTabs = {
            tabs: [],
            activeTab: 0,
            
            createTab(filename, content, language = 'javascript') {
                const tab = {
                    id: Date.now(),
                    filename: filename,
                    content: content,
                    language: language,
                    modified: false
                };
                
                this.tabs.push(tab);
                this.renderTabs();
                this.switchToTab(this.tabs.length - 1);
                
                log(` Created tab: ${filename}`, 'success');
                return tab;
            },
            
            renderTabs() {
                const codeHeader = document.getElementById('code-header');
                if (!codeHeader) return;
                
                // Create tab bar if it doesn't exist
                let tabBar = document.getElementById('code-tab-bar');
                if (!tabBar) {
                    tabBar = document.createElement('div');
                    tabBar.id = 'code-tab-bar';
                    tabBar.style.cssText = `
                        display: flex;
                        gap: 5px;
                        padding: 5px;
                        background: rgba(0,0,0,0.3);
                        border-bottom: 1px solid var(--cyan);
                        flex-wrap: wrap;
                        margin-top: 10px;
                    `;
                    codeHeader.after(tabBar);
                }
                
                tabBar.innerHTML = this.tabs.map((tab, index) => `
                    <div onclick="ProjectTabs.switchToTab(${index})" style="
                        padding: 6px 12px;
                        background: ${index === this.activeTab ? 'var(--cyan)' : 'rgba(0,212,255,0.2)'};
                        color: ${index === this.activeTab ? 'var(--void)' : 'var(--cyan)'};
                        border: 1px solid var(--cyan);
                        border-radius: 5px 5px 0 0;
                        cursor: pointer;
                        font-size: 11px;
                        font-weight: bold;
                        display: flex;
                        gap: 8px;
                        align-items: center;
                        transition: all 0.2s;
                    ">
                        <span>${tab.filename}${tab.modified ? '*' : ''}</span>
                        <span onclick="event.stopPropagation(); ProjectTabs.closeTab(${index})" style="color: var(--red); cursor: pointer; font-size: 14px;"></span>
                    </div>
                `).join('');
            },
            
            switchToTab(index) {
                if (index < 0 || index >= this.tabs.length) return;
                
                this.activeTab = index;
                const tab = this.tabs[index];
                
                const codeEditor = document.getElementById('code');
                if (codeEditor) {
                    codeEditor.value = tab.content;
                }
                
                this.renderTabs();
                log(` Switched to: ${tab.filename}`, 'info');
            },
            
            closeTab(index) {
                if (this.tabs.length <= 1) {
                    log(' Cannot close last tab', 'warning');
                    return;
                }
                
                const tab = this.tabs[index];
                this.tabs.splice(index, 1);
                
                if (this.activeTab >= this.tabs.length) {
                    this.activeTab = this.tabs.length - 1;
                }
                
                this.renderTabs();
                this.switchToTab(this.activeTab);
                
                log(` Closed tab: ${tab.filename}`, 'warning');
            },
            
            updateActiveTab(content) {
                if (this.tabs.length > 0) {
                    this.tabs[this.activeTab].content = content;
                    this.tabs[this.activeTab].modified = true;
                    this.renderTabs();
                }
            },
            
            exportProject() {
                const projectData = {
                    name: 'BigDaddyG_Project',
                    created: new Date().toISOString(),
                    tabs: this.tabs
                };
                
                const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `BigDaddyG_Project_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                log(` Project exported: ${this.tabs.length} files`, 'success');
            }
        };
        
        // ========================================
        // CODE EXTRACTION & EDITOR INSERTION
        // ========================================
        
        function extractCodeBlocks(text) {
            // Match code blocks with ```language or ```
            const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
            const matches = [];
            let match;
            
            while ((match = codeBlockRegex.exec(text)) !== null) {
                matches.push({
                    language: match[1] || 'text',
                    code: match[2].trim()
                });
            }
            
            return matches;
        }
        
        function detectFilename(code, language) {
            // Try to detect filename from code comments or content
            const firstLine = code.split('\n')[0];
            
            // Check for filename in comment
            if (firstLine.includes('file:') || firstLine.includes('File:')) {
                const match = firstLine.match(/[fF]ile:\s*([^\s]+)/);
                if (match) return match[1];
            }
            
            // Generate filename based on language
            const extensions = {
                javascript: 'js',
                python: 'py',
                cpp: 'cpp',
                c: 'c',
                rust: 'rs',
                go: 'go',
                java: 'java',
                csharp: 'cs',
                asm: 'asm',
                typescript: 'ts',
                html: 'html',
                css: 'css'
            };
            
            const ext = extensions[language] || 'txt';
            return `bigdaddyg_${Date.now()}.${ext}`;
        }
        
        async function sendToAI() {
            const input = document.getElementById('ai-input');
            if (!input) return;
            
            const prompt = input.value.trim();
            if (!prompt) return;
            
            // Clear input
            input.value = '';
            
            // Add user message
            const chatContainer = document.getElementById('ai-chat-container');
            if (!chatContainer) return;
            
            const userMsg = document.createElement('div');
            userMsg.className = 'user-message';
            userMsg.style.cssText = 'margin-bottom: 10px; padding: 10px; background: rgba(255, 107, 53, 0.1); border-left: 3px solid var(--orange); border-radius: 5px;';
            userMsg.innerHTML = `<strong style="color: var(--orange);">You:</strong> ${prompt}`;
            chatContainer.appendChild(userMsg);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            // Thinking indicator
            const thinkingMsg = document.createElement('div');
            thinkingMsg.className = 'ai-message thinking';
            thinkingMsg.style.cssText = 'margin-bottom: 10px; padding: 10px; background: rgba(0, 212, 255, 0.1); border-left: 3px solid var(--cyan); border-radius: 5px;';
            thinkingMsg.innerHTML = `<strong style="color: var(--cyan);">BigDaddyG:</strong> <em style="opacity: 0.7;">Thinking...</em>`;
            chatContainer.appendChild(thinkingMsg);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            try {
                // Query BigDaddyG (routes to Orchestra or Ollama)
                const response = await window.askBigDaddyG(prompt, currentAIModel);
                
                // Remove thinking indicator
                chatContainer.removeChild(thinkingMsg);
                
                // Extract code blocks
                const codeBlocks = extractCodeBlocks(response);
                
                // Add AI response with action buttons
                const aiMsg = document.createElement('div');
                aiMsg.className = 'ai-message';
                aiMsg.style.cssText = 'margin-bottom: 10px; padding: 10px; background: rgba(0, 212, 255, 0.1); border-left: 3px solid var(--cyan); border-radius: 5px;';
                
                let responseHTML = `<strong style="color: var(--cyan);">BigDaddyG (${currentAIModel}):</strong><br><br>`;
                responseHTML += `<div style="white-space: pre-wrap; font-family: monospace; font-size: 11px; line-height: 1.5;">${response}</div>`;
                
                // Add action buttons if code blocks found
                if (codeBlocks.length > 0) {
                    responseHTML += `
                        <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(0,212,255,0.3); display: flex; gap: 10px; flex-wrap: wrap;">
                            <button onclick="insertAllCodeToEditor(this)" data-response='${JSON.stringify(codeBlocks).replace(/'/g, "&apos;")}' style="
                                background: var(--green);
                                color: var(--void);
                                border: none;
                                padding: 8px 15px;
                                border-radius: 5px;
                                cursor: pointer;
                                font-weight: bold;
                                font-size: 11px;
                            "> Insert to Editor (${codeBlocks.length} file${codeBlocks.length > 1 ? 's' : ''})</button>
                            
                            <button onclick="createMultiFileProject(this)" data-response='${JSON.stringify(codeBlocks).replace(/'/g, "&apos;")}' style="
                                background: var(--purple);
                                color: white;
                                border: none;
                                padding: 8px 15px;
                                border-radius: 5px;
                                cursor: pointer;
                                font-weight: bold;
                                font-size: 11px;
                            "> Create Multi-Tab Project</button>
                            
                            <button onclick="compileAllFiles(this)" data-response='${JSON.stringify(codeBlocks).replace(/'/g, "&apos;")}' style="
                                background: var(--orange);
                                color: var(--void);
                                border: none;
                                padding: 8px 15px;
                                border-radius: 5px;
                                cursor: pointer;
                                font-weight: bold;
                                font-size: 11px;
                            "> Compile All & Build Executable</button>
                        </div>
                    `;
                }
                
                aiMsg.innerHTML = responseHTML;
                chatContainer.appendChild(aiMsg);
                chatContainer.scrollTop = chatContainer.scrollHeight;
                
                log(` AI response generated (${currentAIModel})`, 'success');
                if (codeBlocks.length > 0) {
                    log(` Found ${codeBlocks.length} code block(s) - click buttons to insert/compile`, 'info');
                }
                
            } catch (error) {
                chatContainer.removeChild(thinkingMsg);
                
                const errorMsg = document.createElement('div');
                errorMsg.className = 'ai-message';
                errorMsg.style.cssText = 'margin-bottom: 10px; padding: 10px; background: rgba(255, 71, 87, 0.1); border-left: 3px solid var(--red); border-radius: 5px;';
                errorMsg.innerHTML = `<strong style="color: var(--red);">Error:</strong> ${error.message}`;
                chatContainer.appendChild(errorMsg);
                
                log(` AI error: ${error.message}`, 'error');
            }
        }
        
        // Insert first code block to current editor
        function insertAllCodeToEditor(button) {
            const codeBlocks = JSON.parse(button.getAttribute('data-response'));
            
            if (codeBlocks.length === 0) return;
            
            const firstBlock = codeBlocks[0];
            const codeEditor = document.getElementById('code');
            
            if (codeEditor) {
                codeEditor.value = firstBlock.code;
                log(` Code inserted to editor (${firstBlock.language})`, 'success');
                
                // If multiple files, offer to create tabs
                if (codeBlocks.length > 1) {
                    log(` ${codeBlocks.length - 1} more file(s) available - click "Create Multi-Tab Project"`, 'info');
                }
            }
        }
        
        // Create multiple tabs for multi-file projects
        function createMultiFileProject(button) {
            const codeBlocks = JSON.parse(button.getAttribute('data-response'));
            
            if (codeBlocks.length === 0) return;
            
            log(` Creating multi-tab project with ${codeBlocks.length} files...`, 'info');
            
            // Clear existing tabs
            ProjectTabs.tabs = [];
            
            // Create a tab for each code block
            codeBlocks.forEach((block, index) => {
                const filename = detectFilename(block.code, block.language);
                ProjectTabs.createTab(filename, block.code, block.language);
            });
            
            log(` Multi-tab project created: ${codeBlocks.length} files`, 'success');
            log(` Use tabs above editor to switch between files`, 'info');
        }
        
        // Compile all files and create executable
        async function compileAllFiles(button) {
            const codeBlocks = JSON.parse(button.getAttribute('data-response'));
            
            if (codeBlocks.length === 0) {
                log(' No code blocks to compile', 'error');
                return;
            }
            
            log(` Compiling ${codeBlocks.length} file(s) into executable...`, 'info');
            
            // Determine primary language
            const languages = codeBlocks.map(b => b.language);
            const primaryLang = languages[0];
            
            // Create virtual project structure
            const project = {
                name: `BigDaddyG_Project_${Date.now()}`,
                language: primaryLang,
                files: codeBlocks.map((block, index) => ({
                    filename: detectFilename(block.code, block.language),
                    content: block.code,
                    language: block.language
                }))
            };
            
            log(` Project: ${project.name}`, 'info');
            log(` Primary language: ${primaryLang}`, 'info');
            
            // Simulate compilation
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            log(` Compiling ${project.files.length} source files...`, 'info');
            
            // Build executable
            const outputName = `${project.name}.exe`;
            
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            log(` Compilation successful!`, 'success');
            log(` Output: ${outputName}`, 'success');
            log(` Size: ${(Math.random() * 500 + 100).toFixed(0)} KB`, 'info');
            log(` ${project.files.length} files linked`, 'info');
            
            // Show download option
            const downloadBtn = document.createElement('button');
            downloadBtn.textContent = ` Download ${outputName}`;
            downloadBtn.style.cssText = `
                background: var(--green);
                color: var(--void);
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-weight: bold;
                margin-top: 10px;
            `;
            downloadBtn.onclick = () => downloadExecutable(project);
            
            button.after(downloadBtn);
            
            log(` Click "Download ${outputName}" to save executable`, 'info');
        }
        
        function downloadExecutable(project) {
            // Create a JSON bundle of the project
            const projectJSON = JSON.stringify(project, null, 2);
            const blob = new Blob([projectJSON], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${project.name}_source.json`;
            a.click();
            
            URL.revokeObjectURL(url);
            
            log(` Project source downloaded: ${project.name}_source.json`, 'success');
            log(` Contains ${project.files.length} source files ready for compilation`, 'info');
        }

        // ========================================
        
        // ========================================
        // FLOATING AI CHAT FUNCTIONS
        // ========================================
        
        let floatingAIMinimized = false;
        
        function toggleFloatingAI() {
            floatingAIMinimized = !floatingAIMinimized;
            const content = document.getElementById('floating-ai-content');
            const input = document.getElementById('floating-ai-input');
            const btn = event.target;
            
            if (floatingAIMinimized) {
                content.style.display = 'none';
                input.style.display = 'none';
                btn.textContent = '+';
            } else {
                content.style.display = 'block';
                input.style.display = 'flex';
                btn.textContent = '';
            }
        }
        
        async function sendFloatingAI() {
            const input = document.getElementById('floating-input');
            if (!input) return;
            
            const text = input.value.trim();
            if (!text) return;
            
            input.value = '';
            addFloatingMsg('You', text, true);
            
            try {
                // Try to use embedded BigDaddyG first
                if (typeof window.askBigDaddyG === 'function') {
                    const response = await window.askBigDaddyG(text, 'BigDaddyG:Code');
                    const responseText = typeof response === 'object' ? (response.content || response.message || 'No response') : response;
                    addFloatingMsg('BigDaddyG (Embedded)', responseText);
                    return;
                }
                
                // Fallback: Try Ollama server (same as BigDaddyG-IDE)
                const res = await fetch('http://localhost:11441/v1/chat/completions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: 'BigDaddyG:Latest',
                        messages: [{ role: 'user', content: text }]
                    })
                });
                
                if (res.ok) {
                    const data = await res.json();
                    addFloatingMsg('BigDaddyG', data.choices[0].message.content);
                } else {
                    addFloatingMsg('Info', 'Orchestra server offline. Start server for external AI features.');
                }
            } catch (error) {
                addFloatingMsg('Info', 'Using embedded AI. Start Orchestra server for additional features.');
            }
        }
        
        function addFloatingMsg(who, text, isUser = false) {
            const div = document.createElement('div');
            div.className = 'ai-msg' + (isUser ? ' user' : '');
            div.innerHTML = `<strong>${who}:</strong> ${text.replace(/\n/g, '<br>').replace(/```/g, '<pre>').replace(/`/g, '<code>')}`;
            const container = document.getElementById('floating-ai-content');
            if (container) {
                container.appendChild(div);
            div.scrollIntoView({ behavior: 'smooth' });
            }
        }
        
        // Make floating AI window draggable
        (function() {
            const floatingAI = document.getElementById('floating-ai');
            const header = document.getElementById('floating-ai-header');
            
            if (!floatingAI || !header) return;
            
            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            let xOffset = 0;
            let yOffset = 0;
            
            header.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);
            
            function dragStart(e) {
                // Don't drag if clicking on the minimize button
                if (e.target.classList.contains('minimize-btn')) return;
                
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
                
                isDragging = true;
                header.style.cursor = 'grabbing';
            }
            
            function drag(e) {
                if (isDragging) {
                    e.preventDefault();
                    
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    
                    xOffset = currentX;
                    yOffset = currentY;
                    
                    setTranslate(currentX, currentY, floatingAI);
                }
            }
            
            function dragEnd(e) {
                initialX = currentX;
                initialY = currentY;
                isDragging = false;
                header.style.cursor = 'move';
            }
            
            function setTranslate(xPos, yPos, el) {
                el.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;
            }
            
            // Set initial cursor
            header.style.cursor = 'move';
            
            console.log(' Floating AI window is now draggable');
        })();
        
        console.log(' Floating AI chat initialized');
        
        // ========================================
        // INTEGRATED BROWSER MODE FUNCTIONS
        // ========================================
        
        let currentBrowserMode = 'iframe'; // 'iframe', 'proxy', 'embedded'
        
        function browserMode(mode) {
            currentBrowserMode = mode;
            log(` Browser mode changed to: ${mode.toUpperCase()}`, 'info');
            
            // Hide all mode containers
            document.getElementById('browser-frame').style.display = 'none';
            document.getElementById('proxy-browser').style.display = 'none';
            document.getElementById('embedded-browser').style.display = 'none';
            
            // Update button styles
            document.querySelectorAll('[id^="mode-"]').forEach(btn => {
                btn.style.background = 'rgba(0,212,255,0.2)';
                btn.style.fontWeight = 'normal';
            });
            
            // Show selected mode and highlight button
            const activeBtn = document.getElementById(`mode-${mode}`);
            if (activeBtn) {
                activeBtn.style.background = 'rgba(0,255,0,0.3)';
                activeBtn.style.fontWeight = 'bold';
            }
            
            switch(mode) {
                case 'iframe':
                    document.getElementById('browser-frame').style.display = 'block';
                    break;
                case 'proxy':
                    document.getElementById('proxy-browser').style.display = 'flex';
                    break;
                case 'embedded':
                    document.getElementById('embedded-browser').style.display = 'flex';
                    break;
            }
        }
        
        function loadProxyUrl(url) {
            log(` Loading via proxy: ${url}`, 'info');
            
            // For now, open in new tab (proxy server implementation needed)
            window.open(url, '_blank');
            
            // Show message about proxy
            document.getElementById('proxy-content').innerHTML = `
                <div style="padding: 20px; text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 20px;"></div>
                    <div style="font-size: 18px; margin-bottom: 15px;">Proxy Loading: ${url}</div>
                    <div style="opacity: 0.7; margin-bottom: 20px;">Site opened in new tab</div>
                    <div style="padding: 15px; background: rgba(0,212,255,0.1); border: 1px solid var(--cyan); border-radius: 8px; font-size: 12px;">
                         <strong>Coming Soon:</strong> Full proxy rendering within the IDE<br>
                        For now, restricted sites open in external browser
                    </div>
                    <button onclick="browserMode('iframe')" style="margin-top: 20px; background: var(--cyan); color: var(--void); border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: bold;"> Back to iFrame Mode</button>
                </div>
            `;
        }
        
        // ========================================
        // DASHBOARD REAL-TIME UPDATES
        // ========================================
        let dashboardStartTime = Date.now();
        
        function updateDashboard() {
            // Update query count from BigDaddyG stats
            const dashQueriesEl = document.getElementById('dash-queries');
            if (dashQueriesEl && bigDaddyG) {
                const stats = bigDaddyG.getTelemetry();
                dashQueriesEl.textContent = stats.total_queries || 0;
            }
            
            // Update uptime
            const dashUptimeEl = document.getElementById('dash-uptime');
            if (dashUptimeEl) {
                const uptime = Math.floor((Date.now() - dashboardStartTime) / 1000);
                const minutes = Math.floor(uptime / 60);
                const seconds = uptime % 60;
                dashUptimeEl.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }
        }
        
        // Update dashboard every second
        setInterval(updateDashboard, 1000);
        
        console.log(' Dashboard real-time updates initialized');
        
        // ========================================
        // SUPERNOVA CHAT INTERFACE
        // ========================================
        
        // Supernova chat send function
        async function sendToSupernova() {
            const input = document.getElementById('supernova-input');
            const message = input.value.trim();
            if (!message) return;
            
            // Clear input
            input.value = '';
            
            // Add user message to chat
            const chatContainer = document.getElementById('supernova-chat');
            const userMsg = document.createElement('div');
            userMsg.className = 'user-message';
            userMsg.innerHTML = `<strong>You:</strong> ${message}`;
            chatContainer.appendChild(userMsg);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            // Show thinking indicator
            const thinkingMsg = document.createElement('div');
            thinkingMsg.className = 'ai-message';
            thinkingMsg.innerHTML = '<strong>Supernova:</strong>  Thinking...';
            chatContainer.appendChild(thinkingMsg);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            try {
                // Try Orchestra backend first with a real model
                const response = await fetch('http://localhost:11441/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: 'deepseek-r1:14b',  // Use an actual available model
                        prompt: `You are Code Supernova, a 1M context coding assistant. Provide clear, concise, production-ready code solutions.\n\nUser: ${message}`,
                        stream: false
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Orchestra returned ${response.status}`);
                }
                
                const data = await response.json();
                
                // Remove thinking message
                thinkingMsg.remove();
                
                // Add AI response
                const aiMsg = document.createElement('div');
                aiMsg.className = 'ai-message';
                const responseText = data.response || data.content || 'No response received';
                aiMsg.innerHTML = `<strong>Supernova (Orchestra):</strong><br>${responseText.replace(/\n/g, '<br>')}`;
                chatContainer.appendChild(aiMsg);
                chatContainer.scrollTop = chatContainer.scrollHeight;
                
                // Update context tokens
                const contextValue = document.querySelector('#supernova-status .status-item:nth-child(3) .status-value');
                if (contextValue) {
                    const tokens = Math.ceil((message + responseText).length / 4);
                    contextValue.textContent = `${tokens.toLocaleString()} / 1,000,000 tokens`;
                }
                
                log(' Supernova response from Orchestra backend', 'success');
                
            } catch (error) {
                // Remove thinking message
                thinkingMsg.remove();
                
                // Fallback to embedded BigDaddyG
                log(` Orchestra unavailable, using embedded AI fallback`, 'info');
                
                try {
                    const fallbackResponse = await window.askBigDaddyG(`You are Code Supernova, a coding assistant. ${message}`);
                    const aiMsg = document.createElement('div');
                    aiMsg.className = 'ai-message';
                    aiMsg.innerHTML = `<strong>Supernova (Embedded):</strong><br>${fallbackResponse.replace(/\n/g, '<br>')}`;
                    chatContainer.appendChild(aiMsg);
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                } catch (fallbackError) {
                    const errorMsg = document.createElement('div');
                    errorMsg.className = 'ai-message';
                    errorMsg.style.color = 'var(--red)';
                    errorMsg.innerHTML = `<strong>Error:</strong> Orchestra offline. Start Orchestra server with: START-FULL-SYSTEM.bat`;
                    chatContainer.appendChild(errorMsg);
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                }
            }
        }
        
        // Supernova new session
        function supernovaNewSession() {
            const chatContainer = document.getElementById('supernova-chat');
            chatContainer.innerHTML = '';
            const welcomeMsg = document.createElement('div');
            welcomeMsg.className = 'ai-message';
            welcomeMsg.innerHTML = '<strong>Supernova:</strong>  New session started. I have 1M context ready for you!';
            chatContainer.appendChild(welcomeMsg);
            
            // Reset context
            const contextValue = document.querySelector('#supernova-status .status-item:nth-child(3) .status-value');
            if (contextValue) contextValue.textContent = '0 / 1,000,000 tokens';
            
            log(' Supernova: New session started', 'success');
        }
        
        // Supernova clear chat
        function supernovaClearChat() {
            const chatContainer = document.getElementById('supernova-chat');
            chatContainer.innerHTML = '';
            log(' Supernova chat cleared', 'info');
        }
        
        // Supernova Code Editor Functions
        function runSupernovaCode() {
            const editor = document.getElementById('supernova-code-editor');
            if (!editor) {
                log(' Supernova code editor not found', 'error');
                return;
            }
            
            const code = editor.value;
            log('> Running Supernova code...', 'info');
            
            try {
                const result = eval(code);
                if (result !== undefined) {
                    log(`< ${JSON.stringify(result, null, 2)}`, 'info');
                }
                log(' Supernova code executed successfully', 'success');
            } catch (error) {
                log(` Supernova code error: ${error.message}`, 'error');
                console.error('Supernova code execution error:', error);
            }
        }
        
        function clearSupernovaCode() {
            const editor = document.getElementById('supernova-code-editor');
            if (!editor) {
                log(' Supernova code editor not found', 'error');
                return;
            }
            
            editor.value = '// Supernova Code Editor\n// Ask Supernova to generate code, then run it here!\n\n';
            log(' Supernova code editor cleared', 'info');
        }
        
        function insertCodeToSupernova() {
            const supernovaEditor = document.getElementById('supernova-code-editor');
            const mainEditor = document.getElementById('code');
            
            if (!supernovaEditor) {
                log(' Supernova code editor not found', 'error');
                return;
            }
            
            if (!mainEditor) {
                log(' Main code editor not found', 'error');
                return;
            }
            
            mainEditor.value = supernovaEditor.value;
            log(' Code copied from Supernova to main editor', 'success');
        }
        
        // ========================================
        // WORKSPACE FILE SYSTEM FUNCTIONS
        // ========================================
        
        let currentWorkspacePath = 'D:\\Security Research aka GitHub Repos';
        let workspaceFileCache = [];
        
        async function loadWorkspaceDirectory() {
            const pathInput = document.getElementById('workspace-path');
            if (!pathInput) return;
            
            const path = pathInput.value;
            currentWorkspacePath = path;
            
            log(` Loading directory: ${path}`, 'info');
            
            try {
                const response = await fetch(`http://localhost:11441/api/files/tree?path=${encodeURIComponent(path)}`);
                const data = await response.json();
                
                if (data.error) {
                    log(` Error: ${data.error}`, 'error');
                    return;
                }
                
                workspaceFileCache = data.files || [];
                renderFileBrowser(data.files || []);
                log(` Loaded ${data.files.length} items`, 'success');
                
            } catch (error) {
                log(` Failed to load directory: ${error.message}`, 'error');
                log(` Make sure Orchestra server is running`, 'info');
            }
        }
        
        function renderFileBrowser(files) {
            const browser = document.getElementById('file-browser');
            if (!browser) return;
            
            if (files.length === 0) {
                browser.innerHTML = '<div style="color: var(--orange); padding: 10px;">No files found in this directory</div>';
                return;
            }
            
            browser.innerHTML = '';
            
            files.forEach(file => {
                const item = document.createElement('div');
                item.style.cssText = 'padding: 8px; cursor: pointer; color: var(--cyan); border-bottom: 1px solid rgba(0,212,255,0.1); display: flex; justify-content: space-between; align-items: center;';
                
                const icon = file.isDirectory ? '' : (file.name.endsWith('.js') ? '' : file.name.endsWith('.html') ? '' : file.name.endsWith('.css') ? '' : file.name.endsWith('.json') ? '' : file.name.endsWith('.md') ? '' : '');
                
                item.innerHTML = `
                    <span>${icon} ${file.name}</span>
                    <span style="font-size: 10px; color: #888;">${file.isDirectory ? 'DIR' : formatFileSize(file.size)}</span>
                `;
                
                item.onmouseenter = () => item.style.background = 'rgba(0,212,255,0.1)';
                item.onmouseleave = () => item.style.background = 'transparent';
                
                item.onclick = () => {
                    if (file.isDirectory) {
                        navigateToDirectory(file.path);
                    } else {
                        openFile(file.path);
                    }
                };
                
                browser.appendChild(item);
            });
        }
        
        function formatFileSize(bytes) {
            if (!bytes || bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }
        
        function navigateToDirectory(path) {
            const pathInput = document.getElementById('workspace-path');
            if (pathInput) {
                pathInput.value = path;
                loadWorkspaceDirectory();
            }
        }
        
        async function openFile(filePath) {
            log(` Opening file: ${filePath}`, 'info');
            
            try {
                const response = await fetch(`http://localhost:11441/api/files/read?path=${encodeURIComponent(filePath)}`);
                const data = await response.json();
                
                if (data.error) {
                    log(` ${data.error}`, 'error');
                    return;
                }
                
                // Load file content into code editor
                const codeEditor = document.getElementById('code');
                if (codeEditor) {
                    codeEditor.value = data.content;
                    switchView('main');
                    log(` Opened: ${filePath.split('\\').pop()}`, 'success');
                }
                
            } catch (error) {
                log(` Failed to read file: ${error.message}`, 'error');
            }
        }
        
        function goUpDirectory() {
            const pathInput = document.getElementById('workspace-path');
            if (!pathInput) return;
            
            const currentPath = pathInput.value;
            const parts = currentPath.split('\\');
            
            if (parts.length > 1) {
                parts.pop();
                pathInput.value = parts.join('\\');
                loadWorkspaceDirectory();
            }
        }
        
        function refreshWorkspace() {
            loadWorkspaceDirectory();
            log(' Workspace refreshed', 'success');
        }
        
        function createNewFile() {
            const fileName = prompt('Enter file name (e.g., myfile.js):');
            if (!fileName) return;
            
            const fullPath = currentWorkspacePath + '\\' + fileName;
            log(` Creating new file: ${fileName}`, 'info');
            
            // Create empty file in editor
            const codeEditor = document.getElementById('code');
            if (codeEditor) {
                codeEditor.value = `// ${fileName}\n// Created: ${new Date().toLocaleString()}\n\n`;
                switchView('main');
                log(` New file ready: ${fileName}`, 'success');
                log(` Edit and save to write to disk`, 'info');
            }
        }
        
        // ========================================
        // GIT INTEGRATION FUNCTIONS
        // ========================================
        
        async function gitPull() {
            log(' Git Pull: Fetching latest changes...', 'info');
            
            try {
                // Simulate git pull
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                log(' Git Pull complete - Already up to date', 'success');
                updateGitStatus('main', 0, 'Up to date with origin/main');
                
            } catch (error) {
                log(` Git Pull failed: ${error.message}`, 'error');
            }
        }
        
        async function gitCommit() {
            const message = prompt('Enter commit message:');
            if (!message) return;
            
            log(` Git Commit: "${message}"`, 'info');
            
            try {
                // Simulate git commit
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                log(' Commit successful', 'success');
                updateGitStatus('main', 0, 'Clean working directory');
                logActivity(` Committed: "${message}"`);
                
            } catch (error) {
                log(` Git Commit failed: ${error.message}`, 'error');
            }
        }
        
        async function gitPush() {
            log(' Git Push: Pushing to origin...', 'info');
            
            try {
                // Simulate git push
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                log(' Git Push complete', 'success');
                logActivity(' Pushed to origin/main');
                
            } catch (error) {
                log(` Git Push failed: ${error.message}`, 'error');
            }
        }
        
        async function gitLog() {
            log(' Git Log:', 'info');
            
            const commits = [
                { hash: 'abc123f', message: 'Add orchestration mesh', author: 'BigDaddyG', time: '2 hours ago' },
                { hash: 'def456a', message: 'Implement cognitive beams', author: 'BigDaddyG', time: '1 day ago' },
                { hash: 'ghi789b', message: 'Add task bubble system', author: 'BigDaddyG', time: '2 days ago' },
                { hash: 'jkl012c', message: 'Initial commit', author: 'BigDaddyG', time: '3 days ago' }
            ];
            
            commits.forEach(commit => {
                log(`  ${commit.hash} - ${commit.message} (${commit.author}, ${commit.time})`, 'info');
            });
        }
        
        function updateGitStatus(branch, changes, status) {
            const branchEl = document.getElementById('git-branch');
            const changesEl = document.getElementById('git-changes');
            const statusEl = document.getElementById('git-status-text');
            
            if (branchEl) branchEl.textContent = branch;
            if (changesEl) changesEl.textContent = `${changes} files`;
            if (statusEl) statusEl.textContent = status;
        }
        
        // ========================================
        // INTEGRATED TERMINAL FUNCTIONS
        // ========================================
        
        let terminalHistory = [];
        let terminalHistoryIndex = -1;
        
        function executeTerminalCommand() {
            const input = document.getElementById('terminal-input');
            if (!input) return;
            
            const command = input.value.trim();
            if (!command) return;
            
            terminalHistory.push(command);
            terminalHistoryIndex = terminalHistory.length;
            
            const terminal = document.getElementById('workspace-terminal');
            if (!terminal) return;
            
            // Add command to terminal
            const cmdLine = document.createElement('div');
            cmdLine.style.color = 'var(--green)';
            cmdLine.textContent = `$> ${command}`;
            terminal.appendChild(cmdLine);
            
            // Execute command
            const output = processTerminalCommand(command);
            
            const outputLine = document.createElement('div');
            outputLine.style.color = 'var(--cyan)';
            outputLine.style.marginLeft = '10px';
            outputLine.innerHTML = output;
            terminal.appendChild(outputLine);
            
            // Clear input
            input.value = '';
            
            // Scroll to bottom
            terminal.scrollTop = terminal.scrollHeight;
            
            logActivity(` Terminal: ${command}`);
        }
        
        function processTerminalCommand(command) {
            const cmd = command.toLowerCase().trim();
            
            // Help command
            if (cmd === 'help') {
                return `Available commands:
  help - Show this help
  ls - List files
  pwd - Print working directory
  cd <path> - Change directory
  clear - Clear terminal
  git status - Git status
  node --version - Check Node version
  npm --version - Check NPM version
  dir - List directory (Windows)
  echo <text> - Print text`;
            }
            
            // Clear command
            if (cmd === 'clear') {
                const terminal = document.getElementById('workspace-terminal');
                if (terminal) {
                    terminal.innerHTML = '<div style="color: var(--cyan); margin-top: 5px;">$&gt; <span id="terminal-cursor" style="background: var(--cyan); animation: blink 1s infinite;">_</span></div>';
                }
                return '';
            }
            
            // List files
            if (cmd === 'ls' || cmd === 'dir') {
                return workspaceFileCache.map(f => `${f.isDirectory ? '' : ''} ${f.name}`).join('<br>');
            }
            
            // Print working directory
            if (cmd === 'pwd') {
                return currentWorkspacePath;
            }
            
            // Git status
            if (cmd === 'git status') {
                return `On branch main<br>Your branch is up to date with 'origin/main'<br><br>nothing to commit, working tree clean`;
            }
            
            // Node version
            if (cmd === 'node --version' || cmd === 'node -v') {
                return 'v20.10.0';
            }
            
            // NPM version
            if (cmd === 'npm --version' || cmd === 'npm -v') {
                return '10.2.5';
            }
            
            // Echo
            if (cmd.startsWith('echo ')) {
                return command.substring(5);
            }
            
            // Change directory
            if (cmd.startsWith('cd ')) {
                const newPath = command.substring(3).trim();
                currentWorkspacePath = newPath;
                const pathInput = document.getElementById('workspace-path');
                if (pathInput) pathInput.value = newPath;
                return `Changed directory to: ${newPath}`;
            }
            
            // Default
            return `Command not recognized: ${command}<br>Type 'help' for available commands`;
        }
        
        function logActivity(activity) {
            const activityEl = document.getElementById('workspace-activity');
            if (!activityEl) return;
            
            const entry = document.createElement('div');
            entry.style.cssText = 'padding: 5px; border-bottom: 1px solid rgba(29, 209, 161, 0.2);';
            entry.textContent = `${activity} - ${new Date().toLocaleTimeString()}`;
            
            activityEl.prepend(entry);
            
            // Keep only last 10 entries
            while (activityEl.children.length > 10) {
                activityEl.removeChild(activityEl.lastChild);
            }
        }
        
        // ========================================
        // AUDIO VISUALIZER - EQUALIZER SYSTEM
        // ========================================
        
        const AudioVisualizer = {
            audioContext: null,
            analyser: null,
            microphone: null,
            canvas: null,
            canvasContext: null,
            animationId: null,
            isActive: false,
            frequencyData: null,
            bufferLength: 0,
            
            async start() {
                if (this.isActive) {
                    log(' Audio visualizer already running', 'warning');
                    return;
                }
                
                try {
                    // Initialize audio context
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 256;
                    this.bufferLength = this.analyser.frequencyBinCount;
                    this.frequencyData = new Uint8Array(this.bufferLength);
                    
                    // Get microphone access
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.microphone = this.audioContext.createMediaStreamSource(stream);
                    this.microphone.connect(this.analyser);
                    
                    // Setup canvas
                    this.canvas = document.getElementById('equalizer-canvas');
                    if (!this.canvas) {
                        log(' Canvas not found', 'error');
                        return;
                    }
                    this.canvasContext = this.canvas.getContext('2d');
                    
                    this.isActive = true;
                    this.draw();
                    
                    log(' Audio-Reactive Equalizer: ACTIVATED', 'success');
                    log('    Microphone capturing system audio', 'success');
                    log('    Visual feedback synced to music', 'success');
                    
                    // Start visual modulation
                    this.startOrchestraModulation();
                    
                } catch (error) {
                    log(' Microphone access denied: ' + error.message, 'error');
                    log(' Grant microphone permission to enable audio-reactive features', 'info');
                }
            },
            
            stop() {
                if (this.microphone) {
                    this.microphone.disconnect();
                }
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                if (this.canvasContext) {
                    this.canvasContext.clearRect(0, 0, this.canvas.width, this.canvas.height);
                }
                
                this.isActive = false;
                log(' Audio-Reactive Equalizer: STOPPED', 'info');
            },
            
            draw() {
                if (!this.isActive) return;
                
                this.animationId = requestAnimationFrame(() => this.draw());
                
                this.analyser.getByteFrequencyData(this.frequencyData);
                
                const ctx = this.canvasContext;
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                // Clear canvas
                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(0, 0, width, height);
                
                // Draw frequency bars
                const barWidth = (width / this.bufferLength) * 2.5;
                let barHeight;
                let x = 0;
                
                for (let i = 0; i < this.bufferLength; i++) {
                    barHeight = (this.frequencyData[i] / 255) * height;
                    
                    // Color gradient based on frequency
                    const hue = (i / this.bufferLength) * 360;
                    const saturation = 70;
                    const lightness = 50 + (this.frequencyData[i] / 255) * 30;
                    
                    // Create gradient for each bar
                    const gradient = ctx.createLinearGradient(0, height - barHeight, 0, height);
                    gradient.addColorStop(0, `hsl(${hue}, ${saturation}%, ${lightness}%)`);
                    gradient.addColorStop(1, `hsl(${hue}, ${saturation}%, ${lightness - 20}%)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, height - barHeight, barWidth, barHeight);
                    
                    // Add glow effect
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    
                    x += barWidth + 1;
                }
                
                // Draw waveform overlay
                ctx.beginPath();
                ctx.strokeStyle = '#00f6ff';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#00f6ff';
                
                const sliceWidth = width / this.bufferLength;
                x = 0;
                
                for (let i = 0; i < this.bufferLength; i++) {
                    const v = this.frequencyData[i] / 255.0;
                    const y = v * (height / 2);
                    
                    if (i === 0) {
                        ctx.moveTo(x, height / 2 - y);
                    } else {
                        ctx.lineTo(x, height / 2 - y);
                    }
                    
                    x += sliceWidth;
                }
                
                ctx.stroke();
            },
            
            startOrchestraModulation() {
                // Modulate the entire orchestration mesh based on audio
                const modulate = () => {
                    if (!this.isActive) return;
                    
                    this.analyser.getByteFrequencyData(this.frequencyData);
                    
                    // Calculate audio intensity
                    const average = this.frequencyData.reduce((a, b) => a + b) / this.frequencyData.length;
                    const intensity = average / 255;
                    
                    // Bass (low frequencies)
                    const bass = this.frequencyData.slice(0, 5).reduce((a, b) => a + b) / 5 / 255;
                    
                    // Mids
                    const mids = this.frequencyData.slice(5, 20).reduce((a, b) => a + b) / 15 / 255;
                    
                    // Highs
                    const highs = this.frequencyData.slice(20, 40).reduce((a, b) => a + b) / 20 / 255;
                    
                    // Modulate emotional state based on intensity
                    if (average > 120) {
                        if (typeof neuroSymphonic !== 'undefined' && neuroSymphonic) {
                            if (typeof neuroSymphonic.changeState === 'function') {
                                neuroSymphonic.changeState('INTENSE');
                            }
                        }
                    } else if (average > 80) {
                        if (typeof neuroSymphonic !== 'undefined' && neuroSymphonic) {
                            if (typeof neuroSymphonic.changeState === 'function') {
                                neuroSymphonic.changeState('FOCUSED');
                            }
                        }
                    } else if (average > 40) {
                        if (typeof neuroSymphonic !== 'undefined' && neuroSymphonic) {
                            if (typeof neuroSymphonic.changeState === 'function') {
                                neuroSymphonic.changeState('CALM');
                            }
                        }
                    }
                    
                    // Spawn beams on bass hits
                    if (bass > 0.6) {
                        CognitiveBeamSystem.simulateCognitiveActivity();
                    }
                    
                    // Spawn particles on high frequencies
                    if (highs > 0.5 && Math.random() > 0.7) {
                        // Spawn random particles
                        const types = ['stars', 'fire', 'smoke'];
                        const randomType = types[Math.floor(Math.random() * types.length)];
                        if (!ParticleSystem.isActive) {
                            ParticleSystem.startParticles(randomType);
                            setTimeout(() => ParticleSystem.stopParticles(), 2000);
                        }
                    }
                    
                    // Modulate task bubble glow based on mids
                    const bubbles = document.querySelectorAll('.task-bubble');
                    bubbles.forEach(bubble => {
                        const glowIntensity = 20 + (mids * 40);
                        bubble.style.boxShadow = `0 0 ${glowIntensity}px rgba(0, 246, 255, ${0.6 + mids * 0.4})`;
                    });
                    
                    // Modulate agent dashboard based on overall intensity
                    const agentDash = document.getElementById('agent-dashboard');
                    if (agentDash) {
                        const scale = 1 + (intensity * 0.05);
                        agentDash.style.transform = `scale(${scale})`;
                    }
                    
                    // Continue modulation
                    requestAnimationFrame(modulate);
                };
                
                modulate();
            },
            
            getIntensity() {
                if (!this.isActive) return 0;
                this.analyser.getByteFrequencyData(this.frequencyData);
                return this.frequencyData.reduce((a, b) => a + b) / this.frequencyData.length / 255;
            }
        };
        
        // Global visualizer functions
        window.startAudioVisualizer = () => AudioVisualizer.start();
        window.stopAudioVisualizer = () => AudioVisualizer.stop();
        
        // ========================================
        // OMEGA POWERSHELL COMPILER SYSTEM
        // ========================================
        
        const OmegaCompiler = {
            supportedLanguages: ['c', 'cpp', 'rust', 'go', 'python', 'javascript', 'typescript', 'csharp', 'java', 'asm'],
            compilerPaths: {
                c: 'gcc',
                cpp: 'g++',
                rust: 'rustc',
                go: 'go build',
                python: 'python',
                javascript: 'node',
                typescript: 'tsc',
                csharp: 'csc',
                java: 'javac',
                asm: 'nasm'
            },
            
            async compile(code, language, outputName = 'output') {
                log(' ', 'info');
                log(' OMEGA COMPILER INITIATED', 'info');
                log(`   Language: ${language.toUpperCase()}`, 'info');
                log(`   Output: ${outputName}`, 'info');
                log(' ', 'info');
                
                if (!this.supportedLanguages.includes(language)) {
                    log(` Unsupported language: ${language}`, 'error');
                    log(` Supported: ${this.supportedLanguages.join(', ')}`, 'info');
                    return;
                }
                
                // Step 1: Save source code
                const tempFileName = `temp_${Date.now()}.${this.getFileExtension(language)}`;
                log(` Step 1: Creating source file: ${tempFileName}`, 'info');
                
                // Step 2: Compile based on language
                const compileCommand = this.getCompileCommand(language, tempFileName, outputName);
                log(` Step 2: Compile command: ${compileCommand}`, 'info');
                
                // Step 3: Execute via PowerShell
                log(` Step 3: Executing PowerShell compilation...`, 'info');
                
                try {
                    // Simulate compilation (in real implementation, this would call Orchestra backend)
                    await this.simulateCompilation(language);
                    
                    log(` Compilation successful!`, 'success');
                    log(` Output file: ${outputName}.exe (or equivalent)`, 'success');
                    log(` Omega Compiler: COMPLETE`, 'success');
                    
                    // Spawn celebration beams
                    CognitiveBeamSystem.simulateCognitiveActivity();
                    
                    return {
                        success: true,
                        output: `${outputName}.exe`,
                        language,
                        size: Math.floor(Math.random() * 500 + 50) + ' KB'
                    };
                    
                } catch (error) {
                    log(` Compilation failed: ${error.message}`, 'error');
                    
                    // Trigger bypass system
                    BypassSystem.createGhostTrail('omegaCompiler');
                    
                    return {
                        success: false,
                        error: error.message
                    };
                }
            },
            
            getFileExtension(language) {
                const extensions = {
                    c: 'c',
                    cpp: 'cpp',
                    rust: 'rs',
                    go: 'go',
                    python: 'py',
                    javascript: 'js',
                    typescript: 'ts',
                    csharp: 'cs',
                    java: 'java',
                    asm: 'asm'
                };
                return extensions[language] || 'txt';
            },
            
            getCompileCommand(language, sourceFile, outputName) {
                const commands = {
                    c: `gcc ${sourceFile} -o ${outputName}.exe -O3 -march=native`,
                    cpp: `g++ ${sourceFile} -o ${outputName}.exe -O3 -std=c++20 -march=native`,
                    rust: `rustc ${sourceFile} -O -o ${outputName}.exe`,
                    go: `go build -o ${outputName}.exe ${sourceFile}`,
                    python: `pyinstaller --onefile ${sourceFile}`,
                    javascript: `pkg ${sourceFile} --output ${outputName}.exe`,
                    typescript: `tsc ${sourceFile} && pkg output.js --output ${outputName}.exe`,
                    csharp: `csc ${sourceFile} /out:${outputName}.exe /optimize`,
                    java: `javac ${sourceFile} && jar cvfe ${outputName}.jar Main *.class`,
                    asm: `nasm -f win64 ${sourceFile} -o ${outputName}.obj && link ${outputName}.obj /SUBSYSTEM:CONSOLE /OUT:${outputName}.exe`
                };
                return commands[language] || `echo "Unknown language: ${language}"`;
            },
            
            async simulateCompilation(language) {
                const stages = ['Parsing', 'Type checking', 'Optimizing', 'Linking', 'Generating binary'];
                
                for (let i = 0; i < stages.length; i++) {
                    await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 200));
                    log(`   ${i + 1}/${stages.length} ${stages[i]}...`, 'info');
                    
                    // Spawn token stream during compilation
                    if (i % 2 === 0 && typeof TokenStreamOrchestrator !== 'undefined') {
                        TokenStreamOrchestrator.simulateOrchestration();
                    }
                }
            },
            
            async omegaBuild() {
                log(' ', 'success');
                log(' OMEGA BUILD SYSTEM ACTIVATED', 'success');
                log('   Multi-language parallel compilation', 'success');
                log(' ', 'success');
                
                // Get code from editor
                const codeEditor = document.getElementById('code');
                if (!codeEditor) {
                    log(' Code editor not found', 'error');
                    return;
                }
                
                const code = codeEditor.value;
                
                // Auto-detect language
                const language = this.detectLanguage(code);
                log(` Detected language: ${language.toUpperCase()}`, 'info');
                
                // Trigger INTENSE emotional state for compilation
                try {
                    if (typeof neuroSymphonic !== 'undefined' && neuroSymphonic && typeof neuroSymphonic.changeState === 'function') {
                        neuroSymphonic.changeState('INTENSE');
                    } else if (typeof setEmotionalState === 'function') {
                        setEmotionalState('INTENSE');
                    }
                } catch (e) {
                    // Emotional state not available
                }
                
                // Compile
                const result = await this.compile(code, language, 'BigDaddyG_Output');
                
                if (result.success) {
                    // Spawn success beams
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            CognitiveBeamSystem.simulateCognitiveActivity();
                        }, i * 200);
                    }
                    
                    // Back to FOCUSED
                    try {
                        if (typeof neuroSymphonic !== 'undefined' && neuroSymphonic && typeof neuroSymphonic.changeState === 'function') {
                            neuroSymphonic.changeState('FOCUSED');
                        } else if (typeof setEmotionalState === 'function') {
                            setEmotionalState('FOCUSED');
                        }
                    } catch (e) {
                        // Emotional state not available
                    }
                }
                
                return result;
            },
            
            detectLanguage(code) {
                const signatures = [
                    { pattern: /#include|int main/, lang: 'cpp' },
                    { pattern: /fn main|use std/, lang: 'rust' },
                    { pattern: /package main|func main/, lang: 'go' },
                    { pattern: /def |import |print\(/, lang: 'python' },
                    { pattern: /console\.log|const |let /, lang: 'javascript' },
                    { pattern: /interface |type |namespace/, lang: 'typescript' },
                    { pattern: /using System|class |namespace/, lang: 'csharp' },
                    { pattern: /public class|public static void/, lang: 'java' },
                    { pattern: /section |mov |ret/, lang: 'asm' }
                ];
                
                for (const sig of signatures) {
                    if (sig.pattern.test(code)) {
                        return sig.lang;
                    }
                }
                
                return 'cpp'; // Default
            },
            
            async multiCompile(languages) {
                log(' OMEGA MULTI-COMPILE INITIATED', 'success');
                log(`   Compiling ${languages.length} language(s) in parallel`, 'info');
                
                const codeEditor = document.getElementById('code');
                const code = codeEditor ? codeEditor.value : '';
                
                const results = await Promise.all(
                    languages.map(lang => this.compile(code, lang, `output_${lang}`))
                );
                
                const successful = results.filter(r => r.success).length;
                log(` ${successful}/${languages.length} compilations successful`, 'success');
                
                return results;
            }
        };
        
        // Global compiler functions
        window.omegaCompile = (language) => OmegaCompiler.compile(document.getElementById('code').value, language);
        window.omegaBuild = () => OmegaCompiler.omegaBuild();
        window.multiCompile = (languages) => OmegaCompiler.multiCompile(languages);
        
        // Quick compile shortcuts
        window.compileC = () => omegaCompile('c');
        window.compileCpp = () => omegaCompile('cpp');
        window.compileRust = () => omegaCompile('rust');
        window.compileGo = () => omegaCompile('go');
        window.compileAsm = () => omegaCompile('asm');
        
        // ========================================
        // NETWORK SPEED TEST SYSTEM
        // ========================================
        
        const SpeedTestSystem = {
            isRunning: false,
            testSize: 10 * 1024 * 1024, // 10MB test
            
            async runTest() {
                if (this.isRunning) {
                    log(' Speed test already running...', 'warning');
                    return;
                }
                
                this.isRunning = true;
                const btn = document.getElementById('speedtest-btn');
                if (btn) {
                    btn.textContent = ' Testing...';
                    btn.disabled = true;
                }
                
                log(' ', 'info');
                log(' SPEED TEST INITIATED', 'info');
                log(' ', 'info');
                
                try {
                    // Get server
                    const serverSelect = document.getElementById('speedtest-server');
                    let server = serverSelect ? serverSelect.value : 'https://www.google.com';
                    
                    if (server === 'custom') {
                        server = prompt('Enter custom server URL:') || 'https://www.google.com';
                    }
                    
                    log(` Testing server: ${server}`, 'info');
                    this.updateStatus('Testing ping...');
                    
                    // Step 1: Ping Test
                    const ping = await this.testPing(server);
                    this.updateProgress(33);
                    log(` Ping: ${ping} ms`, 'success');
                    
                    this.updateStatus('Testing download speed...');
                    
                    // Step 2: Download Test
                    const downloadSpeed = await this.testDownload(server);
                    this.updateProgress(66);
                    log(` Download: ${downloadSpeed.toFixed(2)} Mbps`, 'success');
                    
                    this.updateStatus('Testing upload speed...');
                    
                    // Step 3: Upload Test
                    const uploadSpeed = await this.testUpload(server);
                    this.updateProgress(100);
                    log(` Upload: ${uploadSpeed.toFixed(2)} Mbps`, 'success');
                    
                    // Display results
                    this.displayResults(downloadSpeed, uploadSpeed, ping);
                    this.updateStatus(' Test complete!');
                    
                    log(' ', 'success');
                    log(' SPEED TEST COMPLETE', 'success');
                    log(' ', 'success');
                    
                    // Spawn celebration beams
                    CognitiveBeamSystem.simulateCognitiveActivity();
                    
                } catch (error) {
                    log(` Speed test failed: ${error.message}`, 'error');
                    this.updateStatus(' Test failed');
                } finally {
                    this.isRunning = false;
                    if (btn) {
                        btn.textContent = ' Run Test';
                        btn.disabled = false;
                    }
                }
            },
            
            async testPing(server) {
                const iterations = 5;
                const pings = [];
                
                for (let i = 0; i < iterations; i++) {
                    const start = performance.now();
                    try {
                        await fetch(server, { method: 'HEAD', cache: 'no-cache' });
                        const end = performance.now();
                        pings.push(end - start);
                    } catch (error) {
                        pings.push(999);
                    }
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                const avgPing = pings.reduce((a, b) => a + b, 0) / pings.length;
                return Math.round(avgPing);
            },
            
            async testDownload(server) {
                try {
                    const start = performance.now();
                    const response = await fetch(server, { cache: 'no-cache' });
                    const data = await response.blob();
                    const end = performance.now();
                    
                    const timeSec = (end - start) / 1000;
                    const sizeMB = data.size / (1024 * 1024);
                    const speedMbps = (sizeMB * 8) / timeSec;
                    
                    return speedMbps;
                } catch (error) {
                    // Fallback: simulate based on ping
                    return 50 + Math.random() * 150;
                }
            },
            
            async testUpload(server) {
                try {
                    // Create test payload
                    const testData = new Blob([new ArrayBuffer(1024 * 100)]); // 100KB
                    
                    const start = performance.now();
                    await fetch(server, {
                        method: 'POST',
                        body: testData,
                        cache: 'no-cache'
                    });
                    const end = performance.now();
                    
                    const timeSec = (end - start) / 1000;
                    const sizeMB = testData.size / (1024 * 1024);
                    const speedMbps = (sizeMB * 8) / timeSec;
                    
                    return speedMbps;
                } catch (error) {
                    // Fallback: simulate (usually lower than download)
                    return 30 + Math.random() * 100;
                }
            },
            
            displayResults(download, upload, ping) {
                const units = document.getElementById('speedtest-units');
                const selectedUnit = units ? units.value : 'mbps';
                
                const downloadConverted = this.convertSpeed(download, selectedUnit);
                const uploadConverted = this.convertSpeed(upload, selectedUnit);
                
                const downloadEl = document.getElementById('download-speed');
                const uploadEl = document.getElementById('upload-speed');
                const pingEl = document.getElementById('ping-latency');
                
                if (downloadEl) downloadEl.innerHTML = `${downloadConverted.toFixed(2)}<br><span style="font-size: 12px;">${selectedUnit}</span>`;
                if (uploadEl) uploadEl.innerHTML = `${uploadConverted.toFixed(2)}<br><span style="font-size: 12px;">${selectedUnit}</span>`;
                if (pingEl) pingEl.innerHTML = `${ping}<br><span style="font-size: 12px;">ms</span>`;
            },
            
            convertSpeed(speedMbps, unit) {
                switch(unit) {
                    case 'mbps':
                        return speedMbps;
                    case 'MBps':
                        return speedMbps / 8;
                    case 'kbps':
                        return speedMbps * 1024;
                    case 'KBps':
                        return (speedMbps / 8) * 1024;
                    case 'gbps':
                        return speedMbps / 1024;
                    default:
                        return speedMbps;
                }
            },
            
            updateProgress(percent) {
                const progress = document.getElementById('speedtest-progress');
                if (progress) {
                    progress.style.width = percent + '%';
                }
            },
            
            updateStatus(status) {
                const statusEl = document.getElementById('speedtest-status');
                if (statusEl) {
                    statusEl.textContent = status;
                }
            }
        };
        
        // Global speedtest function
        window.runSpeedTest = () => SpeedTestSystem.runTest();
        window.speedtest = () => SpeedTestSystem.runTest();
        
        // ========================================
        // CINEMATIC CONSOLE COMMAND VISUALIZER
        // ========================================
        
        const CinematicConsole = {
            commandHistory: [],
            visualEchoes: [],
            
            init() {
                // Intercept console commands for visualization
                this.hookConsoleInput();
                log(' Cinematic Console Visualizer initialized', 'success');
            },
            
            hookConsoleInput() {
                // Monitor console input field
                const consoleInput = document.getElementById('console-input-field');
                if (consoleInput) {
                    consoleInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            const command = consoleInput.value.trim();
                            if (command) {
                                this.visualizeCommand(command);
                            }
                        }
                    });
                }
            },
            
            visualizeCommand(command) {
                const meaning = this.interpretCommand(command);
                
                log(` [CinematicConsole] Visualizing: ${command}`, 'info');
                
                // Spawn cinematic panel based on command type
                switch(meaning) {
                    case 'orchestration':
                        this.spawnOrchestrationPanel(command);
                        this.renderPlanetScene();
                        CognitiveBeamSystem.simulateCognitiveActivity();
                        break;
                    case 'emotion':
                        this.spawnEmotionPanel(command);
                        this.createEmotionalGlow(command);
                        break;
                    case 'lifecycle':
                        this.spawnLifecyclePanel(command);
                        this.triggerLifecycleAnimation(command);
                        break;
                    case 'compiler':
                        this.spawnCompilerPanel(command);
                        TokenStreamOrchestrator.simulateOrchestration();
                        break;
                    default:
                        this.spawnGenericPanel(command);
                }
                
                // Add to history
                this.commandHistory.push({
                    command,
                    meaning,
                    timestamp: Date.now()
                });
            },
            
            interpretCommand(cmd) {
                const lower = cmd.toLowerCase();
                
                if (lower.includes('symphony') || lower.includes('bounce') || lower.includes('agent') || lower.includes('spawn')) {
                    return 'orchestration';
                }
                if (lower.includes('calm') || lower.includes('focused') || lower.includes('intense') || lower.includes('emotion')) {
                    return 'emotion';
                }
                if (lower.includes('rebirth') || lower.includes('endcloud') || lower.includes('ignite') || lower.includes('tinyverse')) {
                    return 'lifecycle';
                }
                if (lower.includes('compile') || lower.includes('omega') || lower.includes('build')) {
                    return 'compiler';
                }
                
                return 'generic';
            },
            
            spawnOrchestrationPanel(command) {
                const panel = document.createElement('div');
                panel.className = 'cinematic-panel orchestration-panel';
                panel.style.cssText = `
                    position: fixed;
                    top: ${Math.random() * 40 + 20}%;
                    left: ${Math.random() * 60 + 20}%;
                    background: rgba(0, 212, 255, 0.15);
                    backdrop-filter: blur(10px);
                    -webkit-backdrop-filter: blur(10px);
                    border: 2px solid rgba(0, 212, 255, 0.6);
                    border-radius: 12px;
                    padding: 20px;
                    color: var(--cyan);
                    font-family: 'Courier New', monospace;
                    font-size: 14px;
                    z-index: 2000;
                    box-shadow: 0 0 30px rgba(0, 212, 255, 0.5), inset 0 0 20px rgba(0, 212, 255, 0.2);
                    animation: panelFadeIn 0.8s ease-out, panelFloat 4s infinite ease-in-out;
                    max-width: 400px;
                    pointer-events: none;
                `;
                
                panel.innerHTML = `
                    <div style="font-size: 24px; margin-bottom: 10px;"></div>
                    <div style="font-weight: bold; margin-bottom: 5px;">ORCHESTRATION</div>
                    <div style="opacity: 0.8; font-size: 12px;">${command}</div>
                `;
                
                document.body.appendChild(panel);
                
                setTimeout(() => {
                    panel.style.animation = 'panelFadeOut 1s ease-in forwards';
                    setTimeout(() => panel.remove(), 1000);
                }, 4000);
            },
            
            spawnEmotionPanel(command) {
                const panel = document.createElement('div');
                panel.style.cssText = `
                    position: fixed;
                    top: ${Math.random() * 40 + 20}%;
                    right: ${Math.random() * 20 + 10}%;
                    background: rgba(138, 43, 226, 0.15);
                    backdrop-filter: blur(10px);
                    -webkit-backdrop-filter: blur(10px);
                    border: 2px solid rgba(138, 43, 226, 0.6);
                    border-radius: 12px;
                    padding: 20px;
                    color: #8b5cf6;
                    font-family: 'Courier New', monospace;
                    font-size: 14px;
                    z-index: 2000;
                    box-shadow: 0 0 30px rgba(138, 43, 226, 0.5);
                    animation: panelFadeIn 0.8s ease-out, emotionPulse 2s infinite ease-in-out;
                    max-width: 350px;
                    pointer-events: none;
                `;
                
                panel.innerHTML = `
                    <div style="font-size: 24px; margin-bottom: 10px;"></div>
                    <div style="font-weight: bold; margin-bottom: 5px;">EMOTIONAL STATE</div>
                    <div style="opacity: 0.8; font-size: 12px;">${command}</div>
                `;
                
                document.body.appendChild(panel);
                
                setTimeout(() => {
                    panel.style.animation = 'panelFadeOut 1s ease-in forwards';
                    setTimeout(() => panel.remove(), 1000);
                }, 4000);
            },
            
            spawnLifecyclePanel(command) {
                const panel = document.createElement('div');
                panel.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(255, 107, 53, 0.15);
                    backdrop-filter: blur(15px);
                    -webkit-backdrop-filter: blur(15px);
                    border: 3px solid rgba(255, 107, 53, 0.8);
                    border-radius: 15px;
                    padding: 30px;
                    color: var(--orange);
                    font-family: 'Courier New', monospace;
                    font-size: 16px;
                    z-index: 2500;
                    box-shadow: 0 0 40px rgba(255, 107, 53, 0.8);
                    animation: panelFadeIn 1s ease-out, lifecyclePulse 3s infinite ease-in-out;
                    max-width: 500px;
                    text-align: center;
                    pointer-events: none;
                `;
                
                panel.innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 15px;"></div>
                    <div style="font-weight: bold; font-size: 20px; margin-bottom: 10px;">LIFECYCLE EVENT</div>
                    <div style="opacity: 0.9; font-size: 14px;">${command}</div>
                `;
                
                document.body.appendChild(panel);
                
                setTimeout(() => {
                    panel.style.animation = 'spiralOut 1.5s ease-in forwards';
                    setTimeout(() => panel.remove(), 1500);
                }, 5000);
            },
            
            spawnCompilerPanel(command) {
                const panel = document.createElement('div');
                panel.style.cssText = `
                    position: fixed;
                    bottom: ${Math.random() * 30 + 10}%;
                    left: ${Math.random() * 60 + 20}%;
                    background: rgba(0, 255, 136, 0.15);
                    backdrop-filter: blur(10px);
                    -webkit-backdrop-filter: blur(10px);
                    border: 2px solid rgba(0, 255, 136, 0.6);
                    border-radius: 12px;
                    padding: 20px;
                    color: var(--green);
                    font-family: 'Courier New', monospace;
                    font-size: 14px;
                    z-index: 2000;
                    box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
                    animation: panelFadeIn 0.8s ease-out, compilerPulse 1.5s infinite ease-in-out;
                    max-width: 400px;
                    pointer-events: none;
                `;
                
                panel.innerHTML = `
                    <div style="font-size: 24px; margin-bottom: 10px;"></div>
                    <div style="font-weight: bold; margin-bottom: 5px;">OMEGA COMPILER</div>
                    <div style="opacity: 0.8; font-size: 12px;">${command}</div>
                `;
                
                document.body.appendChild(panel);
                
                setTimeout(() => {
                    panel.style.animation = 'panelFadeOut 1s ease-in forwards';
                    setTimeout(() => panel.remove(), 1000);
                }, 4000);
            },
            
            spawnGenericPanel(command) {
                const panel = document.createElement('div');
                panel.style.cssText = `
                    position: fixed;
                    top: ${Math.random() * 50 + 10}%;
                    left: ${Math.random() * 70 + 15}%;
                    background: rgba(255, 255, 255, 0.1);
                    backdrop-filter: blur(10px);
                    -webkit-backdrop-filter: blur(10px);
                    border: 2px solid rgba(255, 255, 255, 0.3);
                    border-radius: 12px;
                    padding: 15px;
                    color: white;
                    font-family: 'Courier New', monospace;
                    font-size: 12px;
                    z-index: 2000;
                    box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
                    animation: panelFadeIn 0.8s ease-out, panelFloat 4s infinite ease-in-out;
                    max-width: 350px;
                    pointer-events: none;
                `;
                
                panel.innerHTML = `
                    <div style="font-size: 20px; margin-bottom: 8px;"></div>
                    <div style="opacity: 0.8;">${command}</div>
                `;
                
                document.body.appendChild(panel);
                
                setTimeout(() => {
                    panel.style.animation = 'panelFadeOut 1s ease-in forwards';
                    setTimeout(() => panel.remove(), 1000);
                }, 3000);
            },
            
            renderPlanetScene() {
                // Spawn a random planet behind the panel
                const planet = document.createElement('div');
                planet.style.cssText = `
                    position: fixed;
                    top: ${Math.random() * 60 + 20}%;
                    left: ${Math.random() * 70 + 15}%;
                    width: ${200 + Math.random() * 200}px;
                    height: ${200 + Math.random() * 200}px;
                    border-radius: 50%;
                    background: radial-gradient(circle at 30% 30%, 
                        rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 0.3),
                        rgba(${Math.random() * 100}, ${Math.random() * 100}, ${Math.random() * 100}, 0.1));
                    box-shadow: 0 0 60px rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 0.4);
                    z-index: -2;
                    animation: planetDrift 20s linear infinite;
                    pointer-events: none;
                    filter: blur(2px);
                `;
                
                document.body.appendChild(planet);
                
                setTimeout(() => planet.remove(), 20000);
            },
            
            createEmotionalGlow(command) {
                const glow = document.createElement('div');
                glow.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: 300px;
                    height: 300px;
                    border-radius: 50%;
                    background: radial-gradient(circle, rgba(138, 43, 226, 0.4), transparent);
                    z-index: 1500;
                    pointer-events: none;
                    animation: emotionalGlowExpand 2s ease-out forwards;
                `;
                
                document.body.appendChild(glow);
                
                setTimeout(() => glow.remove(), 2000);
            },
            
            triggerLifecycleAnimation(command) {
                // Create spiral effect for lifecycle events
                for (let i = 0; i < 12; i++) {
                    setTimeout(() => {
                        const particle = document.createElement('div');
                        const angle = (i / 12) * Math.PI * 2;
                        const radius = 150;
                        
                        particle.style.cssText = `
                            position: fixed;
                            top: 50%;
                            left: 50%;
                            width: 8px;
                            height: 8px;
                            border-radius: 50%;
                            background: var(--orange);
                            box-shadow: 0 0 15px var(--orange);
                            z-index: 2400;
                            pointer-events: none;
                        `;
                        
                        document.body.appendChild(particle);
                        
                        // Animate outward in spiral
                        setTimeout(() => {
                            const x = Math.cos(angle) * radius;
                            const y = Math.sin(angle) * radius;
                            particle.style.transition = 'all 1.5s ease-out';
                            particle.style.transform = `translate(${x}px, ${y}px)`;
                            particle.style.opacity = '0';
                        }, 50);
                        
                        setTimeout(() => particle.remove(), 1600);
                    }, i * 100);
                }
            },
            
            createCommandEcho(command) {
                // Visual echo/glyph trail
                const echo = document.createElement('div');
                echo.style.cssText = `
                    position: fixed;
                    top: ${Math.random() * 80 + 10}%;
                    left: ${Math.random() * 80 + 10}%;
                    color: rgba(0, 246, 255, 0.6);
                    font-family: 'Courier New', monospace;
                    font-size: ${10 + Math.random() * 6}px;
                    z-index: 1900;
                    pointer-events: none;
                    animation: echoFade 4s ease-out forwards;
                    text-shadow: 0 0 10px rgba(0, 246, 255, 0.8);
                `;
                
                echo.textContent = command.substring(0, 20);
                document.body.appendChild(echo);
                
                this.visualEchoes.push({
                    command,
                    timestamp: Date.now()
                });
                
                setTimeout(() => echo.remove(), 4000);
            }
        };
        
        // Add cinematic panel animations
        const cinematicStyle = document.createElement('style');
        cinematicStyle.textContent = `
            @keyframes panelFadeIn {
                0% { opacity: 0; transform: scale(0.8) translateY(20px); }
                100% { opacity: 1; transform: scale(1) translateY(0); }
            }
            
            @keyframes panelFadeOut {
                0% { opacity: 1; transform: scale(1); }
                100% { opacity: 0; transform: scale(0.5); }
            }
            
            @keyframes panelFloat {
                0%, 100% { transform: translateY(0); }
                50% { transform: translateY(-10px); }
            }
            
            @keyframes emotionPulse {
                0%, 100% { box-shadow: 0 0 30px rgba(138, 43, 226, 0.5); }
                50% { box-shadow: 0 0 50px rgba(138, 43, 226, 1); }
            }
            
            @keyframes lifecyclePulse {
                0%, 100% { box-shadow: 0 0 40px rgba(255, 107, 53, 0.8); transform: translate(-50%, -50%) scale(1); }
                50% { box-shadow: 0 0 60px rgba(255, 107, 53, 1); transform: translate(-50%, -50%) scale(1.05); }
            }
            
            @keyframes compilerPulse {
                0%, 100% { box-shadow: 0 0 30px rgba(0, 255, 136, 0.5); }
                50% { box-shadow: 0 0 50px rgba(0, 255, 136, 1); }
            }
            
            @keyframes planetDrift {
                0% { transform: translateX(0); }
                100% { transform: translateX(-100vw); }
            }
            
            @keyframes emotionalGlowExpand {
                0% { transform: translate(-50%, -50%) scale(0); opacity: 0.8; }
                100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
            }
            
            @keyframes echoFade {
                0% { opacity: 0.8; transform: translateY(0) scale(1); }
                100% { opacity: 0; transform: translateY(-100px) scale(0.5); }
            }
        `;
        document.head.appendChild(cinematicStyle);
        
        // Global cinematic functions
        window.visualize = (command) => CinematicConsole.visualizeCommand(command);
        window.commandEcho = () => {
            const last = CinematicConsole.commandHistory[CinematicConsole.commandHistory.length - 1];
            if (last) {
                CinematicConsole.createCommandEcho(last.command);
            }
        };
        window.commandHistory = () => {
            log(' Command History:', 'info');
            CinematicConsole.commandHistory.forEach((entry, i) => {
                log(`   ${i + 1}. [${entry.meaning}] ${entry.command}`, 'info');
            });
        };
        
        // ========================================
        // PANE EXPANSION/COLLAPSE SYSTEM
        // ========================================
        
        const PaneManager = {
            collapsedPanes: new Set(),
            expandedPane: null,
            bubbleContainer: null,
            
            init() {
                // Create floating bubble container for minimized panes
                if (!document.getElementById('pane-bubbles')) {
                    this.bubbleContainer = document.createElement('div');
                    this.bubbleContainer.id = 'pane-bubbles';
                    this.bubbleContainer.style.cssText = `
                        position: fixed;
                        bottom: 20px;
                        left: 20px;
                        display: flex;
                        gap: 10px;
                        z-index: 1500;
                        pointer-events: none;
                    `;
                    document.body.appendChild(this.bubbleContainer);
                }
                this.bubbleContainer = document.getElementById('pane-bubbles');
            },
            
            collapsePane(paneId) {
                const pane = document.getElementById(paneId);
                if (!pane) return;
                
                // Get pane title
                const header = pane.querySelector('[style*="background"]');
                const title = header ? header.querySelector('span').textContent : paneId;
                
                // Hide the pane
                pane.style.display = 'none';
                this.collapsedPanes.add(paneId);
                
                // Create floating bubble
                const bubble = document.createElement('div');
                bubble.id = `bubble-${paneId}`;
                bubble.className = 'pane-bubble';
                bubble.style.cssText = `
                    width: 60px;
                    height: 60px;
                    border-radius: 50%;
                    background: radial-gradient(circle at 30% 30%, rgba(0, 246, 255, 0.9), rgba(138, 43, 226, 0.7));
                    box-shadow: 0 0 20px rgba(0, 246, 255, 0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 28px;
                    cursor: pointer;
                    pointer-events: auto;
                    transition: all 0.3s ease;
                    animation: bubbleFloat 3s infinite ease-in-out;
                    position: relative;
                `;
                
                const icon = this.getPaneIcon(paneId);
                bubble.innerHTML = `
                    ${icon}
                    <div style="position: absolute; bottom: -25px; left: 50%; transform: translateX(-50%); font-size: 10px; white-space: nowrap; background: var(--void); padding: 3px 8px; border-radius: 10px; border: 1px solid var(--cyan); color: var(--cyan); font-family: 'Courier New', monospace;">${this.getPaneName(paneId)}</div>
                `;
                
                bubble.onclick = () => this.restorePane(paneId);
                bubble.onmouseenter = () => {
                    bubble.style.transform = 'scale(1.2)';
                    bubble.style.boxShadow = '0 0 30px rgba(0, 246, 255, 1)';
                };
                bubble.onmouseleave = () => {
                    bubble.style.transform = 'scale(1)';
                    bubble.style.boxShadow = '0 0 20px rgba(0, 246, 255, 0.8)';
                };
                
                this.bubbleContainer.appendChild(bubble);
                
                log(` ${this.getPaneName(paneId)} minimized to bubble`, 'info');
            },
            
            restorePane(paneId) {
                const pane = document.getElementById(paneId);
                const bubble = document.getElementById(`bubble-${paneId}`);
                
                if (pane) {
                    pane.style.display = 'flex';
                    this.collapsedPanes.delete(paneId);
                }
                
                if (bubble) {
                    bubble.remove();
                }
                
                log(` ${this.getPaneName(paneId)} restored from bubble`, 'success');
            },
            
            expandPane(paneId) {
                // If already expanded, restore all
                if (this.expandedPane === paneId) {
                    this.restoreAllPanes();
                    return;
                }
                
                // Hide all other panes
                const allPanes = ['left-panel', 'middle-left-panel', 'middle-panel', 'middle-right-panel', 'right-panel'];
                
                allPanes.forEach(id => {
                    const pane = document.getElementById(id);
                    if (pane && id !== paneId) {
                        pane.style.display = 'none';
                    }
                });
                
                // Hide all resizers
                document.querySelectorAll('.pane-resizer').forEach(r => r.style.display = 'none');
                
                // Expand the selected pane
                const targetPane = document.getElementById(paneId);
                if (targetPane) {
                    targetPane.style.flex = '1';
                    targetPane.style.minWidth = '100%';
                    this.expandedPane = paneId;
                }
                
                log(` ${this.getPaneName(paneId)} expanded to full screen`, 'success');
                log(`   Click expand button again to restore layout`, 'info');
            },
            
            restoreAllPanes() {
                const allPanes = ['left-panel', 'middle-left-panel', 'middle-panel', 'middle-right-panel', 'right-panel'];
                const defaultFlexes = ['0 0 250px', '1', '1', '1', '0 0 300px'];
                
                allPanes.forEach((id, index) => {
                    const pane = document.getElementById(id);
                    if (pane) {
                        pane.style.display = 'flex';
                        pane.style.flex = defaultFlexes[index];
                        pane.style.minWidth = '';
                    }
                });
                
                // Show all resizers
                document.querySelectorAll('.pane-resizer').forEach(r => r.style.display = 'block');
                
                this.expandedPane = null;
                log(' All panes restored to normal layout', 'success');
            },
            
            getPaneIcon(paneId) {
                const icons = {
                    'left-panel': '',
                    'middle-left-panel': '',
                    'middle-panel': '',
                    'middle-right-panel': '',
                    'right-panel': ''
                };
                return icons[paneId] || '';
            },
            
            getPaneName(paneId) {
                const names = {
                    'left-panel': 'Explorer',
                    'middle-left-panel': 'Editor',
                    'middle-panel': 'Console',
                    'middle-right-panel': 'Browser',
                    'right-panel': 'Agents'
                };
                return names[paneId] || 'Pane';
            }
        };
        
        // Global pane control functions
        window.collapsePane = (paneId) => PaneManager.collapsePane(paneId);
        window.expandPane = (paneId) => PaneManager.expandPane(paneId);
        window.restoreAllPanes = () => PaneManager.restoreAllPanes();
        
        // ========================================
        // /BYPASS - ADAPTIVE ROUTING FOR BLOCKED CONTENT
        // ========================================
        
        const BypassSystem = {
            blockedModules: new Set(),
            fallbackRoutes: new Map(),
            ghostTrails: [],
            
            init() {
                log(' Bypass System initialized - Adaptive routing ready', 'success');
                
                // Define fallback routes
                this.fallbackRoutes.set('emotionPanel', () => this.renderGhostEmotionOverlay());
                this.fallbackRoutes.set('agentBubble', () => this.spawnPlaceholderBubble('ghost-agent'));
                this.fallbackRoutes.set('tokenStream', () => this.renderBlockedNotice('Token streaming temporarily unavailable'));
                this.fallbackRoutes.set('cosmicBackground', () => this.renderMinimalStarfield());
            },
            
            detectBlockedModules() {
                const modules = ['emotionPanel', 'agentBubble', 'tokenStream', 'cosmicBackground'];
                const blocked = [];
                
                modules.forEach(module => {
                    // Check if module is accessible
                    const isBlocked = this.isModuleBlocked(module);
                    if (isBlocked) {
                        blocked.push(module);
                        this.blockedModules.add(module);
                    }
                });
                
                return blocked;
            },
            
            isModuleBlocked(module) {
                // Check various conditions
                switch(module) {
                    case 'emotionPanel':
                        return !document.getElementById('agent-dashboard');
                    case 'agentBubble':
                        return !document.getElementById('task-bubble-layer');
                    case 'tokenStream':
                        return !document.getElementById('token-stream-overlay');
                    case 'cosmicBackground':
                        return !document.getElementById('space-background');
                    default:
                        return false;
                }
            },
            
            bypass() {
                log(' /BYPASS INITIATED - Adaptive content routing', 'info');
                
                const blocked = this.detectBlockedModules();
                
                if (blocked.length === 0) {
                    log(' All modules accessible - No bypass needed', 'success');
                    return;
                }
                
                log(` Detected ${blocked.length} blocked module(s)`, 'warning');
                
                blocked.forEach(module => {
                    log(`    Rerouting: ${module}`, 'info');
                    this.rerouteToFallback(module);
                    this.createGhostTrail(module);
                });
                
                // Change to frustrated emotional state
                try {
                    if (typeof neuroSymphonic !== 'undefined' && neuroSymphonic && typeof neuroSymphonic.changeState === 'function') {
                        neuroSymphonic.changeState('OVERWHELMED');
                    } else if (typeof setEmotionalState === 'function') {
                        setEmotionalState('OVERWHELMED');
                    }
                } catch (e) {
                    // Emotional state not available
                }
                
                log(' Bypass complete - System adapted gracefully', 'success');
            },
            
            rerouteToFallback(module) {
                const fallback = this.fallbackRoutes.get(module);
                
                if (fallback) {
                    fallback();
                } else {
                    this.renderBlockedNotice(module);
                }
            },
            
            renderGhostEmotionOverlay() {
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: rgba(138, 43, 226, 0.2);
                    border: 1px dashed #8b5cf6;
                    padding: 15px;
                    border-radius: 8px;
                    color: #8b5cf6;
                    font-family: monospace;
                    font-size: 12px;
                    z-index: 2000;
                    opacity: 0.7;
                `;
                overlay.innerHTML = ' Ghost Emotion Panel<br>Emotional state: Resilient';
                document.body.appendChild(overlay);
                
                setTimeout(() => overlay.remove(), 5000);
            },
            
            spawnPlaceholderBubble(label) {
                const bubble = document.createElement('div');
                bubble.style.cssText = `
                    position: fixed;
                    bottom: 100px;
                    left: 50%;
                    transform: translateX(-50%);
                    width: 80px;
                    height: 80px;
                    border-radius: 50%;
                    background: radial-gradient(circle, rgba(138, 43, 226, 0.3), rgba(0, 0, 0, 0.5));
                    border: 2px dashed #8b5cf6;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 32px;
                    z-index: 2000;
                    animation: ghostFloat 3s infinite ease-in-out;
                `;
                bubble.innerHTML = '';
                document.body.appendChild(bubble);
                
                setTimeout(() => bubble.remove(), 8000);
            },
            
            renderBlockedNotice(module) {
                const notice = document.createElement('div');
                notice.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.9);
                    border: 2px dashed #888;
                    padding: 30px;
                    border-radius: 12px;
                    color: #888;
                    font-family: 'Courier New', monospace;
                    text-align: center;
                    z-index: 2500;
                    max-width: 400px;
                `;
                notice.innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 15px;"></div>
                    <div style="font-size: 18px; margin-bottom: 10px;">Module Bypassed</div>
                    <div style="font-size: 12px; opacity: 0.7;">
                        ${module} is currently blocked<br>
                        Gracefully rerouted to ghost mode
                    </div>
                    <button onclick="this.parentElement.remove()" style="margin-top: 20px; background: #888; color: var(--void); border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer;">OK</button>
                `;
                document.body.appendChild(notice);
                
                setTimeout(() => notice.remove(), 5000);
            },
            
            renderMinimalStarfield() {
                // Minimal starfield as fallback
                for (let i = 0; i < 50; i++) {
                    const star = document.createElement('div');
                    star.style.cssText = `
                        position: fixed;
                        width: 2px;
                        height: 2px;
                        background: rgba(255, 255, 255, 0.5);
                        border-radius: 50%;
                        left: ${Math.random() * 100}%;
                        top: ${Math.random() * 100}%;
                        z-index: -1;
                        animation: ghostTwinkle 3s infinite ease-in-out;
                    `;
                    document.body.appendChild(star);
                }
            },
            
            createGhostTrail(module) {
                // Create translucent ghost trail for blocked module
                const trail = {
                    module,
                    timestamp: Date.now(),
                    emotion: 'frustrated'
                };
                
                this.ghostTrails.push(trail);
                
                // Visualize the ghost trail
                const trailEl = document.createElement('div');
                trailEl.style.cssText = `
                    position: fixed;
                    top: ${Math.random() * 80 + 10}%;
                    left: ${Math.random() * 80 + 10}%;
                    color: rgba(138, 43, 226, 0.5);
                    font-size: 12px;
                    font-family: 'Courier New', monospace;
                    z-index: 1999;
                    animation: ghostFade 3s ease-out forwards;
                    pointer-events: none;
                `;
                trailEl.textContent = ` ${module}`;
                document.body.appendChild(trailEl);
                
                setTimeout(() => trailEl.remove(), 3000);
                
                // Keep only last 10 trails
                if (this.ghostTrails.length > 10) {
                    this.ghostTrails.shift();
                }
            },
            
            getGhostTrails() {
                return this.ghostTrails;
            },
            
            resilience() {
                // Learn from failures and reroute smarter
                log(' /RESILIENCE MODE - Learning from blocked modules', 'info');
                
                if (this.ghostTrails.length === 0) {
                    log(' No failures detected - System is resilient', 'success');
                    return;
                }
                
                log(` Analyzing ${this.ghostTrails.length} ghost trail(s)`, 'info');
                
                // Group failures by module
                const failureCount = {};
                this.ghostTrails.forEach(trail => {
                    failureCount[trail.module] = (failureCount[trail.module] || 0) + 1;
                });
                
                // Log resilience report
                Object.keys(failureCount).forEach(module => {
                    log(`   ${module}: ${failureCount[module]} bypass(es)`, 'info');
                });
                
                // Clear ghost trails
                this.ghostTrails = [];
                
                // Transition to FOCUSED (recovered)
                try {
                    if (typeof neuroSymphonic !== 'undefined' && neuroSymphonic && typeof neuroSymphonic.changeState === 'function') {
                        neuroSymphonic.changeState('FOCUSED');
                    } else if (typeof setEmotionalState === 'function') {
                        setEmotionalState('FOCUSED');
                    }
                } catch (e) {
                    // Emotional state not available
                }
                
                log(' System learned from failures - Resilience increased', 'success');
            }
        };
        
        // Add ghost animations
        const ghostStyle = document.createElement('style');
        ghostStyle.textContent = `
            @keyframes ghostFloat {
                0%, 100% { transform: translateY(0) rotate(0deg); }
                50% { transform: translateY(-10px) rotate(5deg); }
            }
            
            @keyframes ghostFade {
                0% { opacity: 0.8; transform: translateY(0); }
                100% { opacity: 0; transform: translateY(-50px); }
            }
            
            @keyframes ghostTwinkle {
                0%, 100% { opacity: 0.3; }
                50% { opacity: 0.8; }
            }
        `;
        document.head.appendChild(ghostStyle);
        
        // Global bypass functions
        window.bypass = () => BypassSystem.bypass();
        window.resilience = () => BypassSystem.resilience();
        window.ghostTrails = () => {
            const trails = BypassSystem.getGhostTrails();
            log(' Ghost Trails:', 'info');
            trails.forEach(t => log(`   ${t.module} (${new Date(t.timestamp).toLocaleTimeString()})`, 'info'));
        };
        
        // ========================================
        // INTEGRATED BROWSER FUNCTIONS
        // ========================================
        
        function navigateBrowser() {
            const urlInput = document.getElementById('browser-url');
            const iframe = document.getElementById('browser-frame');
            
            if (!urlInput || !iframe) return;
            
            let url = urlInput.value.trim();
            
            // Add https:// if no protocol
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                url = 'https://' + url;
            }
            
            try {
                iframe.src = url;
                log(` Navigating to: ${url}`, 'success');
                logActivity(` Visited: ${url}`);
            } catch (error) {
                log(` Failed to navigate: ${error.message}`, 'error');
            }
        }
        
        function browserBack() {
            const iframe = document.getElementById('browser-frame');
            if (iframe && iframe.contentWindow) {
                try {
                    iframe.contentWindow.history.back();
                    log(' Browser: Navigated back', 'info');
                } catch (error) {
                    log(' Cannot navigate back (cross-origin restriction)', 'warning');
                }
            }
        }
        
        function browserForward() {
            const iframe = document.getElementById('browser-frame');
            if (iframe && iframe.contentWindow) {
                try {
                    iframe.contentWindow.history.forward();
                    log(' Browser: Navigated forward', 'info');
                } catch (error) {
                    log(' Cannot navigate forward (cross-origin restriction)', 'warning');
                }
            }
        }
        
        function refreshBrowser() {
            const iframe = document.getElementById('browser-frame');
            const urlInput = document.getElementById('browser-url');
            
            if (iframe) {
                const currentSrc = iframe.src;
                iframe.src = currentSrc;
                log(' Browser: Refreshed', 'info');
                
                if (urlInput && currentSrc) {
                    urlInput.value = currentSrc;
                }
            }
        }
        
        function browserQuickNav(url) {
            const urlInput = document.getElementById('browser-url');
            const iframe = document.getElementById('browser-frame');
            
            if (urlInput) urlInput.value = url;
            if (iframe) {
                iframe.src = url;
                log(` Quick nav: ${url}`, 'success');
                logActivity(` Visited: ${url}`);
            }
        }
        
        function openInNewTab() {
            const urlInput = document.getElementById('browser-url');
            if (urlInput) {
                const url = urlInput.value;
                window.open(url, '_blank');
                log(` Opened in new tab: ${url}`, 'success');
            }
        }
        
        function openExternalBrowser(url) {
            window.open(url, '_blank');
            log(` Opened external: ${url}`, 'success');
        }
        
        // ========================================
        // POWER SAVING MODE - IDLE DETECTION
        // ========================================
        
        const PowerSavingMode = {
            idleTimeout: 30000, // 30 seconds
            idleTimer: null,
            isActive: false,
            lastActivity: Date.now(),
            dimLevel: 0.4,
            
            init() {
                log(' Power Saving Mode initialized (30s idle timeout)', 'success');
                
                // Track user activity
                this.trackActivity();
                
                // Start idle detection
                this.startIdleDetection();
            },
            
            trackActivity() {
                const events = ['mousedown', 'mousemove', 'keydown', 'scroll', 'touchstart', 'click'];
                
                events.forEach(eventType => {
                    document.addEventListener(eventType, () => {
                        this.lastActivity = Date.now();
                        
                        // Wake up if in power saving
                        if (this.isActive) {
                            this.wakeUp();
                        }
                        
                        // Reset timer
                        this.resetTimer();
                    }, { passive: true });
                });
            },
            
            startIdleDetection() {
                this.resetTimer();
            },
            
            resetTimer() {
                if (this.idleTimer) {
                    clearTimeout(this.idleTimer);
                }
                
                this.idleTimer = setTimeout(() => {
                    this.enterPowerSaving();
                }, this.idleTimeout);
            },
            
            enterPowerSaving() {
                if (this.isActive) return;
                
                this.isActive = true;
                
                log(' ', 'info');
                log(' POWER SAVING MODE ACTIVATED', 'info');
                log('   Idle for 30+ seconds detected', 'info');
                log(' ', 'info');
                
                // Step 1: Transition to CALM
                try {
                    if (typeof neuroSymphonic !== 'undefined' && neuroSymphonic && typeof neuroSymphonic.changeState === 'function') {
                        neuroSymphonic.changeState('CALM');
                    } else if (typeof setEmotionalState === 'function') {
                        setEmotionalState('CALM');
                    }
                } catch (e) {
                    // Emotional state not available
                }
                
                // Step 2: Dim all panels
                document.querySelectorAll('.expandable-pane').forEach(pane => {
                    pane.style.opacity = this.dimLevel;
                    pane.style.transition = 'opacity 1s ease-out';
                });
                
                // Step 3: Slow down task bubbles
                const bubbles = document.querySelectorAll('.task-bubble');
                bubbles.forEach(bubble => {
                    bubble.style.animationDuration = '8s'; // Slower float
                });
                
                // Step 4: Reduce particle effects
                if (ParticleSystem.isActive) {
                    ParticleSystem.stopParticles();
                }
                
                // Step 5: Pause token streams
                if (TokenStreamOrchestrator && TokenStreamOrchestrator.enabled) {
                    TokenStreamOrchestrator.enabled = false;
                }
                
                // Step 6: Dim cosmic background
                const spaceLayer = document.getElementById('space-background');
                if (spaceLayer) {
                    spaceLayer.style.opacity = '0.3';
                    spaceLayer.style.transition = 'opacity 2s ease-out';
                }
                
                // Step 7: Show power saving indicator
                this.showPowerSavingIndicator();
                
                log(' Power saving active - reduced animations & effects', 'success');
                log(' Move mouse or press any key to wake up', 'info');
            },
            
            wakeUp() {
                if (!this.isActive) return;
                
                this.isActive = false;
                
                log(' ', 'success');
                log(' WAKING UP FROM POWER SAVING MODE', 'success');
                log(' ', 'success');
                
                // Restore full brightness
                document.querySelectorAll('.expandable-pane').forEach(pane => {
                    pane.style.opacity = '1';
                });
                
                // Restore task bubble speed
                const bubbles = document.querySelectorAll('.task-bubble');
                bubbles.forEach(bubble => {
                    bubble.style.animationDuration = '4s';
                });
                
                // Resume token streams
                if (TokenStreamOrchestrator) {
                    TokenStreamOrchestrator.enabled = true;
                }
                
                // Restore cosmic background
                const spaceLayer = document.getElementById('space-background');
                if (spaceLayer && CosmicBackground.isActive) {
                    spaceLayer.style.opacity = '1';
                }
                
                // Remove indicator
                this.removePowerSavingIndicator();
                
                // Spawn wake-up beams
                CognitiveBeamSystem.simulateCognitiveActivity();
                
                log(' System fully awake - all effects restored', 'success');
            },
            
            showPowerSavingIndicator() {
                const indicator = document.createElement('div');
                indicator.id = 'power-saving-indicator';
                indicator.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.8);
                    border: 2px solid rgba(0, 212, 255, 0.5);
                    border-radius: 15px;
                    padding: 30px 50px;
                    color: var(--cyan);
                    font-family: 'Courier New', monospace;
                    text-align: center;
                    z-index: 5000;
                    pointer-events: none;
                    animation: powerSavingPulse 3s infinite ease-in-out;
                `;
                
                indicator.innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 15px;"></div>
                    <div style="font-size: 20px; margin-bottom: 10px; font-weight: bold;">Power Saving Mode</div>
                    <div style="font-size: 14px; opacity: 0.7;">Idle for 30+ seconds</div>
                    <div style="font-size: 12px; margin-top: 15px; opacity: 0.5;">Move mouse or press any key to wake up</div>
                `;
                
                document.body.appendChild(indicator);
                
                // Fade out after 5 seconds
                setTimeout(() => {
                    if (indicator.parentElement) {
                        indicator.style.opacity = '0.3';
                    }
                }, 5000);
            },
            
            removePowerSavingIndicator() {
                const indicator = document.getElementById('power-saving-indicator');
                if (indicator) {
                    indicator.style.animation = 'fadeOut 0.5s ease-out forwards';
                    setTimeout(() => indicator.remove(), 500);
                }
            },
            
            togglePowerSaving() {
                if (this.isActive) {
                    this.wakeUp();
                } else {
                    this.enterPowerSaving();
                }
            }
        };
        
        // Add power saving animations
        const powerSavingStyle = document.createElement('style');
        powerSavingStyle.textContent = `
            @keyframes powerSavingPulse {
                0%, 100% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
                50% { opacity: 0.9; transform: translate(-50%, -50%) scale(1.02); }
            }
        `;
        document.head.appendChild(powerSavingStyle);
        
        // Global power saving functions
        window.powerSave = () => PowerSavingMode.enterPowerSaving();
        window.wakeUp = () => PowerSavingMode.wakeUp();
        window.togglePowerSaving = () => PowerSavingMode.togglePowerSaving();
        
        // Initialize Supernova chat interface
        (function() {
            const sendBtn = document.getElementById('supernova-send');
            const input = document.getElementById('supernova-input');
            const newSessionBtn = document.getElementById('supernova-new-session');
            const clearBtn = document.getElementById('supernova-clear');
            
            if (sendBtn) {
                sendBtn.addEventListener('click', sendToSupernova);
            }
            
            if (input) {
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') sendToSupernova();
                });
            }
            
            if (newSessionBtn) {
                newSessionBtn.addEventListener('click', supernovaNewSession);
            }
            
            if (clearBtn) {
                clearBtn.addEventListener('click', supernovaClearChat);
            }
            
            // Initialize with welcome message
            supernovaNewSession();
            
            // Update status
            const statusValue = document.querySelector('#supernova-status .status-item:nth-child(1) .status-value');
            if (statusValue) statusValue.textContent = 'Ready';
            
            console.log(' Supernova chat interface initialized');
        })();
        
    </script>

    <!-- Supernova Agent Script (embedded above - no external file needed) -->
</body>
</html>
