<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Developer Workbench - Dual Mode (Gemini + Ollama)</title>
    
    <!-- Dependencies -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use a stable version of Monaco -->
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.48.0/min/vs/loader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/12.0.1/marked.min.js"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        slate: { 
                            900:'#0f172a', 800:'#1e293b', 700:'#334155',
                            600: '#475569', 500: '#64748b'
                        },
                        indigo: { 500:'#6366f1', 600:'#4f46e5', 400: '#818cf8' },
                        emerald: { 500:'#10b981', 600:'#059669', 400: '#34d399' },
                        rose: { 600:'#e11d48', 500: '#f43f5e' },
                        amber: { 500: '#f59e0b', 400: '#fbbf24' }
                    },
                    fontFamily: {
                        sans:['Inter','system-ui','-apple-system','Segoe UI', 'Arial', 'sans-serif'],
                        mono:['Fira Code','ui-monospace','SFMono-Regular','Menlo','Monaco','monospace']
                    },
                    animation: {
                        'pulse-soft': 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500;600&display=swap" rel="stylesheet"/>
    
    <style>
        body { background-color: #0f172a; color: #e2e8f0; }
        #app { display: flex; height: 100vh; overflow: hidden; }
        .editor-container { flex: 1; min-width: 0; }
        #sidebar { width: 420px; min-width: 420px; background-color: #1e293b; border-left: 1px solid #334155; display: flex; flex-direction: column; }
        #editor { height: 100%; border-radius: 0 0 0.5rem 0.5rem; }
        #chat { flex-grow: 1; overflow-y: auto; padding: 1rem; scroll-behavior: smooth; }
        .chat-message { max-width: 90%; margin-bottom: 1rem; }
        .user-message { background-color: #4f46e5; color: white; border-radius: 0.75rem 0.75rem 0 0.75rem; padding: 0.6rem 1rem; align-self: flex-end; }
        .agent-message { background-color: #334155; border: 1px solid #475569; color: #e2e8f0; border-radius: 0.75rem 0.75rem 0.75rem 0; padding: 0.6rem 1rem; align-self: flex-start; }
        .dot { border-radius: 50%; display: inline-block; margin: 0 1px; animation: bounce 1.4s infinite ease-in-out both; }
        .dot-sm { width: 6px; height: 6px; background-color: #6366f1; }
        @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }
        .dot:nth-child(1) { animation-delay: -0.32s; }
        .dot:nth-child(2) { animation-delay: -0.16s; }
        .dot:nth-child(3) { animation-delay: 0s; }
        .agent-persona-badge { padding: 2px 8px; border-radius: 4px; font-size: 0.7rem; font-weight: 600; margin-bottom: 4px; display: inline-block; }
        .analyst-badge { background-color: #f59e0b; color: #1e293b; }
        .refactor-badge { background-color: #10b981; color: #1e293b; }
        .implementer-badge { background-color: #6366f1; color: white; }
        .orchestrator-badge { background-color: #e11d48; color: white; }
        
        /* Monaco tab styling */
        .tab-bar { background-color: #1e293b; padding: 0 1rem; border-bottom: 1px solid #334155; }
        .tab { padding: 0.5rem 1rem; cursor: pointer; border-right: 1px solid #334155; font-size: 0.875rem; color: #94a3b8; transition: all 0.2s; }
        .tab.active { background-color: #0f172a; color: #e2e8f0; border-bottom: 2px solid #6366f1; }
        
        /* Hide scrollbars for a cleaner look */
        #chat::-webkit-scrollbar, #folder-tree::-webkit-scrollbar { display: none; }
        #chat, #folder-tree { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="font-sans">

    <div id="app">
        <!-- Editor Section -->
        <div class="editor-container flex flex-col p-4">
            <header class="flex justify-between items-center py-2 px-4 bg-slate-800 rounded-t-lg border-b border-slate-700">
                <div class="flex items-center space-x-4">
                    <h1 class="text-xl font-bold text-indigo-400">Agentic Developer Workbench</h1>
                    <span id="badge-mode" class="px-2 py-1 rounded-full text-xs bg-indigo-500 text-white">Gemini Cloud</span>
                    <span id="status-indicator" class="text-sm font-medium text-slate-400">Ready.</span>
                </div>
                <div class="flex items-center space-x-3 text-sm">
                    <span id="cursor-pos" class="text-slate-500">Ln 1, Col 1</span>
                </div>
            </header>

            <!-- File Tabs (Simulated/Placeholder) -->
            <div id="tab-bar" class="flex flex-row overflow-x-auto tab-bar">
                <div class="tab active" data-path="Untitled-1.js">Untitled-1.js</div>
            </div>

            <!-- Monaco Editor Container -->
            <div id="editor" class="flex-grow bg-slate-900 border border-slate-700 rounded-b-lg shadow-2xl"></div>

            <!-- File System Controls (Placeholders for Native File System API) -->
            <footer class="mt-2 flex space-x-3 text-sm">
                <!-- These buttons require browser permissions (Native File System API) and are placeholders -->
                <button onclick="alert('File System Access API is required for this. Using local storage for now.')" class="bg-slate-700 hover:bg-slate-600 text-white py-1 px-3 rounded-md transition duration-150">Load Folder</button>
                <button onclick="alert('File System Access API is required for this. Using local storage for now.')" class="bg-slate-700 hover:bg-slate-600 text-white py-1 px-3 rounded-md transition duration-150">Save File</button>
            </footer>
        </div>

        <!-- Sidebar Section (Chat & Controls) -->
        <div id="sidebar">
            <div class="p-4 border-b border-slate-700">
                <h2 class="text-lg font-semibold mb-2 text-emerald-400">Agentic Chat & Controls</h2>
                <div class="flex items-center space-x-3 mb-3">
                    <label for="mode" class="text-sm text-slate-400">AI Mode:</label>
                    <select id="mode" onchange="aiAdapter.updateUIMode()" class="bg-slate-700 text-white text-sm p-1 rounded">
                        <option value="gemini">Gemini (Cloud)</option>
                        <option value="ollama">Ollama (Local)</option>
                    </select>
                </div>
                <div id="gemini-row" class="text-sm text-slate-400">
                    Model: <input type="text" value="gemini-2.5-flash-preview-09-2025" disabled class="bg-slate-700 p-1 rounded w-60 text-xs">
                </div>
                <div id="ollama-row" class="text-sm text-slate-400 hidden">
                    Ollama: <span id="ollama-health" class="font-medium text-amber-400">Checking...</span> |
                    Model: <select id="ollama-model" class="bg-slate-700 text-white text-sm p-1 rounded">
                        <option value="llama3">llama3</option>
                        <option value="codellama">codellama</option>
                        <option value="phi3">phi3</option>
                    </select>
                </div>
            </div>

            <!-- Chat Display -->
            <div id="chat" class="flex flex-col flex-grow">
                <div class="chat-message agent-message self-start">
                    <span class="orchestrator-badge">Orchestrator</span>
                    Hello! I'm your multi-agent coding workbench. Describe what you want to achieve with the code on the left, and I will deploy my Analyst, Refactor, and Implementer agents to assist you.
                </div>
            </div>

            <!-- Chat Input -->
            <div class="p-4 border-t border-slate-700">
                <div class="flex space-x-2">
                    <input type="text" id="user-input" placeholder="Ask the agent to implement a feature, refactor code, or fix a bug..." 
                           class="flex-grow p-3 rounded-lg bg-slate-700 text-white placeholder-slate-500 focus:ring-indigo-500 focus:border-indigo-500 border-none" 
                           onkeypress="if(event.key === 'Enter') handleUserInput()">
                    <button id="btn-send" onclick="handleUserInput()" class="bg-indigo-600 hover:bg-indigo-500 text-white p-3 rounded-lg transition duration-150 active:scale-95">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                    </button>
                    <button id="btn-stop" onclick="stopGeneration()" class="bg-rose-600 hover:bg-rose-500 text-white p-3 rounded-lg transition duration-150 active:scale-95 hidden">
                         <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="9" x2="15" y2="15"></line><line x1="15" y1="9" x2="9" y2="15"></line></svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

<script>
    // --- Global State & Constants ---
    let editor = null;
    let chatHistory = [];
    let abortController = null;
    let updateTimer; // for debouncing suggestions
    const OLLAMA_BASE = 'http://localhost:11434'; // Standard Ollama endpoint
    
    // System prompt for the Orchestrator
    const APP_SYSTEM_PROMPT = `You are the primary orchestration agent for a coding IDE. Your goal is to coordinate a team of specialized sub-agents (Analyst, Refactor, Implementer) to fulfill the user's request. You must ensure the response is helpful, actionable, and uses the code context provided by the editor. The current code context is always provided in the user prompt.`;

    // --- Utility Functions ---

    const el = selector => document.querySelector(selector);

    /**
     * Updates the global status indicator in the editor header.
     * @param {string} message - The status message.
     * @param {'ok'|'warn'|'error'|'thinking'} type - The status type.
     */
    function setStatus(message, type) {
        const statusEl = el('#status-indicator');
        if (type === 'thinking') {
            statusEl.innerHTML = `<span class="dot dot-sm"></span><span class="dot dot-sm"></span><span class="dot dot-sm"></span> ${message}`;
        } else {
            statusEl.textContent = message;
        }
        
        statusEl.className = 'text-sm font-medium';
        switch (type) {
            case 'ok': statusEl.classList.add('text-emerald-400'); break;
            case 'warn': statusEl.classList.add('text-amber-400'); break;
            case 'error': statusEl.classList.add('text-rose-400'); break;
            case 'thinking':
                statusEl.classList.add('text-indigo-400');
                break;
            default: statusEl.classList.add('text-slate-400');
        }
    }

    /**
     * Renders a message to the chat display.
     * @param {string} content - The message content (Markdown or HTML).
     * @param {'user'|'agent'|'orchestrator'|'analyst'|'refactor'|'implementer'} role - The sender role.
     * @returns {HTMLElement} The newly created message element.
     */
    function renderChat(content, role = 'agent') {
        const chat = el('#chat');
        const newMsg = document.createElement('div');
        newMsg.classList.add('chat-message', 'w-full', 'flex', 'flex-col');

        let roleClass = 'agent-message self-start';
        let roleBadge = role;
        let badgeClass = '';

        switch (role) {
            case 'user':
                roleClass = 'user-message self-end';
                break;
            case 'analyst':
                roleClass = 'agent-message self-start';
                badgeClass = 'analyst-badge';
                roleBadge = 'Analyst Agent';
                break;
            case 'refactor':
                roleClass = 'agent-message self-start';
                badgeClass = 'refactor-badge';
                roleBadge = 'Refactor Agent';
                break;
            case 'implementer':
                roleClass = 'agent-message self-start';
                badgeClass = 'implementer-badge';
                roleBadge = 'Implementer Agent';
                break;
            case 'orchestrator':
            case 'agent':
            default:
                roleClass = 'agent-message self-start';
                badgeClass = 'orchestrator-badge';
                roleBadge = 'Orchestrator';
                break;
        }

        const badgeHtml = role !== 'user' && role !== 'agent' ? `<span class="${badgeClass} agent-persona-badge">${roleBadge}</span>` : '';
        
        newMsg.innerHTML = `<div class="${roleClass}">${badgeHtml}${marked.parse(content)}</div>`;
        chat.appendChild(newMsg);
        chat.scrollTop = chat.scrollHeight;
        return newMsg.querySelector(`.${roleClass}`);
    }

    /**
     * Appends a chunk of text to the last message in the chat.
     * @param {HTMLElement} targetEl - The element to append to.
     * @param {string} chunk - The text chunk.
     */
    function appendChunk(targetEl, chunk) {
        targetEl.textContent += chunk;
        const parsed = marked.parse(targetEl.textContent);
        targetEl.innerHTML = parsed;
        el('#chat').scrollTop = el('#chat').scrollHeight;
    }

    /**
     * Adds the final message content to the chat history.
     * @param {string} role - The role of the speaker.
     * @param {string} content - The final content.
     */
    function saveToHistory(role, content) {
        chatHistory.push({ role, content });
        if (chatHistory.length > 20) chatHistory.shift();
    }


    // --- AI Adapter Class (Gemini/Ollama) ---

    class AIAdapter {
        constructor() {
            this.mode = 'gemini';
            this.updateUIMode();
        }

        async checkOllamaHealth() {
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 1000);
                const res = await fetch(`${OLLAMA_BASE}/api/tags`, { method: 'GET', signal: controller.signal });
                clearTimeout(timeout);
                const healthy = res.ok;
                const healthEl = el('#ollama-health');
                
                healthEl.innerHTML = healthy 
                    ? '<span class="dot bg-emerald-400"></span> Online'
                    : '<span class="dot bg-rose-400"></span> Offline (Simulated)';
                
                return healthy;
            } catch (err) {
                el('#ollama-health').innerHTML = '<span class="dot bg-rose-400"></span> Offline (Simulated)';
                return false;
            }
        }

        updateUIMode() {
            this.mode = el('#mode').value;
            const isOllama = this.mode === 'ollama';

            el('#gemini-row').classList.toggle('hidden', isOllama);
            el('#ollama-row').classList.toggle('hidden', !isOllama);

            const badge = el('#badge-mode');
            badge.textContent = isOllama ? 'Ollama Local' : 'Gemini Cloud';
            badge.className = `px-2 py-1 rounded-full text-xs ${isOllama ? 'bg-emerald-600' : 'bg-indigo-500'} text-white`;
        }
        
        async generate(prompt, systemInstruction, role, onChunk, signal) {
            el('#btn-stop').classList.remove('hidden');
            el('#btn-send').disabled = true;

            const agentMessageEl = renderChat('', role);
            
            try {
                if (this.mode === 'ollama') {
                    await this.simulateStream(prompt, onChunk, signal, agentMessageEl, 'Ollama');
                } else {
                    await this.simulateStream(prompt, onChunk, signal, agentMessageEl, 'Gemini');
                }
            } catch (err) {
                if (err.name === 'AbortError') {
                    onChunk('\n\n**Generation stopped by user.**', agentMessageEl);
                    setStatus('Aborted by user', 'warn');
                } else {
                    onChunk(`\n\n**Agent Error:** ${err.message}`, agentMessageEl);
                    setStatus('Generation failed', 'error');
                }
            } finally {
                el('#btn-stop').classList.add('hidden');
                el('#btn-send').disabled = false;
                return agentMessageEl.textContent;
            }
        }

        async simulateStream(prompt, onChunk, signal, agentMessageEl, modelName) {
            setStatus(`Agent ${modelName} is thinking...`, 'thinking');

            const fakeResponse = `The ${modelName} model is simulating a response. The prompt was: "${prompt.substring(0, 100)}..."\n\nThis stream simulates a high-quality, step-by-step agent output.`;

            let i = 0;
            const delay = 30;

            return new Promise((resolve, reject) => {
                function writeChunk() {
                    if (signal.aborted) return reject(new DOMException('Aborted', 'AbortError'));
                    
                    if (i < fakeResponse.length) {
                        const chunk = fakeResponse.charAt(i);
                        onChunk(chunk, agentMessageEl);
                        i++;
                        setTimeout(writeChunk, delay);
                    } else {
                        setStatus('Ready', 'ok');
                        resolve(agentMessageEl.textContent);
                    }
                }
                writeChunk();
            });
        }
    }

    const aiAdapter = new AIAdapter();


    // --- Agentic Workflow (The Orchestrator) ---

    async function agenticWorkflow(userPrompt, codeContext) {
        const fullPrompt = `USER REQUEST: ${userPrompt}\n\nCURRENT CODE CONTEXT:\n\`\`\`${editor.getModel().getLanguageId()}\n${codeContext}\n\`\`\``;
        saveToHistory('user', userPrompt);

        setStatus('Orchestrating agents...', 'thinking');
        let combinedPlan = '';
        let finalCode = '';

        const analystPrompt = `Analyze the following code context and user request. Create a **concise, bulleted plan** (max 3 points) detailing necessary steps (e.g., refactoring, new functions, error handling). Do not write any code yet.`;
        combinedPlan = await runAgent('analyst', fullPrompt, analystPrompt, 'analyst');
        saveToHistory('analyst', combinedPlan);

        const refactorPrompt = `Based on the Analyst's plan (below) and the original code context, identify and explain any necessary refactoring or code quality improvements for the existing code. Provide only markdown text (no code blocks).

        ANALYSIS PLAN: ${combinedPlan}`;
        const refactoringNotes = await runAgent('refactor', refactorPrompt, 'Explain necessary refactoring.', 'refactor');
        saveToHistory('refactor', refactoringNotes);
        
        const implementerPrompt = `Based on the Analyst's plan and the Refactor Agent's notes, implement the final, complete, and correct code solution. Your output MUST be a single, complete code block wrapped in \`\`\`language...\`\`\` to be directly usable in the editor.

        ANALYSIS PLAN: ${combinedPlan}
        REFACTOR NOTES: ${refactoringNotes}`;
        finalCode = await runAgent('implementer', implementerPrompt, 'Generate the final code block.', 'implementer');
        saveToHistory('implementer', finalCode);

        const codeBlockMatch = finalCode.match(/```[a-z]*\n([\s\S]*?)```/i);
        if (codeBlockMatch && codeBlockMatch[1]) {
            const extractedCode = codeBlockMatch[1].trim();
            const currentLanguage = editor.getModel().getLanguageId();
            
            renderChat(`Code successfully extracted and applied to the editor. Check the left panel for the updated file.`, 'orchestrator');
            
            const languageMatch = codeBlockMatch[0].match(/```([a-z]+)/i);
            const newLanguage = languageMatch && languageMatch[1] ? languageMatch[1] : currentLanguage;
            
            editor.setValue(extractedCode);
            if (newLanguage !== currentLanguage) {
                monaco.editor.setModelLanguage(editor.getModel(), newLanguage);
            }
            setStatus('Code implemented successfully', 'ok');
        } else {
            renderChat(`Implementation agent failed to produce a valid code block. Please review the output.`, 'orchestrator');
            setStatus('Implementation incomplete', 'warn');
        }
    }

    async function runAgent(agentRole, prompt, systemInstruction, role) {
        try {
            const finalContent = await aiAdapter.generate(
                prompt, 
                systemInstruction, 
                role, 
                (chunk, targetEl) => appendChunk(targetEl, chunk), 
                abortController.signal
            );
            return finalContent;
        } catch (error) {
            return `[AGENT ERROR - ${agentRole.toUpperCase()}] Request failed or was cancelled.`;
        }
    }

    // --- UI Handlers ---

    function stopGeneration() {
        if (abortController) {
            abortController.abort();
            setStatus('Stopping generation...', 'warn');
        }
    }

    function handleUserInput() {
        const inputEl = el('#user-input');
        const userPrompt = inputEl.value.trim();

        if (!userPrompt) return;

        inputEl.value = '';
        abortController = new AbortController();

        const codeContext = editor.getValue();
        
        renderChat(userPrompt, 'user');
        
        agenticWorkflow(userPrompt, codeContext).catch(error => {
            if (error.name !== 'AbortError') {
                renderChat(`An unexpected error occurred in the workflow: ${error.message}`, 'orchestrator');
                setStatus('Workflow halted unexpectedly', 'error');
            }
        });
    }

    // --- Editor Initialization ---

    function initMonacoEditor() {
        setStatus('Loading Monaco Editor...', 'thinking');

        if (editor && typeof editor.dispose === 'function') {
            try {
                editor.dispose();
            } catch (disposeError) {
                console.warn('Monaco dispose error:', disposeError);
            }
            editor = null;
        }

        require.config({
            paths: {
                vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.48.0/min/vs'
            },
            waitSeconds: 30
        });

        require.onError = (err) => {
            console.error('Monaco Loader Error:', err);
            setStatus(`Failed to load editor: ${err?.message || 'Network error'}`, 'error');
            renderChat(`
**❌ Editor Failed to Load**

**Cause**: Could not load Monaco Editor from CDN.

**Solutions**:
1. **Check your internet connection**
2. **Try refreshing the page** (Ctrl+R)
3. **If behind a firewall**, download Monaco locally

**Technical Details**: ${err?.message || 'Unknown network error'}
`, 'error');
        };

        let loadAttempts = 0;
        const maxAttempts = 3;

        const initialCodeTemplate = `// Welcome to the Agentic Developer Workbench!
// Use the chat on the right to interact with the multi-agent system.

function calculate(a, b) {
    // Current function is empty.
    // REQUEST: Add a function that calculates the sum of a and b, but first checks 
    // if both are numbers. If not, return an error message string.
    
    // Agent analysis will start once you send a prompt.
    return 0; 
}
`;

        function useFallbackEditor() {
            const editorDiv = el('#editor');
            editorDiv.innerHTML = `
                <textarea id="fallback-editor" 
                    style="width:100%; height:100%; background:#0f172a; color:#e2e8f0; border:none; padding:1rem; font-family:monospace; font-size:14px;"
                    placeholder="Monaco Editor failed to load. Fallback editor active."
                >${localStorage.getItem('wb-code') || initialCodeTemplate}</textarea>
            `;
            
            const fallback = el('#fallback-editor');
            fallback.addEventListener('input', () => {
                localStorage.setItem('wb-code', fallback.value);
            });
            
            editor = null;
            renderChat('⚠️ **Using Fallback Editor** - Monaco failed to load. Basic functionality only.', 'warn');
        }

        function loadMonaco() {
            loadAttempts++;

            require(['vs/editor/editor.main'], () => {
                const initialCode = localStorage.getItem('wb-code') || initialCodeTemplate;

                editor = monaco.editor.create(el('#editor'), {
                    value: initialCode,
                    language: 'javascript',
                    theme: 'vs-dark',
                    automaticLayout: true,
                    fontSize: 14,
                    fontFamily: 'Fira Code, ui-monospace, SFMono-Regular, Menlo, Monaco, monospace',
                    fontLigatures: true,
                    minimap: { enabled: true },
                    scrollBeyondLastLine: false,
                    wordWrap: 'on',
                    wrappingIndent: 'indent'
                });

                editor.onDidChangeCursorPosition(e => {
                    const pos = e.position;
                    el('#cursor-pos').textContent = `Ln ${pos.lineNumber}, Col ${pos.column}`;
                });

                editor.onDidChangeModelContent(() => {
                    clearTimeout(updateTimer);
                    updateTimer = setTimeout(() => {
                        try {
                            localStorage.setItem('wb-code', editor.getValue());
                        } catch (storageError) {
                            console.warn('Failed to persist editor content:', storageError);
                        }
                    }, 500);
                });

                setStatus('Editor ready', 'ok');
            }, (err) => {
                console.error(`Monaco load attempt ${loadAttempts} failed:`, err);
                if (loadAttempts < maxAttempts) {
                    setStatus(`Retrying editor load... (${loadAttempts}/${maxAttempts})`, 'warn');
                    setTimeout(loadMonaco, 1000);
                } else {
                    setStatus('Editor load failed. Using fallback.', 'error');
                    useFallbackEditor();
                }
            });
        }

        loadMonaco();
    }

    // --- Main Application Entry Point ---

    window.onload = function() {
        initMonacoEditor();
        aiAdapter.checkOllamaHealth();
    };

</script>
</body>
</html>
